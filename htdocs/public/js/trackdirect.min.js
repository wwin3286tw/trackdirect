var trackdirect = {
    services: {},
    models: {},
    _time: null,
    _timetravel: null,
    _center: null,
    _zoom: null,
    _maptype: null,
    _mid: null,
    _rulers: [],
    _filterTimeoutId: null,
    _waitForFilterResponse: false,
    _doNotChangeLocationOnFilterResponse: false,
    _doNotChangeLocationOnFilterResponseTmp: false,
    _filters: {},
    _defaultLatitude: null,
    _defaultLongitude: null,
    _eventListeners: {},
    _eventListenersOnce: {},
    _coordinatesContainerElementId: null,
    _statusContainerElementId: "td-status-text",
    _mapElementId: null,
    _wsServerUrl: null,
    _map: null,
    _websocket: null,
    _mapCreated: false,
    _trackdirectInitDone: false,
    isMobile: false,
    coverageDataUrl: null,
    coveragePercentile: 95,
    settings: {},
    init: function (wsServerUrl, mapElementId, options) {
        this._initSettings();
        this._wsServerUrl = wsServerUrl;
        this._mapElementId = mapElementId;
        if ($("#" + mapElementId).length <= 0) {
            console.log("ERROR: Specified map element missing");
            return;
        }
        if (typeof google === "object" && typeof google.maps === "object") {
            this.settings.defaultMinZoomForMarkerLabel = 12;
            this.settings.minZoomForMarkerLabel = 12;
        }
        this._parseOptions(options);
        var me = this;
        this.addListener("map-created", function () {
            me._initTime();
            me._websocket = new trackdirect.Websocket(me._wsServerUrl);
            me._initWebsocketListeners();
            me._handleWebsocketStateChange();
            me._initMapListeners();
            if (!me._initFilterUrlRequest()) {
                trackdirect.services.callbackExecutor.add(me, me._sendPositionRequest, []);
            }
            me._setWebsocketStateIdle();
            if (inIframe()) {
                var parentUrl = "";
                try {
                    parentUrl = window.location != window.parent.location ? document.referrer : document.location.href;
                } catch (e) {
                    parentUrl = "Unknown";
                }
            }
            me._emitEventListeners("trackdirect-init-done");
        });
        this._mapInit(options);
    },
    enableImperialUnits: function () {
        this._map.state.useImperialUnit = true;
        if (this._map.state.openInfoWindow !== null) {
            this._map.state.openInfoWindow.hide();
        }
    },
    enableMetricUnits: function () {
        this._map.state.useImperialUnit = false;
        if (this._map.state.openInfoWindow !== null) {
            this._map.state.openInfoWindow.hide();
        }
    },
    toggleImperialUnits: function () {
        if (this._map.state.useImperialUnit) {
            this.enableMetricUnits();
        } else {
            this.enableImperialUnits();
        }
    },
    isImperialUnits: function () {
        return this._map.state.useImperialUnit;
    },
    addListener: function (event, handler, execOnce) {
        execOnce = typeof execOnce !== "undefined" ? execOnce : false;
        if ((event == "map-created" && this._mapCreated) || (event == "trackdirect-init-done" && this._trackdirectInitDone)) {
            handler();
            if (execOnce) {
                return;
            }
        }
        if (execOnce) {
            if (!(event in this._eventListenersOnce)) {
                this._eventListenersOnce[event] = [];
            }
            this._eventListenersOnce[event].push(handler);
        } else {
            if (!(event in this._eventListeners)) {
                this._eventListeners[event] = [];
            }
            this._eventListeners[event].push(handler);
        }
    },
    setCenter: function (latitude, longitude, zoom) {
        latitude = typeof latitude !== "undefined" ? latitude : this._defaultLatitude;
        longitude = typeof longitude !== "undefined" ? longitude : this._defaultLongitude;
        zoom = typeof zoom !== "undefined" ? zoom : this._map.getZoom();
        if (this._map !== null) {
            this._map.setCenter({ lat: latitude, lng: longitude }, zoom);
        }
    },
    setZoom: function (value) {
        if (this._map !== null) {
            this._map.setZoom(value);
        }
    },
    addRuler: function () {
        if (this._rulers.length > 0) {
            var ruler = this._rulers.pop();
            ruler.hide();
        } else {
            var ruler = new trackdirect.models.Ruler((this._map.getCurrentRadiusInKm() * 1000) / 2, this._map);
            this._rulers.push(ruler);
        }
    },
    isFilteredMode: function () {
        return this._map.state.isFilterMode;
    },
    stopFilterOnStationId: function (stationId) {
        var currentFilterStationIds = this._map.state.getFilterStationIds();
        if (currentFilterStationIds.length == 1 && currentFilterStationIds.indexOf(stationId) >= 0) {
            this.filterOnStationId([]);
        } else {
            if (this._map.state.getTrackStationId() == stationId) {
                this.stopTrackStation();
            }
            this._setWebsocketStateLoading(false);
            this._websocket.doSendStopFilterRequest(stationId);
        }
    },
    filterOnStationId: function (stationIdArray) {
        if (!Array.isArray(stationIdArray)) {
            stationIdArray = [stationIdArray];
        }
        var currentFilterStationIds = this._map.state.getFilterStationIds();
        if (currentFilterStationIds.length == 0) {
            if (this._map.state.getTrackStationId() !== null && stationIdArray.indexOf(this._map.state.getTrackStationId()) == -1) {
                this.stopTrackStation();
            }
        }
        this._setWebsocketStateLoading(false);
        this._websocket.doSendFilterRequest(stationIdArray, this._map.state.getTimeLength() / 60, this.getTimeTravelTimestamp());
    },
    filterOnStationName: function (stationNameArray) {
        if (!Array.isArray(stationNameArray)) {
            stationNameArray = [stationNameArray];
        }
        var currentFilterStationIds = this._map.state.getFilterStationIds();
        if (currentFilterStationIds.length == 0) {
            if (this._map.state.getTrackStationId() !== null && stationIdArray.indexOf(this._map.state.getTrackStationId()) == -1) {
                this.stopTrackStation();
            }
        }
        this._setWebsocketStateLoading(false);
        this._websocket.doSendFilterRequestByName(stationNameArray, this._map.state.getTimeLength() / 60, this.getTimeTravelTimestamp());
    },
    stopTrackStation: function () {
        this._map.state.onlyTrackRecentPackets = false;
        this._map.state.trackStationId = null;
        this._emitEventListeners("track-changed", [null, null]);
    },
    trackStation: function (stationId, stationName, alsoFilterOnStation, onlyTrackRecentPackets) {
        onlyTrackRecentPackets = typeof onlyTrackRecentPackets !== "undefined" ? onlyTrackRecentPackets : false;
        if (alsoFilterOnStation) {
            var currentFilterStationIds = this._map.state.getFilterStationIds();
            if (currentFilterStationIds.length > 0) {
                if (currentFilterStationIds.indexOf(stationId) == -1) {
                    this.filterOnStationId(stationId);
                }
            }
        }
        if (stationId !== null) {
            var trackLinkElementClass = "trackStationLink" + stationId;
            $("." + trackLinkElementClass).html("Untrack");
        }
        if (this._map.state.trackStationId !== null) {
            var trackLinkElementClass = "trackStationLink" + this._map.state.trackStationId;
            $("." + trackLinkElementClass).html("Track");
        }
        this._map.state.onlyTrackRecentPackets = onlyTrackRecentPackets;
        this._map.state.trackStationId = stationId;
        this._emitEventListeners("track-changed", [stationId, stationName]);
    },
    focusOnStation: function (stationId, openInfoWindow) {
        var map = this._map;
        openInfoWindow = typeof openInfoWindow !== "undefined" ? openInfoWindow : false;
        var marker = map.markerCollection.getStationLatestMarker(stationId);
        if (marker !== null) {
            marker.show();
            marker.showLabel();
            if (openInfoWindow) {
                map.openMarkerInfoWindow(marker, false);
            } else {
                this.setCenter(marker.packet.latitude, marker.packet.longitude);
            }
            marker.hide(5000, true);
            return true;
        } else {
            return false;
        }
    },
    focusOnMarkerId: function (markerId, zoom) {
        var map = this._map;
        var markerIdKey = map.markerCollection.getMarkerIdKey(markerId);
        if (map.markerCollection.isExistingMarker(markerIdKey)) {
            var marker = map.markerCollection.getMarker(markerIdKey);
            if (map.markerCollection.hasRelatedDashedPolyline(marker)) {
                newerMarker = map.markerCollection.getMarker(marker._relatedMarkerOriginDashedPolyLine.ownerMarkerIdKey);
                if (newerMarker.packet.hasConfirmedMapId()) {
                    return this.focusOnMarkerId(newerMarker.packet.marker_id);
                }
            }
            marker.show();
            marker.showLabel();
            this.setCenter(marker.packet.latitude, marker.packet.longitude, zoom);
            map.openMarkerInfoWindow(marker);
            marker.hide(5000, true);
        }
    },
    toggleStationCoverage: function (stationId, coverageLinkElementClass) {
        coverageLinkElementClass = typeof coverageLinkElementClass !== "undefined" ? coverageLinkElementClass : null;
        var coveragePolygon = this._map.markerCollection.getStationCoverage(stationId);
        if (coveragePolygon !== null && coveragePolygon.isRequestedToBeVisible()) {
            coveragePolygon.hide();
            if (coverageLinkElementClass !== null) {
                $("." + coverageLinkElementClass).html("Coverage");
            }
        } else {
            if (coveragePolygon !== null) {
                coveragePolygon.show();
                if (!coveragePolygon.hasContent()) {
                    alert("Currently we do not have enough data to create a max range coverage plot for this station. Try again later!");
                } else {
                    if (coverageLinkElementClass !== null) {
                        $("." + coverageLinkElementClass).html("Hide coverage");
                    }
                }
            } else {
                var packet = this._map.markerCollection.getStationLatestPacket(stationId);
                var center = { lat: parseFloat(packet.latitude), lng: parseFloat(packet.longitude) };
                var coveragePolygon = new trackdirect.models.StationCoveragePolygon(center, this._map, true);
                this._map.markerCollection.addStationCoverage(stationId, coveragePolygon);
                coveragePolygon.showWhenDone();
                if (coverageLinkElementClass !== null) {
                    $("." + coverageLinkElementClass).html('Loading <i class="fa fa-spinner fa-spin" style="font-size:12px"></i>');
                    coveragePolygon.addTdListener(
                        "visible",
                        function () {
                            if (!coveragePolygon.hasContent()) {
                                coveragePolygon.hide();
                                alert("Currently we do not have enough data to create a max range coverage plot for this station. Try again later!");
                                $("." + coverageLinkElementClass).html("Coverage");
                            } else {
                                $("." + coverageLinkElementClass).html("Hide coverage");
                            }
                        },
                        true
                    );
                }
                var me = this;
                $.getJSON(this.coverageDataUrl + "?id=" + stationId, function (data) {
                    if ("station_id" in data && "coverage" in data) {
                        coveragePolygon.setData(data["coverage"], me.coveragePercentile);
                        var marker = me._map.markerCollection.getStationLatestMarker(stationId);
                        if (marker.isVisible()) {
                            if (coveragePolygon.isRequestedToBeVisible()) {
                                coveragePolygon.show();
                            }
                        }
                    }
                })
                    .fail(function () {
                        coveragePolygon.hide();
                        alert("Failed to fetch coverage data. Try again later!");
                        $("." + coverageLinkElementClass).html("Coverage");
                    })
                    .always(function () {});
            }
        }
    },
    setMapType: function (mapType) {
        if (this._map !== null) {
            this._map.setMapType(mapType);
        }
    },
    getMapType: function () {
        if (this._map !== null) {
            return this._map.getMapType();
        }
    },
    setMapDefaultLocation: function (setDefaultZoom) {
        this._map.setMapDefaultLocation(setDefaultZoom);
    },
    setMapLocationByGeoLocation: function (failCallBack, successCallBack, timeout) {
        var me = this;
        if (navigator && navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                function (position) {
                    var pos = { lat: position.coords.latitude, lng: position.coords.longitude };
                    me._map.setCenter(pos, 12);
                    if (successCallBack !== null) {
                        successCallBack();
                    }
                },
                function (error) {
                    if (failCallBack !== null) {
                        failCallBack(error.message);
                    }
                },
                { enableHighAccuracy: false, timeout: timeout, maximumAge: 5000 }
            );
        } else {
            if (failCallBack !== null) {
                failCallBack();
            }
        }
    },
    openStationInformationDialog: function (stationId) {
        var packet = this._map.markerCollection.getStationLatestPacket(stationId);
        if (packet == null) {
            packet = { station_id: stationId, id: null };
        }
        this._emitEventListeners("station-name-clicked", packet);
    },
    openMarkerInfoWindow: function (markerId) {
        var markerIdKey = this._map.markerCollection.getMarkerIdKey(markerId);
        if (this._map.markerCollection.isExistingMarker(markerIdKey)) {
            var marker = this._map.markerCollection.getMarker(markerIdKey);
            this._map.openMarkerInfoWindow(marker);
        }
    },
    closeAnyOpenInfoWindow: function () {
        if (this._map !== null) {
            var state = this._map.state;
            if (state.isInfoWindowOpen()) {
                state.openInfoWindow.hide();
            }
        }
    },
    setTimeTravelTimestamp: function (ts, sendRequestToServer) {
        if (ts != 0 || this._map.state.endTimeTravelTimestamp != null) {
            sendRequestToServer = typeof sendRequestToServer !== "undefined" ? sendRequestToServer : true;
            if (this._map.state.endTimeTravelTimestamp != ts) {
                if (ts != null && ts != 0 && ts != "") {
                    this._map.state.endTimeTravelTimestamp = ts;
                } else {
                    this._map.state.endTimeTravelTimestamp = null;
                }
                if (sendRequestToServer) {
                    trackdirect.services.callbackExecutor.add(this, this._handleTimeChange, []);
                }
            }
            this._emitEventListeners("time-travel-changed", ts);
            this._emitEventListeners("mode-changed");
        }
    },
    getTimeTravelTimestamp: function () {
        return this._map.state.endTimeTravelTimestamp;
    },
    setTimeLength: function (time, sendRequestToServer) {
        sendRequestToServer = typeof sendRequestToServer !== "undefined" ? sendRequestToServer : true;
        if (this._map.state.getTimeLength() / 60 != time) {
            this._map.state.setTimeLength(time * 60);
            if (sendRequestToServer) {
                trackdirect.services.callbackExecutor.add(this, this._handleTimeChange, []);
            }
        }
        this._emitEventListeners("time-length-changed", time);
        this._updateMinZoomLevels();
    },
    togglePHGCircles: function () {
        var state = this._map.state;
        if (state.showPHGCircles == 0) {
            state.showPHGCircles = 1;
        } else if (state.showPHGCircles == 1) {
            state.showPHGCircles = 2;
        } else {
            state.showPHGCircles = 0;
        }
        this._map.showHidePHGCircles();
    },
    toggleRNGCircles: function () {
        var state = this._map.state;
        if (state.showRNGCircles == 0) {
            state.showRNGCircles = 1;
        } else if (state.showRNGCircles == 1) {
            state.showRNGCircles = 2;
        } else {
            state.showRNGCircles = 0;
        }
        this._map.showHideRNGCircles();
    },
    toggleStationaryPositions: function () {
        if (this.isStationaryMarkersVisible()) {
            this._map.state.isStationaryMarkersVisible = false;
        } else {
            this._map.state.isStationaryMarkersVisible = true;
        }
        this._map.showHideMarkers();
    },
    toggleUnknownPositions: function () {
        if (this.isUnknownMarkersVisible()) {
            this._map.state.isUnknownMarkersVisible = false;
        } else {
            this._map.state.isUnknownMarkersVisible = true;
        }
        this._map.showHideMarkers();
    },
    toggleOgflymPositions: function () {
        if (this.isOgflymMarkersVisible()) {
            this._map.state.isOgflymMarkersVisible = false;
        } else {
            this._map.state.isOgflymMarkersVisible = true;
        }
        this._map.showHideMarkers();
    },
    toggleInternetPositions: function () {
        if (this.isInternetMarkersVisible()) {
            this._map.state.isInternetMarkersVisible = false;
        } else {
            this._map.state.isInternetMarkersVisible = true;
        }
        this._map.showHideMarkers();
    },
    toggleCwopPositions: function () {
        if (this.isCwopMarkersVisible()) {
            this._map.state.isCwopMarkersVisible = false;
        } else {
            this._map.state.isCwopMarkersVisible = true;
        }
        this._map.showHideMarkers();
    },
    toggleGhostPositions: function () {
        if (this.isGhostMarkersVisible()) {
            this._map.state.isGhostMarkersVisible = false;
        } else {
            this._map.state.isGhostMarkersVisible = true;
        }
        this._map.showHideMarkers();
    },
    isGhostMarkersVisible: function () {
        return this._map.state.isGhostMarkersVisible;
    },
    isCwopMarkersVisible: function () {
        return this._map.state.isCwopMarkersVisible;
    },
    isInternetMarkersVisible: function () {
        return this._map.state.isInternetMarkersVisible;
    },
    isStationaryMarkersVisible: function () {
        return this._map.state.isStationaryMarkersVisible;
    },
    setVisibleSymbols: function (symbols) {
        this._map.state.visibleSymbols = symbols;
        this._map.showHideMarkers();
    },
    addVisibleSymbol: function (symbol) {
        this._map.state.visibleSymbols.push(symbol);
        this._map.showHideMarkers();
    },
    removeVisibleSymbol: function (symbol) {
        var indexToRemove = null;
        for (var i = 0; i < this._map.state.visibleSymbols.length; i++) {
            if (this._map.state.visibleSymbols[i][0] == symbol[0] && this._map.state.visibleSymbols[i][1] == symbol[1]) {
                indexToRemove = i;
                break;
            }
        }
        if (indexToRemove !== null) {
            this._map.state.visibleSymbols.splice(indexToRemove, 1);
        }
        this._map.showHideMarkers();
    },
    getVisibleSymbols: function () {
        return this._map.state.visibleSymbols;
    },
    isUnknownMarkersVisible: function () {
        return this._map.state.isUnknownMarkersVisible;
    },
    isOgflymMarkersVisible: function () {
        return this._map.state.isOgflymMarkersVisible;
    },
    handleFilterStationRequest: function (stationId, filterLinkElementClass) {
        filterLinkElementClass = typeof filterLinkElementClass !== "undefined" ? filterLinkElementClass : null;
        if (this._map.state.filterStationIds.length > 0 && this._map.state.filterStationIds.indexOf(stationId) > -1) {
            this.stopFilterOnStationId(stationId);
            if (filterLinkElementClass !== null) {
                $("." + filterLinkElementClass).html("Filter");
            }
        } else {
            this.filterOnStationId(stationId);
            if (filterLinkElementClass !== null) {
                $("." + filterLinkElementClass).html("Unfilter");
            }
        }
    },
    handleTrackStationRequest: function (stationId, trackLinkElementClass) {
        stationId = typeof stationId !== "undefined" ? stationId : 0;
        trackLinkElementClass = typeof trackLinkElementClass !== "undefined" ? trackLinkElementClass : null;
        if (this._map.state.getTrackStationId() !== null && (stationId === 0 || this._map.state.getTrackStationId() == stationId)) {
            if (trackLinkElementClass !== null) {
                $("." + trackLinkElementClass).html("Track");
            } else if (this._map.state.openInfoWindow !== null) {
                this._map.state.openInfoWindow.hide();
            }
            this.stopTrackStation();
        } else if (stationId !== 0) {
            if (trackLinkElementClass !== null) {
                $("." + trackLinkElementClass).html("Untrack");
            }
            var packet = this._map.markerCollection.getStationLatestPacket(stationId);
            if (packet !== null) {
                var stationName = packet.station_name;
                if (packet.sender_name != packet.station_name) {
                    stationName = packet.station_name + " (" + packet.sender_name + ")";
                }
                this.trackStation(stationId, stationName, true);
            }
        }
    },
    _initSettings: function () {
        this.settings = {
            animate: true,
            defaultMinZoomForMarkerLabel: 11,
            defaultMinZoomForMarkerPrevPosition: 11,
            defaultMinZoomForMarkerTail: 9,
            defaultMinZoomForMarkers: 8,
            minZoomForMarkerLabel: 11,
            minZoomForMarkerPrevPosition: 11,
            minZoomForMarkerTail: 9,
            minZoomForMarkers: 8,
            markerSymbolBaseDir: "/symbols/",
            imagesBaseDir: "/images/",
            defaultCurrentZoom: 11,
            defaultCurrentZoomMobile: 11,
            dateFormat: "L LTSZ",
            dateFormatNoTimeZone: "L LTS",
            host: "www.aprsdirect.com",
            baseUrl: "https://www.aprsdirect.com",
            defaultTimeLength: 60,
            symbolsToScale: [],
            primarySymbolWithNoDirectionPolyline: [87, 64, 95],
            alternativeSymbolWithNoDirectionPolyline: [40, 42, 64, 74, 84, 85, 96, 98, 101, 102, 112, 116, 119, 121, 123],
        };
    },
    _parseOptions: function (options) {
        if (typeof options["coordinatesContainerElementId"] !== undefined) {
            this._coordinatesContainerElementId = options["coordinatesContainerElementId"];
        }
        if (typeof options["statusContainerElementId"] !== undefined) {
            this._statusContainerElementId = options["statusContainerElementId"];
        }
        if (typeof options["isMobile"] !== undefined) {
            this.isMobile = options["isMobile"];
        }
        if (typeof options["coverageDataUrl"] !== undefined) {
            this.coverageDataUrl = options["coverageDataUrl"];
        }
        if (typeof options["coveragePercentile"] !== undefined) {
            this.coveragePercentile = options["coveragePercentile"];
        }
        if (typeof options["time"] !== undefined) {
            this._time = options["time"];
        }
        if (typeof options["timetravel"] !== undefined) {
            this._timetravel = options["timetravel"];
        }
        if (typeof options["center"] !== undefined) {
            this._center = options["center"];
        }
        if (typeof options["zoom"] !== undefined) {
            this._zoom = options["zoom"];
        }
        if (typeof options["maptype"] !== undefined) {
            this._maptype = options["maptype"];
        }
        if (typeof options["mid"] !== undefined) {
            this._mid = options["mid"];
        }
        if (typeof options["filters"] !== undefined && options["filters"] !== null) {
            for (var i in options["filters"]) {
                if (options["filters"][i] !== null && options["filters"][i] != "") {
                    this._filters[i] = options["filters"][i];
                }
            }
        }
        if (typeof options["disableLocationChangeOnFilterResponse"] !== undefined && options["disableLocationChangeOnFilterResponse"]) {
            this._doNotChangeLocationOnFilterResponse = true;
        }
        if (typeof options["defaultMinZoomForMarkerLabel"] !== undefined && options["defaultMinZoomForMarkerLabel"] != null) {
            this.settings.defaultMinZoomForMarkerLabel = options["defaultMinZoomForMarkerLabel"];
        }
        if (typeof options["defaultMinZoomForMarkerPrevPosition"] !== undefined && options["defaultMinZoomForMarkerPrevPosition"] != null) {
            this.settings.defaultMinZoomForMarkerPrevPosition = options["defaultMinZoomForMarkerPrevPosition"];
        }
        if (typeof options["defaultMinZoomForMarkerTail"] !== undefined && options["defaultMinZoomForMarkerTail"] != null) {
            this.settings.defaultMinZoomForMarkerTail = options["defaultMinZoomForMarkerTail"];
        }
        if (typeof options["defaultMinZoomForMarkers"] !== undefined && options["defaultMinZoomForMarkers"] != null) {
            this.settings.defaultMinZoomForMarkers = options["defaultMinZoomForMarkers"];
        }
        if (typeof options["animate"] !== undefined && options["animate"] != null) {
            this.settings.animate = options["animate"];
        }
        if (typeof options["host"] !== undefined && options["host"] != null) {
            this.settings.host = options["host"];
            this.settings.baseUrl = this._getMapBaseUrl(options["host"]);
        } else {
            this.settings.baseUrl = this._getMapBaseUrl();
        }
        if (typeof options["defaultTimeLength"] !== undefined && options["defaultTimeLength"] != null) {
            this.settings.defaultTimeLength = options["defaultTimeLength"];
        }
        if (typeof options["symbolsToScale"] !== undefined && options["symbolsToScale"] !== null) {
            this.settings.symbolsToScale = options["symbolsToScale"];
        }
        this._initDefaultLocation(options);
    },
    _initDefaultLocation: function (options) {
        if (typeof options["defaultLatitude"] !== "undefined" && typeof options["defaultLongitude"] !== "undefined") {
            this._defaultLatitude = options["defaultLatitude"];
            this._defaultLongitude = options["defaultLongitude"];
        } else {
            this._defaultLatitude = 0;
            this._defaultLongitude = 0;
        }
    },
    _initTime: function () {
        var filterMode = false;
        if ("sid" in this._filters || "sidlist" in this._filters || "sname" in this._filters || "snamelist" in this._filters) {
            filterMode = true;
        }
        if (this._time != null && this._isValidTime(this._time, filterMode)) {
            this.setTimeLength(this._time, false);
        } else {
            this.setTimeLength(this.settings.defaultTimeLength, false);
        }
        now = new Date();
        if (this._timetravel != null && this._timetravel >= 0 && this._timetravel <= now.getTime() / 1000) {
            this.setTimeTravelTimestamp(this._timetravel, false);
        }
        this._updateMinZoomLevels();
    },
    _mapInit: function (options) {
        if ("sid" in this._filters || "sidlist" in this._filters || "sname" in this._filters || "snamelist" in this._filters) {
            this._waitForFilterResponse = true;
            if (window.location.href.indexOf("/center/") >= 0) {
                this._doNotChangeLocationOnFilterResponseTmp = true;
            }
        }
        var tdMapOptions = this._getMapInitOptions(options);
        var me = this;
        $(document).ready(function () {
            me._map = new trackdirect.models.Map(me._mapElementId, tdMapOptions);
            me._markerCreator = new trackdirect.MarkerCreator(me._map);
            if (typeof options["useImperialUnit"] !== "undefined" && options["useImperialUnit"] == true) {
                me.enableImperialUnits();
            }
            me._emitEventListeners("map-created");
        });
    },
    _getMapInitOptions: function (options) {
        var center = this._getMapInitCenter();
        var tdMapOptions = {
            zoom: this._getMapInitZoom(),
            maptype: this._getMapInitMapType(),
            coordinatesContainer: this._coordinatesContainerElementId,
            defaultLatitude: this._defaultLatitude,
            defaultLongitude: this._defaultLongitude,
            initCenter: center,
            mid: this._getMapInitMid(),
        };
        if ("supportedMapTypes" in options) {
            tdMapOptions["supportedMapTypes"] = options["supportedMapTypes"];
        }
        if ("mapboxGLStyle" in options) {
            tdMapOptions["mapboxGLStyle"] = options["mapboxGLStyle"];
        }
        if ("mapboxGLAccessToken" in options) {
            tdMapOptions["mapboxGLAccessToken"] = options["mapboxGLAccessToken"];
        }
        if ("mapboxGLAttribution" in options) {
            tdMapOptions["mapboxGLAttribution"] = options["mapboxGLAttribution"];
        }
        return tdMapOptions;
    },
    _getMapInitCenter: function () {
        if (this._center != null) {
            var centerParts = this._center.split(",");
            if (centerParts.length == 2 && this._isValidLatitude(centerParts[0]) && this._isValidLongitude(centerParts[1])) {
                return { lat: parseFloat(centerParts[0]), lng: parseFloat(centerParts[1]) };
            }
        }
        return null;
    },
    _getMapInitZoom: function () {
        var zoom = null;
        if (this._zoom != null && this._isValidZoom(this._zoom)) {
            zoom = this._zoom;
        }
        return zoom;
    },
    _getMapInitMid: function () {
        var mid = null;
        if (this._mid != null) {
            mid = this._mid;
        }
        return mid;
    },
    _getMapInitMapType: function () {
        var maptype = null;
        if (this._maptype != null) {
            maptype = this._maptype;
        }
        return maptype;
    },
    _initFilterUrlRequest: function () {
        if ("sid" in this._filters) {
            stationId = this._filters["sid"];
            if (isNumeric(stationId)) {
                this.filterOnStationId(stationId);
            }
        } else if ("sname" in this._filters) {
            stationName = this._filters["sname"];
            if (stationName != "") {
                this.filterOnStationName(stationName);
            }
        } else if ("sidlist" in this._filters) {
            stationIdArray = this._filters["sidlist"].split(",");
            var isValid = true;
            for (var i = 0; i < stationIdArray.length; i++) {
                if (!isNumeric(stationIdArray[i])) {
                    isValid = false;
                }
            }
            if (isValid) {
                this.filterOnStationId(stationIdArray);
            }
        } else if ("snamelist" in this._filters) {
            stationNameArray = this._filters["snamelist"].split(",");
            var isValid = true;
            for (var i = 0; i < stationNameArray.length; i++) {
                if (typeof stationNameArray[i] == "undefined" || stationNameArray[i] == "") {
                    isValid = false;
                }
            }
            if (isValid) {
                this.filterOnStationName(stationNameArray);
            }
        } else {
            return false;
        }
        var me = this;
        this._filterTimeoutId = window.setTimeout(function () {
            if (me._waitForFilterResponse) {
                me._waitForFilterResponse = false;
                trackdirect.services.callbackExecutor.add(me, me._sendPositionRequest, []);
            }
        }, 5000);
        return true;
    },
    _isValidTime: function (time, filteredMode) {
        if (isNumeric(time)) {
            if (filteredMode && time <= 14400 && time > 0) {
                return true;
            } else if (filteredMode == false && time <= 1440 && time > 0) {
                return true;
            }
        }
        return false;
    },
    _isValidZoom: function (zoom) {
        if (isNumeric(zoom)) {
            if (zoom <= 21 && zoom >= 0) {
                return true;
            }
        }
        return false;
    },
    _isValidLatitude: function (lat) {
        if (isNumeric(lat)) {
            if (lat <= 90 && lat >= -90) {
                return true;
            }
        }
        return false;
    },
    _isValidLongitude: function (lng) {
        if (isNumeric(lng)) {
            if (lng <= 180 && lng >= -180) {
                return true;
            }
        }
        return false;
    },
    _initMapListeners: function () {
        var me = this;
        this._map.addTdListener("change", function () {
            trackdirect.services.callbackExecutor.add(me, me._sendPositionRequest, []);
            trackdirect.services.mapAttributionModifier.update(me._map);
        });
        this._map.addTdListener("moving", function () {
            trackdirect.services.callbackExecutor.addIfUnique(me, me._sendIdleRequest, []);
        });
        this._map.addTdListener("station-tail-needed", function (stationId) {
            me._websocket.doSendCompleteStationRequest(stationId, me._map.state.getTimeLength() / 60, me.getTimeTravelTimestamp());
        });
        this._map.addTdListener("station-information", function (stationId) {
            me.openStationInformationDialog(stationId);
        });
    },
    _initWebsocketListeners: function () {
        this._initWebsocketStateChangeListener();
        this._initWebsocketAprsPacketListener();
        this._initWebsocketPayloadDoneListener();
        this._initWebsocketFilterResponseListener();
        this._initWebsocketServerTimestampResponseListener();
        this._initWebsocketResetListener();
    },
    _initWebsocketStateChangeListener: function () {
        var me = this;
        this._websocket.addListener("state-change", function () {
            var callback = function () {
                me._handleWebsocketStateChange();
            };
            trackdirect.services.callbackExecutor.add(this, callback, []);
        });
    },
    _initWebsocketAprsPacketListener: function () {
        var me = this;
        this._websocket.addListener("aprs-packet", function (packetData) {
            var packet = new trackdirect.models.Packet(packetData);
            var queueTimestamp = Math.floor(Date.now() / 1000);
            var callback = function () {
                var dequeueTimestamp = Math.floor(Date.now() / 1000);
                if (dequeueTimestamp - queueTimestamp > 5 || !this.settings.animate) {
                    me._handleAprsPacket(packet, false);
                } else {
                    me._handleAprsPacket(packet, true);
                }
            };
            trackdirect.services.callbackExecutor.add(me, callback, []);
        });
    },
    _initWebsocketPayloadDoneListener: function () {
        var me = this;
        this._websocket.addListener("aprs-packet-payload-done", function () {
            var callback = function () {
                me._map.showNewMarkersInQueue(true);
            };
            trackdirect.services.callbackExecutor.add(this, callback, []);
        });
    },
    _initWebsocketFilterResponseListener: function () {
        var me = this;
        this._websocket.addListener("filter-response", function (data) {
            var callback = function () {
                me._handleFilterResponse(data);
            };
            trackdirect.services.callbackExecutor.add(this, callback, []);
        });
    },
    _initWebsocketServerTimestampResponseListener: function () {
        var me = this;
        this._websocket.addListener("server-timestamp-response", function (data) {
            var callback = function () {
                me._map.state.setServerCurrentTimestamp(data.timestamp);
            };
            trackdirect.services.callbackExecutor.add(this, callback, []);
            if (me._map.getNumberOfNewMarkersToShow() > 0) {
                var callback2 = function () {
                    me._map.showNewMarkersInQueue(true);
                };
                trackdirect.services.callbackExecutor.addIfUnique(this, callback2, []);
            }
        });
    },
    _initWebsocketResetListener: function () {
        var me = this;
        this._websocket.addListener("reset", function () {
            trackdirect.services.callbackExecutor.add(me._map, me._map.resetAllMarkers, []);
        });
    },
    _updateMinZoomLevels: function () {
        if (this._map.state.getTimeLength() / 60 > 720) {
            trackdirect.settings.minZoomForMarkerPrevPosition = trackdirect.settings.defaultMinZoomForMarkerPrevPosition + 1;
            trackdirect.settings.minZoomForMarkerTail = trackdirect.settings.defaultMinZoomForMarkerTail + 1;
            trackdirect.settings.minZoomForMarkerLabel = trackdirect.settings.defaultMinZoomForMarkerLabel + 1;
            trackdirect.settings.minZoomForMarkers = trackdirect.settings.defaultMinZoomForMarkers;
        } else {
            trackdirect.settings.minZoomForMarkerPrevPosition = trackdirect.settings.defaultMinZoomForMarkerPrevPosition;
            trackdirect.settings.minZoomForMarkerTail = trackdirect.settings.defaultMinZoomForMarkerTail;
            trackdirect.settings.minZoomForMarkerLabel = trackdirect.settings.defaultMinZoomForMarkerLabel;
            trackdirect.settings.minZoomForMarkers = trackdirect.settings.defaultMinZoomForMarkers;
        }
    },
    _handleTimeChange: function () {
        this._updateMinZoomLevels();
        this._map.resetAllMarkers();
        this._websocket.clearLastSentPositionRequest();
        trackdirect.services.callbackExecutor.add(this, this._sendPositionRequest, []);
        this._emitEventListeners("mode-changed");
    },
    _handleFilterResponse: function (data) {
        if (this._filterTimeoutId !== null) {
            clearTimeout(this._filterTimeoutId);
            this._filterTimeoutId = null;
        }
        if (data.length == 0) {
            this._handleEmptyFilterResponse();
        } else {
            this._handleNonEmptyFilterResponse(data);
        }
    },
    _unMarkMissingStationsAsFiltered: function (data) {
        var filterStationIds = this._map.state.getFilterStationIds();
        for (var key in filterStationIds) {
            var stationId = filterStationIds[key];
            var foundStation = false;
            for (var i = 0; i < data.length; i++) {
                var packetData = data[i];
                if (packetData.station_id == stationId && packetData["related"] == 0) {
                    foundStation = true;
                }
            }
            if (!foundStation) {
                this._unMarkStationAsFiltered(stationId);
            }
        }
    },
    _unMarkStationAsFiltered: function (stationId) {
        var map = this._map;
        var index = map.state.filterStationIds.indexOf(stationId);
        if (index > -1) {
            map.state.filterStationIds.splice(index, 1);
            var filterLinkElementClass = "filterStationLink" + stationId;
            $("." + filterLinkElementClass).html("Filter");
            for (var markerIdKey in map.markerCollection.getStationMarkerIdKeys(stationId)) {
                var marker = this._map.markerCollection.getMarker(markerIdKey);
                if (marker !== null) {
                    marker.hideCompleteMarker();
                }
            }
        }
    },
    _getNumberOfUniqeStationsInArray: function (data) {
        var numberOfStationPackets = 0;
        for (var i = 0; i < data.length; i++) {
            var packetData = data[i];
            if (packetData["related"] == 0) {
                numberOfStationPackets++;
            }
        }
        return numberOfStationPackets;
    },
    _trackStationInArray: function (data, onlyTrackRecentPackets) {
        if (this._getNumberOfUniqeStationsInArray(data) == 1) {
            for (var i = 0; i < data.length; i++) {
                var packet = new trackdirect.models.Packet(data[i]);
                if (packet["related"] == 0) {
                    this.trackStation(packet.station_id, escapeHtml(packet.getStationName()), false, onlyTrackRecentPackets);
                }
            }
        }
    },
    _addFilterResponsePacketsToMap: function (data) {
        var tryToShowPacket = this._isAnyPacketInArrayOlderThanCurrentLimit(data);
        for (var i = 0; i < data.length; i++) {
            var packet = new trackdirect.models.Packet(data[i]);
            if (packet["related"] == 0) {
                this._markStationAsFiltered(packet.station_id);
            }
            var markerIdKey = this._markerCreator.addPacket(packet, tryToShowPacket);
            var marker = this._map.markerCollection.getMarker(markerIdKey);
            if (marker !== null) {
                marker.markToBeOverWritten();
            }
        }
    },
    _markStationAsFiltered: function (stationId) {
        var map = this._map;
        if (map.state.filterStationIds.indexOf(stationId) == -1) {
            map.state.filterStationIds.push(stationId);
        }
        var filterLinkElementClass = "filterStationLink" + stationId;
        $("." + filterLinkElementClass).html("Unfilter");
        for (var markerIdKey in map.markerCollection.getStationMarkerIdKeys(stationId)) {
            var marker = this._map.markerCollection.getMarker(markerIdKey);
            if (marker !== null) {
                marker.showCompleteMarker();
            }
        }
    },
    _handleNonEmptyFilterResponse: function (data) {
        var isFilterModeNew = !this.isFilteredMode();
        this._map.activateFilteredMode();
        this._waitForFilterResponse = false;
        if (isFilterModeNew) {
            this._map.resetAllMarkers();
            this._emitEventListeners("mode-changed");
        } else {
            this._unMarkMissingStationsAsFiltered(data);
        }
        this._addFilterResponsePacketsToMap(data);
        var packets = [];
        for (var i = 0; i < data.length; i++) {
            packets.push(new trackdirect.models.Packet(data[i]));
        }
        this._emitEventListeners("filter-changed", packets);
        if (isFilterModeNew) {
            var onlyTrackRecentPackets = true;
            if (!this._doNotChangeLocationOnFilterResponse && !this._doNotChangeLocationOnFilterResponseTmp) {
                onlyTrackRecentPackets = false;
                this._setFilteredMapBounds(data);
            }
            this._doNotChangeLocationOnFilterResponseTmp = false;
            this._trackStationInArray(data, onlyTrackRecentPackets);
            this._emitEventListeners("filter-new");
        }
        trackdirect.services.callbackExecutor.add(this, this._requestFilteredUpdate, []);
    },
    _requestFilteredUpdate: function () {
        this._websocket.clearLastSentPositionRequest();
        this._setWebsocketStateLoading(false);
        this._websocket.doSendNewPositionRequest(90, 180, -90, -180, this._map.state.getTimeLength() / 60, this.getTimeTravelTimestamp(), false);
    },
    _handleEmptyFilterResponse: function () {
        this._deactivateFiltered(true);
        this._waitForFilterResponse = false;
    },
    _isAnyPacketInArrayOlderThanCurrentLimit: function (data) {
        for (var i = 0; i < data.length; i++) {
            var packetData = data[i];
            if (packetData["related"] == 0) {
                if (packetData.timestamp < packetData.requested_timestamp + 60) {
                    return true;
                }
                if (packetData["source"] == 0 || packetData["source_id"] == 0) {
                    return true;
                }
            }
        }
        return false;
    },
    _setFilteredMapBounds: function (data) {
        if (data.length == 1) {
            this._map.setCenter({ lat: parseFloat(data[0].latitude), lng: parseFloat(data[0].longitude) }, 12);
        } else {
            var positions = [];
            for (var i = 0; i < data.length; i++) {
                var packetData = data[i];
                if (packetData["related"] == 0) {
                    positions.push({ lat: parseFloat(packetData.latitude), lng: parseFloat(packetData.longitude) });
                }
            }
            this._map.fitBounds(positions);
            if (this._map.getZoom() > 12) {
                this._map.setZoom(12);
            }
        }
    },
    _handleAprsPacket: function (packet, animate) {
        var markerIdKey = this._markerCreator.addPacket(packet, true);
        if (markerIdKey !== null) {
            var highlight = false;
            var autoRender = false;
            var marker = this._map.markerCollection.getMarker(markerIdKey);
            if (animate && packet.db == 0 && packet.station_name == packet.sender_name && marker.shouldMarkerBeVisible() && (this.isFilteredMode() || this._isPacketOnMap(packet))) {
                highlight = true;
                var tdTransmitAnimation = new trackdirect.models.TransmitAnimation(marker, this._map);
                tdTransmitAnimation.show();
            }
            if (packet.realtime == 1 && animate) {
                autoRender = true;
            }
        }
    },
    _linkifyPacketRaw: function (packet) {
        if (typeof packet.raw !== "undefined" && typeof packet.raw == "string") {
            var raw = escapeHtml(packet.raw);
            var stationNameReplacement = '<a href="#" onclick="trackdirect.focusOnMarkerId(' + packet.marker_id + '); return false;">' + escapeHtml(packet.sender_name) + "</a>";
            raw = raw.replaceAll(escapeHtml(packet.sender_name) + "&gt;", stationNameReplacement + "&gt;");
            for (var i = 0; i < packet.station_id_path.length; i++) {
                var relatedStationId = packet.station_id_path[i];
                var relatedStationLatestPacket = this._map.markerCollection.getStationLatestPacket(relatedStationId);
                if (relatedStationLatestPacket !== null) {
                    var relatedStationNameReplacement = '<a href="#" onclick="trackdirect.focusOnStation(' + relatedStationId + ', true); return false;">' + escapeHtml(relatedStationLatestPacket.sender_name) + "</a>";
                    var relatedStationSenderName = escapeHtml(relatedStationLatestPacket.sender_name);
                    raw = raw.replaceAll("&gt;" + relatedStationSenderName + ":", "&gt;" + relatedStationNameReplacement + ":");
                    raw = raw.replaceAll("&gt;" + relatedStationSenderName + ",", "&gt;" + relatedStationNameReplacement + ",");
                    raw = raw.replaceAll("&gt;" + relatedStationSenderName + "*", "&gt;" + relatedStationNameReplacement + "*");
                    raw = raw.replaceAll("," + relatedStationSenderName + ":", "," + relatedStationNameReplacement + ":");
                    raw = raw.replaceAll("," + relatedStationSenderName + ",", "," + relatedStationNameReplacement + ",");
                    raw = raw.replaceAll("," + relatedStationSenderName + "*", "," + relatedStationNameReplacement + "*");
                }
            }
            raw = Autolinker.link(raw, { newWindow: true });
            return raw;
        }
        return "";
    },
    _isPacketOnMap: function (packet) {
        if (packet.latitude <= this._map.getNorthEastLat() && packet.latitude >= this._map.getSouthWestLat()) {
            if (packet.longitude <= this._map.getNorthEastLng() && packet.longitude >= this._map.getSouthWestLng()) {
                return true;
            }
        }
        return false;
    },
    _handleWebsocketStateChange: function () {
        switch (this._websocket.getState()) {
            case this._websocket.State.CONNECTING:
                this._setWebsocketStateConnecting();
                break;
            case this._websocket.State.CONNECTED:
                this._setWebsocketStateConnected();
                trackdirect.services.callbackExecutor.add(this, this._sendPositionRequest, []);
                break;
            case this._websocket.State.CLOSED:
            case this._websocket.State.ERROR:
                this._setWebsocketStateError();
                break;
            case this._websocket.State.LOADING:
                this._setWebsocketStateLoading(true, false);
                break;
            case this._websocket.State.LOADING_DONE:
                this._setWebsocketStateLoadingDone();
                break;
            case this._websocket.State.LISTENING_APRSIS:
                this._setWebsocketStateAprsISConnected();
                break;
            case this._websocket.State.CONNECTING_APRSIS:
                this._setWebsocketStateAprsISConnecting();
                break;
            case this._websocket.State.IDLE:
                this._setWebsocketStateIdle();
                break;
            case this._websocket.State.INACTIVE:
                this._setWebsocketStateInactive();
                break;
        }
    },
    _setWebsocketStateConnecting: function () {
        if (this._statusContainerElementId !== null) {
            $("#" + this._statusContainerElementId)
                .html("Connecting")
                .css("color", "blue");
        }
    },
    _setWebsocketStateConnected: function () {
        this._map.resetAllMarkers();
        if (this._statusContainerElementId !== null) {
            $("#" + this._statusContainerElementId)
                .html("Connected")
                .css("color", "green");
        }
    },
    _setWebsocketStateError: function () {
        if (this._statusContainerElementId !== null) {
            $("#" + this._statusContainerElementId)
                .html("Disconnected")
                .css("color", "red");
        }
        this._map.resetAllMarkers();
        this._deactivateFiltered(false);
        var me = this;
        if (confirm("You have been disconnected, this can be caused by a network error, by the timeout limit or if maintenance occurs while you’re logged in. Do you want to reconnect?")) {
            me._websocket = new trackdirect.Websocket(me._wsServerUrl);
            me._initWebsocketListeners();
            trackdirect.services.callbackExecutor.add(me, me._sendPositionRequest, []);
        }
    },
    _setWebsocketStateLoading: function (isStateConfirmed, showOnMobile) {
        isStateConfirmed = typeof isStateConfirmed !== "undefined" ? isStateConfirmed : true;
        showOnMobile = typeof showOnMobile !== "undefined" ? showOnMobile : true;
        if (this._statusContainerElementId !== null) {
            $("#" + this._statusContainerElementId)
                .html('Loading <i class="fa fa-spinner fa-spin" style="font-size:14px"></i>')
                .css("color", "green");
        }
    },
    _setWebsocketStateLoadingDone: function () {
        if (this._statusContainerElementId !== null) {
            $("#" + this._statusContainerElementId)
                .html("Complete")
                .css("color", "green");
        }
    },
    _setWebsocketStateAprsISConnected: function () {
        if (this._statusContainerElementId !== null) {
            $("#" + this._statusContainerElementId)
                .html("Connected to APRS feed")
                .css("color", "green");
        }
    },
    _setWebsocketStateAprsISConnecting: function () {
        if (this._statusContainerElementId !== null) {
            $("#" + this._statusContainerElementId)
                .html("Waiting for APRS feed")
                .css("color", "green");
        }
    },
    _setWebsocketStateIdle: function () {
        if (this._statusContainerElementId !== null) {
            $("#" + this._statusContainerElementId)
                .html("Idle")
                .css("color", "green");
        }
    },
    _setWebsocketStateInactive: function () {
        if (this._statusContainerElementId !== null) {
            $("#" + this._statusContainerElementId)
                .html("Inactive")
                .css("color", "orange");
        }
        this._websocket.close();
        this._map.resetAllMarkers();
        var me = this;
        if (confirm("No activity for a long time, map updates has been stopped. Do you want to reconnect?")) {
            me._websocket = new trackdirect.Websocket(me._wsServerUrl);
            me._initWebsocketListeners();
            trackdirect.services.callbackExecutor.add(me, me._sendPositionRequest, []);
        }
    },
    _sendPositionRequest: function () {
        if (!this._waitForFilterResponse && this._map.isMapReady()) {
            if (!this.isFilteredMode()) {
                if (this._map.getZoom() < trackdirect.settings.minZoomForMarkers) {
                    this._websocket.doSendNewPositionRequest(0, 0, 0, 0, this._map.state.getTimeLength() / 60, this.getTimeTravelTimestamp(), false);
                } else if (this._map.getZoom() >= trackdirect.settings.minZoomForMarkerTail) {
                    this._websocket.doSendNewPositionRequest(
                        this._map.getNorthEastLat(),
                        this._map.getNorthEastLng(),
                        this._map.getSouthWestLat(),
                        this._map.getSouthWestLng(),
                        this._map.state.getTimeLength() / 60,
                        this.getTimeTravelTimestamp(),
                        false
                    );
                } else {
                    this._websocket.doSendNewPositionRequest(
                        this._map.getNorthEastLat(),
                        this._map.getNorthEastLng(),
                        this._map.getSouthWestLat(),
                        this._map.getSouthWestLng(),
                        this._map.state.getTimeLength() / 60,
                        this.getTimeTravelTimestamp(),
                        true
                    );
                }
            } else {
                this._websocket.doSendNewPositionRequest(90, 180, -90, -180, this._map.state.getTimeLength() / 60, this.getTimeTravelTimestamp(), false);
            }
            var data = { center: this._map.getCenterLiteral(), zoom: this._map.getZoom() };
            this._emitEventListeners("position-request-sent", data);
        }
    },
    _sendIdleRequest: function () {
        if (this._websocket.isPositionRequestSent()) {
            this._websocket.doSendNewPositionRequest(0, 0, 0, 0, this._map.state.getTimeLength() / 60, this.getTimeTravelTimestamp(), false);
        }
    },
    _deactivateFiltered: function (sendNewRequest) {
        this.setTimeTravelTimestamp(null);
        this._map.resetAllMarkers();
        if (this._map.state.openInfoWindow !== null) {
            this._map.state.openInfoWindow.hide();
        }
        this._map.deactivateFilteredMode();
        this.stopTrackStation();
        this.setTimeLength(this.settings.defaultTimeLength, false);
        this._emitEventListeners("filter-changed", []);
        this._emitEventListeners("filter-stopped");
        if (sendNewRequest) {
            trackdirect.services.callbackExecutor.add(this, this._sendPositionRequest, []);
        }
        this._emitEventListeners("mode-changed");
    },
    _getMapBaseUrl: function (host) {
        host = typeof host !== "undefined" ? host : "";
        host = host.replace("http://", "");
        host = host.replace("https://", "");
        if (host == "") {
            host = window.location.host;
        }
        if (location.protocol === "https:") {
            return "https://" + host;
        } else {
            return "http://" + host;
        }
    },
    _emitEventListeners: function (event, arg) {
        if (event in this._eventListeners) {
            for (var i = 0; i < this._eventListeners[event].length; i++) {
                this._eventListeners[event][i](arg);
            }
        }
        if (event in this._eventListenersOnce) {
            for (var i = 0; i < this._eventListenersOnce[event].length; i++) {
                this._eventListenersOnce[event][i](arg);
                this._eventListenersOnce[event].splice(i, 1);
                i--;
            }
        }
        if (event == "trackdirect-init-done") {
            this._trackdirectInitDone = true;
        }
        if (event == "map-created") {
            this._mapCreated = true;
        }
    },
};
trackdirect.services.symbolPathFinder = {
    getFilePath: function (symbolTable, symbol, course, width, height, scaleWidth, scaleHeight) {
        let symbolAsciiValue;
        let symbolTableAsciiValue;
        if (typeof symbol !== "undefined" && typeof symbolTable !== "undefined" && symbol !== null && symbolTable !== null && symbol.length >= 1 && symbolTable.length >= 1) {
            symbolAsciiValue = symbol.charCodeAt(0);
            symbolTableAsciiValue = symbolTable.charCodeAt(0);
        } else {
            symbolAsciiValue = 125;
            symbolTableAsciiValue = 47;
        }
        let sizeStrValue = "";
        if (width !== null && height !== null) {
            sizeStrValue = "-" + width + "x" + height;
        }
        let scaleStrValue = this._getIconFilePathScalePart(scaleWidth, scaleHeight);
        let courseStrValue = this._getIconFilePathCoursePart(course);
        let url = trackdirect.settings.markerSymbolBaseDir + "symbol-" + symbolAsciiValue + "-" + symbolTableAsciiValue + courseStrValue + sizeStrValue + scaleStrValue + ".png";
        return trackdirect.settings.baseUrl + url;
    },
    _getIconFilePathCoursePart: function (course) {
        let courseStrValue = "";
        if (course !== null) {
            let courseValue = Math.round(parseInt(course) / 10) * 10;
            while (courseValue > 360) {
                courseValue = courseValue - 360;
            }
            while (courseValue < 0) {
                courseValue = courseValue + 360;
            }
            courseStrValue = "-" + courseValue;
        }
        return courseStrValue;
    },
    _getIconFilePathScalePart: function (scaleWidth, scaleHeight) {
        let scaleStrValue = "";
        if (scaleWidth !== null && scaleHeight !== null) {
            if (isHighDensity()) {
                scaleStrValue = "-scale" + scaleWidth * 2 + "x" + scaleHeight * 2;
            } else {
                scaleStrValue = "-scale" + scaleWidth + "x" + scaleHeight;
            }
        }
        return scaleStrValue;
    },
};
trackdirect.services.stationColorCalculator = {
    _colors: ["#3333ff", "#9900cc", "#006600", "#cc0000"],
    _stationColorId: {},
    getColor: function (packet) {
        let colorId = this.getColorId(packet);
        return this._colors[colorId];
    },
    getKmlColor(packet) {
        let hex = this.getColor(packet);
        let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (result) {
            return "FF" + result[3] + result[2] + result[1];
        }
        return null;
    },
    getColorId: function (packet) {
        let colorId;
        if (packet.station_name in this._stationColorId) {
            colorId = this._stationColorId[packet.station_name];
            return colorId;
        } else {
            let hash = this._simplehashStr(packet.station_name);
            colorId = hash % this._colors.length;
            this._stationColorId[packet.station_name] = colorId;
        }
        return colorId;
    },
    _simplehashStr: function (str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            let charCode = str.charCodeAt(i);
            hash += charCode;
        }
        return hash;
    },
};
trackdirect.services.MapSectorCalculator = {
    getMapSectors: function (bounds) {
        let result = [];
        let maxLat;
        let minLat;
        let maxLng;
        let minLng;
        if (typeof google === "object" && typeof google.maps === "object") {
            maxLat = Math.ceil(bounds.getNorthEast().lat()) + 1;
            minLat = Math.floor(bounds.getSouthWest().lat()) - 1;
            maxLng = Math.ceil(bounds.getNorthEast().lng()) + 1;
            minLng = Math.floor(bounds.getSouthWest().lng()) - 1;
        } else if (typeof L === "object") {
            maxLat = Math.ceil(bounds.getNorthEast().lat) + 1;
            minLat = Math.floor(bounds.getSouthWest().lat) - 1;
            maxLng = Math.ceil(bounds.getNorthEast().lng) + 1;
            minLng = Math.floor(bounds.getSouthWest().lng) - 1;
        }
        if (maxLng < minLng) {
            result = result.concat(trackdirect.services.MapSectorCalculator.getMapSectorsByInterval(minLat, maxLat, minLng, 180.0));
            minLng = -180.0;
        }
        result = result.concat(trackdirect.services.MapSectorCalculator.getMapSectorsByInterval(minLat, maxLat, minLng, maxLng));
        return result;
    },
    getMapSectorsByInterval: function (minLat, maxLat, minLng, maxLng) {
        let result = [];
        let minAreaCode = this.getMapSector(minLat, minLng);
        let maxAreaCode = this.getMapSector(maxLat, maxLng);
        lngDiff = parseInt(Math.ceil(maxLng)) - parseInt(Math.ceil(minLng));
        let areaCode = minAreaCode;
        while (areaCode <= maxAreaCode) {
            if (areaCode % 10 == 5) {
                result.push(areaCode);
            } else {
                result.push(areaCode);
                result.push(areaCode + 5);
            }
            for (let i = 1; i <= lngDiff; i++) {
                if (areaCode % 10 == 5) {
                    result.push(areaCode + 10 * i - 5);
                    result.push(areaCode + 10 * i);
                } else {
                    result.push(areaCode + 10 * i);
                    result.push(areaCode + 10 * i + 5);
                }
            }
            areaCode = areaCode + 20000;
        }
        return result;
    },
    getMapSector: function (latitude, longitude) {
        let lat = this._getMapSectorLatRepresentation(latitude);
        let lng = this._getMapSectorLngRepresentation(longitude);
        return lat + lng;
    },
    _getMapSectorLatRepresentation: function (latitude) {
        let lat = parseInt(Math.floor(latitude)) + 90;
        let latDecimalPart = latitude - Math.floor(latitude);
        if (latDecimalPart < 0.2) {
            lat = lat * 10 + 0;
        } else if (latDecimalPart < 0.4) {
            lat = lat * 10 + 2;
        } else if (latDecimalPart < 0.6) {
            lat = lat * 10 + 4;
        } else if (latDecimalPart < 0.8) {
            lat = lat * 10 + 6;
        } else {
            lat = lat * 10 + 8;
        }
        lat = lat * 10000;
        return lat;
    },
    _getMapSectorLngRepresentation: function (longitude) {
        lng = parseInt(Math.floor(longitude)) + 180;
        lngDecimalPart = longitude - Math.floor(longitude);
        if (lngDecimalPart < 0.5) {
            lng = lng * 10 + 0;
        } else {
            lng = lng * 10 + 5;
        }
        return lng;
    },
};
trackdirect.services.mapAttributionModifier = {
    _hereBaseAttributionData: null,
    _hereAerialAttributionData: null,
    _latestAttribution: null,
    _isHereInitialized: false,
    _eventListeners: {},
    _eventListenersOnce: {},
    update: function (map) {
        if (this._isHereTileProvider(map)) {
            this.updateHereAttribution(map);
        } else if (this._latestAttribution != null) {
            this.setMapAttribution(map, "");
        }
    },
    updateHereAttribution: function (map) {
        this._loadHereAttributionData(map);
        let me = this;
        let base = this._getMapTileBase(map);
        if (base == "base") {
            this.addListener(
                "init-here-base",
                function () {
                    let attribution = me._getHereAttributionString(map);
                    me.setMapAttribution(map, attribution);
                },
                true
            );
        } else if (base == "aerial") {
            this.addListener(
                "init-here-aerial",
                function () {
                    let attribution = me._getHereAttributionString(map);
                    me.setMapAttribution(map, attribution);
                },
                true
            );
        }
    },
    setMapAttribution: function (map, attribution) {
        if (this._latestAttribution != attribution) {
            map.attributionControl.removeAttribution(this._latestAttribution);
            if (attribution != "") {
                map.attributionControl.addAttribution(attribution);
            }
        }
        this._latestAttribution = attribution;
    },
    addListener: function (event, handler, execOnce) {
        execOnce = typeof execOnce !== "undefined" ? execOnce : false;
        if (execOnce) {
            if (!(event in this._eventListenersOnce)) {
                this._eventListenersOnce[event] = [];
            }
            this._eventListenersOnce[event].push(handler);
        } else {
            if (!(event in this._eventListeners)) {
                this._eventListeners[event] = [];
            }
            this._eventListeners[event].push(handler);
        }
        if (event == "init-here-base" && this._isHereBaseInitialized) {
            this._emitEventListeners("init-here-base");
        }
        if (event == "init-here-aerial" && this._isHereAerialInitialized) {
            this._emitEventListeners("init-here-aerial");
        }
    },
    _isHereTileProvider: function (map) {
        let tileLayer = map.getLeafletTileLayer();
        if (tileLayer !== null && typeof tileLayer._url !== "undefined" && tileLayer._url.indexOf("here.com") >= 0) {
            return true;
        }
        return false;
    },
    _getMapTileOptions: function (map) {
        let tileLayer = map.getLeafletTileLayer();
        if (tileLayer !== null && typeof tileLayer.options !== "undefined") {
            return tileLayer.options;
        }
        return null;
    },
    _getMapTileVariant: function (map) {
        let options = this._getMapTileOptions(map);
        if (options.variant !== "undefined") {
            return options.variant;
        }
        return null;
    },
    _getMapTileInitialVariant: function (map) {
        let mapVariant = this._getMapTileVariant(map);
        let dotIndex = mapVariant.indexOf(".");
        if (dotIndex >= 0) {
            return mapVariant.substring(0, dotIndex);
        }
        return mapVariant;
    },
    _getMapTileBase: function (map) {
        let options = this._getMapTileOptions(map);
        if (options.base !== "undefined") {
            return options.base;
        }
        return null;
    },
    _getHereAttributionString: function (map) {
        let result = [];
        let mapBaseVariant = this._getMapTileInitialVariant(map);
        let data;
        if (this._getMapTileBase(map) == "base") {
            data = this._hereBaseAttributionData;
        } else if (this._getMapTileBase(map) == "aerial") {
            data = this._hereAerialAttributionData;
        }
        if (data !== null && typeof data[mapBaseVariant] !== "undefined") {
            for (let i = 0, len = data[mapBaseVariant].length; i < len; i++) {
                let attributionArea = data[mapBaseVariant][i];
                if (parseInt(map.getZoom()) >= parseInt(attributionArea.minLevel) && parseInt(map.getZoom()) <= parseInt(attributionArea.maxLevel)) {
                    if (typeof attributionArea.boxes === "undefined" || this._isAnyBoxVisible(attributionArea.boxes, map)) {
                        let attributionText = '<span title="' + attributionArea.alt + '">' + attributionArea.label + "</span>";
                        if (result.indexOf(attributionText) < 0) {
                            result.push(attributionText);
                        }
                    }
                }
            }
        }
        return result.join(", ");
    },
    _isAnyBoxVisible: function (boxes, map) {
        if (typeof boxes !== "undefined" && Array.isArray(boxes)) {
            for (let i = 0, len = boxes.length; i < len; i++) {
                let box = boxes[i];
                if (Array.isArray(box) && box.length >= 4) {
                    let boxBounds = L.latLngBounds(L.latLng(parseFloat(box[0]), parseFloat(box[1])), L.latLng(parseFloat(box[2]), parseFloat(box[3])));
                    if (boxBounds.isValid() && boxBounds.intersects(map.getBounds())) {
                        return true;
                    }
                }
            }
        }
        return false;
    },
    _loadHereAttributionData: function (map) {
        let options = this._getMapTileOptions(map);
        let base = this._getMapTileBase(map);
        if ((this._hereBaseAttributionData === null && base == "base") || (this._hereAerialAttributionData === null && base == "aerial")) {
            let me = this;
            jQuery.ajax({
                url: "https://1." + base + ".maps.api.here.com/maptile/2.1/copyright/" + options.mapID + "?app_id=" + options.app_id + "&app_code=" + options.app_code,
                type: "GET",
                dataType: "json",
                timeout: 5000,
                success: function (result) {
                    if (base == "base") {
                        me._hereBaseAttributionData = result;
                        me._isHereBaseInitialized = true;
                        me._emitEventListeners("init-here-base");
                    } else if (base == "aerial") {
                        me._hereAerialAttributionData = result;
                        me._isHereAerialInitialized = true;
                        me._emitEventListeners("init-here-aerial");
                    }
                },
                error: function (xhr) {
                    console.log("Failed to load map copyright data");
                },
            });
        }
    },
    _emitEventListeners: function (event, arg) {
        if (event in this._eventListeners) {
            for (let i = 0; i < this._eventListeners[event].length; i++) {
                this._eventListeners[event][i](arg);
            }
        }
        if (event in this._eventListenersOnce) {
            let eventListenersOnce = this._eventListenersOnce[event].splice(0);
            this._eventListenersOnce[event] = [];
            for (let i = 0; i < eventListenersOnce.length; i++) {
                eventListenersOnce[i](arg);
            }
        }
    },
};
trackdirect.services.imperialConverter = {
    convertKilometerToMile: function (value) {
        return value * 0.621371192;
    },
    convertMpsToMph: function (value) {
        return value * 2.23693629;
    },
    convertMeterToFeet: function (value) {
        return value * 3.2808399;
    },
    convertMeterToYard: function (value) {
        return value * 1.0936133;
    },
    convertMmToInch: function (value) {
        return value * 0.0393700787;
    },
    convertCelciusToFahrenheit: function (value) {
        return value * (9 / 5) + 32;
    },
    convertMbarToMmhg: function (value) {
        return value * 0.75006375541921;
    },
};
trackdirect.services.distanceCalculator = {
    getDistance: function (p1, p2) {
        let R = 6378137;
        let dLat = this._radians(p2.lat - p1.lat);
        let dLong = this._radians(p2.lng - p1.lng);
        let a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this._radians(p1.lat)) * Math.cos(this._radians(p2.lat)) * Math.sin(dLong / 2) * Math.sin(dLong / 2);
        let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        let d = R * c;
        if (isNaN(d)) {
            return null;
        } else {
            return d;
        }
    },
    getCenter: function (coords) {
        let x = coords.map(function (a) {
            return a.lat;
        });
        let y = coords.map(function (a) {
            return a.lng;
        });
        let minX = Math.min.apply(null, x);
        let maxX = Math.max.apply(null, x);
        let minY = Math.min.apply(null, y);
        let maxY = Math.max.apply(null, y);
        return { lat: (minX + maxX) / 2, lng: (minY + maxY) / 2 };
    },
    getPositionByDistance: function (latLng, course, distanceInMeters) {
        let dist = distanceInMeters / 1000;
        dist = dist / 6371;
        let brng = (course * Math.PI) / 180;
        let lat1 = (latLng.lat * Math.PI) / 180,
            lon1 = (latLng.lng * Math.PI) / 180;
        let lat2 = Math.asin(Math.sin(lat1) * Math.cos(dist) + Math.cos(lat1) * Math.sin(dist) * Math.cos(brng));
        let lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(lat1), Math.cos(dist) - Math.sin(lat1) * Math.sin(lat2));
        if (isNaN(lat2) || isNaN(lon2)) return null;
        let latitude = (lat2 * 180) / Math.PI;
        let longitude = (lon2 * 180) / Math.PI;
        return { lat: Math.round(latitude * 100000) / 100000, lng: Math.round(longitude * 100000) / 100000 };
    },
    getBearing: function (p1, p2) {
        startLat = this._radians(p1.lat);
        startLong = this._radians(p1.lng);
        endLat = this._radians(p2.lat);
        endLong = this._radians(p2.lng);
        let dLong = endLong - startLong;
        let dPhi = Math.log(Math.tan(endLat / 2.0 + Math.PI / 4.0) / Math.tan(startLat / 2.0 + Math.PI / 4.0));
        if (Math.abs(dLong) > Math.PI) {
            if (dLong > 0.0) {
                dLong = -(2.0 * Math.PI - dLong);
            } else {
                dLong = 2.0 * Math.PI + dLong;
            }
        }
        return (this._degrees(Math.atan2(dLong, dPhi)) + 360.0) % 360.0;
    },
    _radians: function (n) {
        return n * (Math.PI / 180);
    },
    _degrees: function (n) {
        return n * (180 / Math.PI);
    },
};
trackdirect.services.dateFormatter = {
    getDateString: function (timestamp, includeTimeZone, includeTime, useLocalTimeZone) {
        includeTimeZone = typeof includeTimeZone !== "undefined" ? includeTimeZone : true;
        includeTime = typeof includeTime !== "undefined" ? includeTime : true;
        useLocalTimeZone = typeof useLocalTimeZone !== "undefined" ? useLocalTimeZone : true;
        let date = new Date(timestamp * 1000);
        let theMoment;
        if (useLocalTimeZone) {
            theMoment = moment(date);
        } else {
            theMoment = moment.utc(date);
        }
        if (!theMoment.isValid()) {
            return timestamp;
        }
        if (includeTime) {
            if (includeTimeZone) {
                return theMoment.format("L LTSZ");
            } else {
                return theMoment.format("L LTS");
            }
        } else {
            return theMoment.format("L");
        }
    },
    getAgeString: function (timestamp) {
        let delta = Math.abs(Math.floor(Date.now() / 1000) - timestamp);
        let days = Math.floor(delta / 86400);
        delta -= days * 86400;
        let hours = Math.floor(delta / 3600) % 24;
        delta -= hours * 3600;
        let minutes = Math.floor(delta / 60) % 60;
        delta -= minutes * 60;
        let seconds = Math.floor(delta % 60);
        let timeAgoList = [];
        if (days > 1) {
            timeAgoList.push(days + " days");
        } else if (days > 0) {
            timeAgoList.push(days + " day");
        }
        if (hours > 1) {
            timeAgoList.push(hours + " hours");
        } else if (hours > 0) {
            timeAgoList.push(hours + " hour");
        }
        if (minutes > 1) {
            timeAgoList.push(minutes + " minutes");
        } else if (minutes > 0) {
            timeAgoList.push(minutes + " minute");
        }
        if (seconds == 1) {
            timeAgoList.push(seconds + " second");
        } else {
            timeAgoList.push(seconds + " seconds");
        }
        if (timeAgoList.length > 1) {
            return timeAgoList.slice(0, timeAgoList.length - 1).join(", ") + " and " + timeAgoList[timeAgoList.length - 1];
        } else {
            return timeAgoList[timeAgoList.length - 1];
        }
    },
};
if (!Date.now) {
    Date.now = function () {
        return new Date().getTime();
    };
}
function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
String.prototype.replaceAll = function (search, replacement) {
    var target = this;
    return target.replace(new RegExp(escapeRegExp(search), "gi"), replacement);
};
function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
Number.prototype.mod = function (n) {
    return ((this % n) + n) % n;
};
function isDate(str) {
    var d = new Date(str);
    var now = new Date();
    if (Object.prototype.toString.call(d) === "[object Date]") {
        if (isNaN(d.getTime())) {
            return false;
        } else {
            if (d.getTime() > 0) {
                return true;
            } else {
                return false;
            }
        }
    } else {
        return false;
    }
}
if (!Array.prototype.fill) {
    Array.prototype.fill = function (value) {
        if (this == null) {
            throw new TypeError("this is null or not defined");
        }
        var O = Object(this);
        var len = O.length >>> 0;
        var start = arguments[1];
        var relativeStart = start >> 0;
        var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
        var end = arguments[2];
        var relativeEnd = end === undefined ? len : end >> 0;
        var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
        while (k < final) {
            O[k] = value;
            k++;
        }
        return O;
    };
}
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (elt) {
        var len = this.length;
        var from = Number(arguments[1]) || 0;
        from = from < 0 ? Math.ceil(from) : Math.floor(from);
        if (from < 0) from += len;
        for (; from < len; from++) {
            if (from in this && this[from] === elt) return from;
        }
        return -1;
    };
}
if (typeof String.prototype.endsWith !== "function") {
    String.prototype.endsWith = function (suffix) {
        return this.indexOf(suffix, this.length - suffix.length) !== -1;
    };
}
if (!String.prototype.trim) {
    (function () {
        var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        String.prototype.trim = function () {
            return this.replace(rtrim, "");
        };
    })();
}
if (!Object.keys) {
    Object.keys = function (obj) {
        var keys = [],
            k;
        for (k in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
                keys.push(k);
            }
        }
        return keys;
    };
}
if (!Date.prototype.toISOString) {
    (function () {
        function pad(number) {
            var r = String(number);
            if (r.length === 1) {
                r = "0" + r;
            }
            return r;
        }
        Date.prototype.toISOString = function () {
            return (
                this.getUTCFullYear() +
                "-" +
                pad(this.getUTCMonth() + 1) +
                "-" +
                pad(this.getUTCDate()) +
                "T" +
                pad(this.getUTCHours()) +
                ":" +
                pad(this.getUTCMinutes()) +
                ":" +
                pad(this.getUTCSeconds()) +
                "." +
                String((this.getUTCMilliseconds() / 1000).toFixed(3)).slice(2, 5) +
                "Z"
            );
        };
    })();
}
function inIframe() {
    try {
        return window.self !== window.top;
    } catch (e) {
        return true;
    }
}
function isHighDensity() {
    return (
        (window.matchMedia &&
            (window.matchMedia("only screen and (min-resolution: 124dpi), only screen and (min-resolution: 1.3dppx), only screen and (min-resolution: 48.8dpcm)").matches ||
                window.matchMedia(
                    "only screen and (-webkit-min-device-pixel-ratio: 1.3), only screen and (-o-min-device-pixel-ratio: 2.6/2), only screen and (min--moz-device-pixel-ratio: 1.3), only screen and (min-device-pixel-ratio: 1.3)"
                ).matches)) ||
        (window.devicePixelRatio && window.devicePixelRatio > 1.3)
    );
}
function escapeHtml(text) {
    if (typeof text === "undefined" || text == null) {
        return null;
    }
    var map = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;" };
    return text.replace(/[&<>"']/g, function (m) {
        return map[m];
    });
}
trackdirect.services.callbackExecutor = {
    settings: { minTimeBeforeSleep: 30 },
    _running: false,
    _lastSleepTimestamp: 0,
    _lastAddedUniqueCallback: null,
    _lowPriorityQueue: [],
    _normalPriorityQueue: [],
    _highPriorityQueue: [],
    add: function (thisObj, callback, argsArray) {
        this._lastAddedUniqueCallback = callback.toString() + ":" + argsArray.toString();
        this._normalPriorityQueue.push(function () {
            callback.apply(thisObj, argsArray);
            trackdirect.services.callbackExecutor._next();
        });
        this.start();
        return this;
    },
    addIfUnique: function (thisObj, callback, argsArray) {
        let callBackString = callback.toString() + ":" + argsArray.toString();
        if (this._lastAddedUniqueCallback == callBackString) {
            return this;
        }
        this._lastAddedUniqueCallback = callBackString;
        this._normalPriorityQueue.push(function () {
            callback.apply(thisObj, argsArray);
            trackdirect.services.callbackExecutor._next();
        });
        this.start();
        return this;
    },
    addWithPriority: function (thisObj, callback, argsArray) {
        this._highPriorityQueue.push(function () {
            callback.apply(thisObj, argsArray);
            trackdirect.services.callbackExecutor._next();
        });
        this.start();
        return this;
    },
    addWithLowPriority: function (thisObj, callback, argsArray) {
        this._lowPriorityQueue.push(function () {
            callback.apply(thisObj, argsArray);
            trackdirect.services.callbackExecutor._next();
        });
        this.start();
        return this;
    },
    start: function () {
        if (!this._running) {
            this._next();
        }
        return this;
    },
    _next: function () {
        let secondsSinceLastSleep = Date.now() - this._lastSleepTimestamp;
        if (secondsSinceLastSleep > this.settings.minTimeBeforeSleep) {
            this._lastSleepTimestamp = Date.now();
            let me = this;
            setTimeout(function () {
                me._dequeue();
            }, 1);
        } else {
            this._dequeue();
        }
    },
    _dequeue: function () {
        let shift = this._highPriorityQueue.shift();
        if (shift) {
            this._running = true;
            shift();
            return;
        }
        shift = this._normalPriorityQueue.shift();
        if (shift) {
            this._running = true;
            shift();
            return;
        }
        shift = this._lowPriorityQueue.shift();
        if (shift) {
            this._running = true;
            shift();
            return;
        }
        this._running = false;
    },
};
trackdirect.Websocket = function (wsServerUrl) {
    this._wsServerUrl = wsServerUrl;
    this._init();
    this._state = this.State.CONNECTING;
    this._emitEventListeners("state-change");
    this._instance = new WebSocket(this._wsServerUrl);
    let me = this;
    this._instance.onopen = function (evt) {
        me._onOpen(evt);
    };
    this._instance.onclose = function (evt) {
        me._onClose(evt);
    };
    this._instance.onmessage = function (evt) {
        me._onMessage(evt);
    };
    this._instance.onerror = function (evt) {
        me._onError(evt);
    };
};
trackdirect.Websocket.prototype._init = function () {
    this._instance = null;
    this._eventListeners = {};
    this._lastSentPositionRequest = "";
    this._state = 0;
    this._lastMessageTimestamp = null;
    this._queue = [];
    this._running = false;
    this._sendPositionRequestIntervalId = null;
    this.State = { CONNECTING: 0, CONNECTED: 1, CLOSING: 2, CLOSED: 3, ERROR: 4, LOADING: 5, LOADING_DONE: 6, LISTENING_APRSIS: 7, CONNECTING_APRSIS: 8, IDLE: 9, INACTIVE: 10 };
};
trackdirect.Websocket.prototype.send = function (data) {
    this._instance.send(data);
};
trackdirect.Websocket.prototype.close = function () {
    this._instance.close();
};
trackdirect.Websocket.prototype.getState = function () {
    return this._state;
};
trackdirect.Websocket.prototype.clearLastSentPositionRequest = function () {
    this._lastSentPositionRequest = "";
};
trackdirect.Websocket.prototype.isPositionRequestSent = function () {
    if (this._lastSentPositionRequest != "") {
        return true;
    } else {
        return false;
    }
};
trackdirect.Websocket.prototype.doSendFilterRequest = function (list, historyMinutes, referenceTime) {
    let request = {};
    request.payload_request_type = 4;
    request.list = list;
    request.minutes = historyMinutes;
    if (referenceTime != "") {
        request.time = parseInt(referenceTime, 10);
    } else {
        request.time = null;
    }
    return this._addToSendQueue(request);
};
trackdirect.Websocket.prototype.doSendFilterRequestByName = function (namelist, historyMinutes, referenceTime) {
    let request = {};
    request.payload_request_type = 8;
    request.namelist = namelist;
    request.minutes = historyMinutes;
    if (referenceTime != "") {
        request.time = parseInt(referenceTime, 10);
    } else {
        request.time = null;
    }
    return this._addToSendQueue(request);
};
trackdirect.Websocket.prototype.doSendCompleteStationRequest = function (stationId, historyMinutes, referenceTime) {
    let request = {};
    request.payload_request_type = 7;
    request.station_id = stationId;
    request.minutes = historyMinutes;
    if (referenceTime != "") {
        request.time = parseInt(referenceTime, 10);
    } else {
        request.time = null;
    }
    return this._addToSendQueue(request);
};
trackdirect.Websocket.prototype.doSendStopFilterRequest = function (stationId) {
    let request = {};
    request.payload_request_type = 6;
    request.station_id = stationId;
    return this._addToSendQueue(request);
};
trackdirect.Websocket.prototype.doSendNewPositionRequest = function (neLat, neLng, swLat, swLng, historyMinutes, referenceTime, onlyRequestLatestPacket) {
    let request = {};
    request.payload_request_type = 1;
    request.neLat = neLat;
    request.neLng = neLng;
    request.swLat = swLat;
    request.swLng = swLng;
    request.minutes = historyMinutes;
    if (referenceTime != "") {
        request.time = parseInt(referenceTime, 10);
    } else {
        request.time = null;
    }
    if (onlyRequestLatestPacket) {
        request.onlyLatestPacket = 1;
    } else {
        request.onlyLatestPacket = 0;
    }
    let requestStr = JSON.stringify(request);
    if (requestStr != this._lastSentPositionRequest) {
        this._lastSentPositionRequest = requestStr;
        if (this._sendPositionRequestIntervalId !== null) {
            clearInterval(this._sendPositionRequestIntervalId);
        }
        if (this._addToSendQueue(request)) {
            let me = this;
            this._sendPositionRequestIntervalId = window.setInterval(function () {
                request.payload_request_type = 11;
                if (me._lastSentPositionRequest == requestStr) {
                    me._addToSendQueue(request);
                }
            }, 60 * 1000);
            return true;
        }
        return false;
    } else {
        return true;
    }
};
trackdirect.Websocket.prototype.addListener = function (event, handler) {
    if (!(event in this._eventListeners)) {
        this._eventListeners[event] = [];
    }
    this._eventListeners[event].push(handler);
};
trackdirect.Websocket.prototype._onOpen = function (evt) {
    this._state = this.State.CONNECTING;
    this._emitEventListeners("state-change");
};
trackdirect.Websocket.prototype._onClose = function (evt) {
    this._state = this.State.CLOSED;
    this._emitEventListeners("state-change");
};
trackdirect.Websocket.prototype._onError = function (evt) {
    this._state = this.State.ERROR;
    this._emitEventListeners("state-change");
};
trackdirect.Websocket.prototype._onMessage = function (evt) {
    this._lastMessageTimestamp = Math.floor(Date.now() / 1000);
    let packet = JSON.parse(evt.data);
    trackdirect.services.callbackExecutor.add(this, this._handleMessage, [packet]);
};
trackdirect.Websocket.prototype._handleMessage = function (packet) {
    switch (packet.payload_response_type) {
        case 1:
            this._emitEventListeners("aprs-packet", packet.data);
            this._emitEventListeners("aprs-packet-payload-done");
            break;
        case 2:
            for (i = 0; typeof packet.data !== "undefined" && i < packet.data.length; i++) {
                this._emitEventListeners("aprs-packet", packet.data[i]);
            }
            this._emitEventListeners("aprs-packet-payload-done");
            break;
        case 5:
            this._emitEventListeners("filter-response", packet.data);
            this._emitEventListeners("aprs-packet-payload-done");
            break;
        case 41:
            this._emitEventListeners("server-timestamp-response", packet.data);
            break;
        case 31:
            this._state = this.State.LISTENING_APRSIS;
            this._emitEventListeners("state-change");
            break;
        case 32:
            this._state = this.State.LOADING;
            this._emitEventListeners("state-change");
            break;
        case 33:
            this._state = this.State.IDLE;
            this._emitEventListeners("state-change");
            break;
        case 34:
            this._state = this.State.CONNECTING_APRSIS;
            this._emitEventListeners("state-change");
            break;
        case 35:
            this._state = this.State.LOADING_DONE;
            this._emitEventListeners("state-change");
            break;
        case 36:
            this._state = this.State.INACTIVE;
            this._emitEventListeners("state-change");
            this.clearLastSentPositionRequest();
            break;
        case 40:
            this._emitEventListeners("reset");
            break;
        case 42:
            this.clearLastSentPositionRequest();
            this._state = this.State.CONNECTED;
            this._emitEventListeners("state-change");
            break;
    }
    return true;
};
trackdirect.Websocket.prototype._addToSendQueue = function (request) {
    if (this.readyState > 1) {
        return false;
    }
    let currentTs = Math.floor(Date.now() / 1000);
    if (this._lastMessageTimestamp !== null && this._lastMessageTimestamp < currentTs - 60) {
        this.close();
        return false;
    }
    let me = this;
    this._queue.push(function () {
        let data = JSON.stringify(request);
        if (data != null) {
            me.send(data);
        }
        me._dequeue();
    });
    this._start();
    return true;
};
trackdirect.Websocket.prototype._start = function () {
    if (!this._running) {
        this._dequeue();
    }
};
trackdirect.Websocket.prototype._dequeue = function () {
    this._running = true;
    let me = this;
    setTimeout(function () {
        if (me._instance.readyState === 1) {
            let shift = me._queue.shift();
            if (shift) {
                shift();
            } else {
                me._running = false;
            }
        } else if (me._instance.readyState > 1) {
            me._running = false;
        } else {
            me._dequeue();
        }
    }, 5);
};
trackdirect.Websocket.prototype._emitEventListeners = function (event, arg) {
    if (typeof this._eventListeners !== "undefined" && event in this._eventListeners) {
        for (let i = 0; i < this._eventListeners[event].length; i++) {
            this._eventListeners[event][i](arg);
        }
    }
};
trackdirect.models.TransmitPolyline = function (packet, map) {
    this._packet = packet;
    this._defaultMap = map;
    this._relatedMarkerIdKeys = [];
    if (typeof google === "object" && typeof google.maps === "object") {
        const googlePolyline = new google.maps.Polyline(this._getGooglePolylineOptions());
        for (const key of Object.keys(this)) {
            googlePolyline[key] = this[key];
        }
        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {
            if (key !== "constructor" && typeof this[key] === "function") {
                googlePolyline[key] = this[key];
            }
        }
        return googlePolyline;
    } else if (typeof L === "object") {
        L.Polyline.call(this, {}, this._getLeafletPolylineOptions());
        this.setLatLngs(this.getCoordinates());
    }
};
if (typeof google === "object" && typeof google.maps === "object") {
    trackdirect.models.TransmitPolyline.prototype = Object.create(google.maps.Polyline.prototype);
} else if (typeof L === "object") {
    trackdirect.models.TransmitPolyline.prototype = Object.create(L.Polyline.prototype);
}
trackdirect.models.TransmitPolyline.prototype.constructor = trackdirect.models.TransmitPolyline;
trackdirect.models.TransmitPolyline.prototype.getPathItem = function (index) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let path = google.maps.Polyline.prototype.getPath.call(this);
        return path.getAt(index);
    } else if (typeof L === "object") {
        let list = this.getLatLngs();
        if (typeof list[index] !== "undefined") {
            return list[index];
        } else {
            return null;
        }
    }
    return null;
};
trackdirect.models.TransmitPolyline.prototype.pushPathItem = function (latLng) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let path = google.maps.Polyline.prototype.getPath.call(this);
        path.push(latLng);
    } else if (typeof L === "object") {
        this.addLatLng(latLng);
    }
};
trackdirect.models.TransmitPolyline.prototype.removePathItem = function (index) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let path = google.maps.Polyline.prototype.getPath.call(this);
        path.removeAt(index);
    } else if (typeof L === "object") {
        let list = this.getLatLngs();
        if (typeof list[index] !== "undefined") {
            list.splice(index, 1);
            this.setLatLngs(list);
        }
    }
};
trackdirect.models.TransmitPolyline.prototype.getPathLength = function (index) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let path = google.maps.Polyline.prototype.getPath.call(this);
        return path.getLength();
    } else if (typeof L === "object") {
        let list = this.getLatLngs();
        return list.length;
    }
};
trackdirect.models.TransmitPolyline.prototype.getPath = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        return google.maps.Polyline.prototype.getPath.call(this);
    } else if (typeof L === "object") {
        return this.getLatLngs();
    }
    return [];
};
trackdirect.models.TransmitPolyline.prototype.getMap = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        let map = google.maps.Polyline.prototype.getMap.call(this);
        if (typeof map !== "undefined") {
            return map;
        }
    } else if (typeof L === "object") {
        if (this._defaultMap.hasLayer(this)) {
            return this._defaultMap;
        }
    }
    return null;
};
trackdirect.models.TransmitPolyline.prototype.show = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (typeof this.getMap() === "undefined" || this.getMap() === null) {
            this.setMap(this._defaultMap);
        }
    } else if (typeof L === "object") {
        if (!this._defaultMap.hasLayer(this)) {
            this.addTo(this._defaultMap);
        }
    }
    for (let i = 0; i < this._relatedMarkerIdKeys.length; i++) {
        let relatedMarkerIdKey = this._relatedMarkerIdKeys[i];
        if (this._defaultMap.markerCollection.isExistingMarker(relatedMarkerIdKey)) {
            let relatedMarker = this._defaultMap.markerCollection.getMarker(relatedMarkerIdKey);
            relatedMarker.show();
            relatedMarker.showLabel();
        }
    }
};
trackdirect.models.TransmitPolyline.prototype.hide = function (delayInMilliSeconds) {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (this.getMap() !== null) {
            this.setMap(null);
        }
    } else if (typeof L === "object") {
        if (this._defaultMap.hasLayer(this)) {
            this._defaultMap.removeLayer(this);
        }
    }
    for (let i = 0; i < this._relatedMarkerIdKeys.length; i++) {
        let relatedMarkerIdKey = this._relatedMarkerIdKeys[i];
        if (this._defaultMap.markerCollection.isExistingMarker(relatedMarkerIdKey)) {
            let relatedMarker = this._defaultMap.markerCollection.getMarker(relatedMarkerIdKey);
            if (relatedMarker !== null && relatedMarker.getMap() !== null) {
                relatedMarker.hide(delayInMilliSeconds, true);
            }
        }
    }
};
trackdirect.models.TransmitPolyline.prototype.isVisible = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (typeof this.getMap() !== "undefined" && this.getMap() !== null) {
            return true;
        }
    } else if (typeof L === "object") {
        if (this._defaultMap.hasLayer(this)) {
            return true;
        }
    }
    return false;
};
trackdirect.models.TransmitPolyline.prototype._getGooglePolylineOptions = function () {
    let lineCoordinates = this.getCoordinates();
    if (lineCoordinates.length <= 1) {
        lineCoordinates = [];
    }
    let lineSymbol = { path: "M 0,-0.1 0,0", strokeOpacity: 0.7, scale: 3 };
    return { path: lineCoordinates, strokeOpacity: 0, strokeColor: "#0000ff", icons: [{ icon: lineSymbol, offset: "0px", repeat: "5px" }], map: null, zIndex: 100 };
};
trackdirect.models.TransmitPolyline.prototype._getLeafletPolylineOptions = function () {
    return { opacity: 0.6, weight: 3, color: "#0000ff", dashArray: "1,5", lineCap: "round", lineJoin: "round" };
};
(trackdirect.models.TransmitPolyline.prototype.getCoordinates = function () {
    let lineCoordinates = this.getCoordinatesByStationMarkers();
    if (lineCoordinates.length < this._packet.station_location_path.length + 1) {
        lineCoordinates = this.getCoordinatesByPositions();
    }
    return lineCoordinates;
}),
    (trackdirect.models.TransmitPolyline.prototype.getCoordinatesByStationMarkers = function () {
        let lineCoordinates = [];
        let startLatLng = this._packet.getLatLngLiteral();
        lineCoordinates.push(startLatLng);
        for (let i = 0; i < this._packet.station_id_path.length; i++) {
            let stationId = this._packet.station_id_path[i];
            let stationMarkerIdKey = null;
            let stationMarker = null;
            let stationDistance = null;
            let stationLatLng = null;
            for (let pointMarkerIdKey in this._defaultMap.markerCollection.getStationMarkerIdKeys(stationId)) {
                let pointMarker = this._defaultMap.markerCollection.getMarker(pointMarkerIdKey);
                if (pointMarker !== null) {
                    let pointLatLng = pointMarker.packet.getLatLngLiteral();
                    let distance = trackdirect.services.distanceCalculator.getDistance(startLatLng, pointLatLng);
                    if (stationMarker === null || distance < stationDistance) {
                        stationMarkerIdKey = pointMarkerIdKey;
                        stationMarker = pointMarker;
                        stationDistance = distance;
                        stationLatLng = pointLatLng;
                    }
                }
            }
            if (stationLatLng !== null) {
                lineCoordinates.push(stationLatLng);
                this._relatedMarkerIdKeys.push(stationMarkerIdKey);
            }
        }
        return lineCoordinates;
    }),
    (trackdirect.models.TransmitPolyline.prototype.getCoordinatesByPositions = function () {
        let lineCoordinates = [];
        let startLatLng = this._packet.getLatLngLiteral();
        lineCoordinates.push(startLatLng);
        if (lineCoordinates.length < this._packet.station_location_path.length + 1) {
            for (let i = 0; i < this._packet.station_location_path.length; i++) {
                if (this._packet.station_location_path[i][0] !== null && this._packet.station_location_path[i][1] !== null) {
                    lineCoordinates.push({ lat: parseFloat(this._packet.station_location_path[i][0]), lng: parseFloat(this._packet.station_location_path[i][1]) });
                }
            }
        }
        return lineCoordinates;
    });
trackdirect.models.TransmitAnimation = function (marker, map) {
    this._map = map;
    this._marker = marker;
    this.init();
};
trackdirect.models.TransmitAnimation.prototype.show = function () {
    this._startAnimation();
};
trackdirect.models.TransmitAnimation.prototype.hide = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        this.iconMarkers[1].setMap(null);
        this.iconMarkers[2].setMap(null);
        this.iconMarkers[3].setMap(null);
    } else if (typeof L === "object") {
        this._map.removeLayer(this.iconMarkers[1]);
        this._map.removeLayer(this.iconMarkers[2]);
        this._map.removeLayer(this.iconMarkers[3]);
    }
    this.marker.transmitPolyLine.hide();
};
trackdirect.models.TransmitAnimation.prototype.init = function () {
    let newLatLng = this._marker.packet.getLatLngLiteral();
    this._marker.transmitPolyLine = new trackdirect.models.TransmitPolyline(this._marker.packet, this._map);
    this.iconMarkers = [];
    for (let i = 1; i <= 3; i++) {
        let icon = this._getIcon(i);
        let iconMarker;
        if (typeof google === "object" && typeof google.maps === "object") {
            iconMarker = new google.maps.Marker({ position: newLatLng, zIndex: this._map.state.currentMarkerZindex, icon: icon, opacity: 0.6 });
            //iconMarker = new google.maps.marker.AdvancedMarkerElement({ position: newLatLng, zIndex: this._map.state.currentMarkerZindex, icon: icon, opacity: 0.6 });
        } else if (typeof L === "object") {
            iconMarker = new L.Marker(newLatLng, { zIndexOffset: this._map.state.currentMarkerZindex, icon: icon, opacity: 0.6 });
        }
        this.iconMarkers[i] = iconMarker;
    }
};
trackdirect.models.TransmitAnimation.prototype._getIcon = function (index) {
    let icon;
    if (typeof google === "object" && typeof google.maps === "object") {
        icon = { url: trackdirect.settings.baseUrl + trackdirect.settings.imagesBaseDir + "transmit" + index + ".png", size: new google.maps.Size(60, 60), origin: new google.maps.Point(0, 0), anchor: new google.maps.Point(30, 30) };
    } else if (typeof L === "object") {
        icon = L.icon({ iconUrl: trackdirect.settings.baseUrl + trackdirect.settings.imagesBaseDir + "transmit" + index + ".png", iconSize: [60, 60], iconAnchor: [30, 30] });
    }
    return icon;
};
trackdirect.models.TransmitAnimation.prototype._startAnimation = function () {
    let me = this;
    me._showIconMarker(1);
    window.setTimeout(function () {
        me._showIconMarker(2);
    }, 150);
    window.setTimeout(function () {
        me._showIconMarker(3);
        if (me._marker.transmitPolyLine !== null) {
            me._marker.transmitPolyLine.show();
        }
    }, 300);
    window.setTimeout(function () {
        me._hideIconMarker(1);
    }, 800);
    window.setTimeout(function () {
        me._hideIconMarker(2);
    }, 900);
    window.setTimeout(function () {
        me._hideIconMarker(3);
        if (me._marker.transmitPolyLine != null) {
            me._marker.transmitPolyLine.hide(4000);
        }
    }, 1000);
};
trackdirect.models.TransmitAnimation.prototype._showIconMarker = function (index) {
    if (typeof google === "object" && typeof google.maps === "object") {
        this.iconMarkers[index].setMap(this._map);
    } else if (typeof L === "object") {
        this.iconMarkers[index].addTo(this._map);
    }
};
trackdirect.models.TransmitAnimation.prototype._hideIconMarker = function (index) {
    if (typeof google === "object" && typeof google.maps === "object") {
        this.iconMarkers[index].setMap(null);
    } else if (typeof L === "object") {
        this._map.removeLayer(this.iconMarkers[index]);
    }
};
trackdirect.models.TailPolyline = function (color, map) {
    this._defaultMap = map;
    this.markerIdKey = null;
    this.ownerMarkerIdKey = null;
    this.relatedMarkerIdKey = null;
    if (typeof google === "object" && typeof google.maps === "object") {
        const googlePolyline = new google.maps.Polyline(this._getGooglePolylineOptions(color));
        for (const key of Object.keys(this)) {
            googlePolyline[key] = this[key];
        }
        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {
            if (key !== "constructor" && typeof this[key] === "function") {
                googlePolyline[key] = this[key];
            }
        }
        return googlePolyline;
    } else if (typeof L === "object") {
        L.Polyline.call(this, {}, this._getLeafletPolylineOptions(color));
    }
};
if (typeof google === "object" && typeof google.maps === "object") {
    trackdirect.models.TailPolyline.prototype = Object.create(google.maps.Polyline.prototype);
} else if (typeof L === "object") {
    trackdirect.models.TailPolyline.prototype = Object.create(L.Polyline.prototype);
}
trackdirect.models.TailPolyline.prototype.constructor = trackdirect.models.TailPolyline;
trackdirect.models.TailPolyline.prototype.getPathItem = function (index) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let path = google.maps.Polyline.prototype.getPath.call(this);
        return path.getAt(index);
    } else if (typeof L === "object") {
        let list = this.getLatLngs();
        if (typeof list[index] !== "undefined") {
            return list[index];
        } else {
            return null;
        }
    }
    return null;
};
trackdirect.models.TailPolyline.prototype.pushPathItem = function (latLng) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let path = google.maps.Polyline.prototype.getPath.call(this);
        path.push(latLng);
    } else if (typeof L === "object") {
        this.addLatLng(latLng);
    }
};
trackdirect.models.TailPolyline.prototype.removePathItem = function (index) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let path = google.maps.Polyline.prototype.getPath.call(this);
        path.removeAt(index);
    } else if (typeof L === "object") {
        let list = this.getLatLngs();
        if (typeof list[index] !== "undefined") {
            list.splice(index, 1);
            this.setLatLngs(list);
        }
    }
};
trackdirect.models.TailPolyline.prototype.getPathLength = function (index) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let path = google.maps.Polyline.prototype.getPath.call(this);
        return path.getLength();
    } else if (typeof L === "object") {
        let list = this.getLatLngs();
        return list.length;
    }
};
trackdirect.models.TailPolyline.prototype.getPath = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        return google.maps.Polyline.prototype.getPath.call(this);
    } else if (typeof L === "object") {
        return this.getLatLngs();
    }
    return [];
};
trackdirect.models.TailPolyline.prototype.getMap = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        let map = google.maps.Polyline.prototype.getMap.call(this);
        if (typeof map !== "undefined") {
            return map;
        }
    } else if (typeof L === "object") {
        if (this._defaultMap.hasLayer(this)) {
            return this._defaultMap;
        }
    }
    return null;
};
trackdirect.models.TailPolyline.prototype.setMarkerIdKey = function (markerIdKey) {
    this.markerIdKey = markerIdKey;
    this.ownerMarkerIdKey = markerIdKey;
    this._addInfoWindowListener(markerIdKey);
};
trackdirect.models.TailPolyline.prototype.setRelatedMarkerIdKey = function (markerIdKey) {
    this.relatedMarkerIdKey = markerIdKey;
};
trackdirect.models.TailPolyline.prototype.show = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (typeof this.getMap() === "undefined" || this.getMap() === null) {
            this.setMap(this._defaultMap);
        }
    } else if (typeof L === "object") {
        if (!this._defaultMap.hasLayer(this)) {
            this.addTo(this._defaultMap);
        }
    }
};
trackdirect.models.TailPolyline.prototype.hide = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (this.getMap() !== null) {
            this.setMap(null);
        }
    } else if (typeof L === "object") {
        if (this._defaultMap.hasLayer(this)) {
            this._defaultMap.removeLayer(this);
        }
    }
};
trackdirect.models.TailPolyline.prototype.addMarker = function (marker) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let latLng = new google.maps.LatLng(parseFloat(marker.packet.latitude), parseFloat(marker.packet.longitude));
        latLng.marker = marker;
        this.pushPathItem(latLng);
    } else if (typeof L === "object") {
        let latLng = new L.latLng(parseFloat(marker.packet.latitude), parseFloat(marker.packet.longitude));
        latLng.marker = marker;
        this.addLatLng(latLng);
    }
};
trackdirect.models.TailPolyline.prototype._addInfoWindowListener = function (markerIdKey) {
    let me = this;
    if (typeof google === "object" && typeof google.maps === "object") {
        google.maps.event.addListener(this, "click", function (event) {
            let marker = me._defaultMap.markerCollection.getMarker(markerIdKey);
            me._defaultMap.openPolylineInfoWindow(marker, event.latLng);
        });
    } else if (typeof L === "object") {
        this.on("click", function (event) {
            let marker = me._defaultMap.markerCollection.getMarker(markerIdKey);
            me._defaultMap.openPolylineInfoWindow(marker, event.latlng);
        });
    }
};
trackdirect.models.TailPolyline.prototype._getGooglePolylineOptions = function (color) {
    return { geodesic: false, strokeOpacity: 0.6, strokeWeight: 4, strokeColor: color, map: null, zIndex: 100 };
};
trackdirect.models.TailPolyline.prototype._getLeafletPolylineOptions = function (color) {
    return { opacity: 0.7, weight: 4, color: color };
};
trackdirect.models.StationCoveragePolygon = function (center, map, tryToShowCoveragePolygon) {
    tryToShowCoveragePolygon = typeof tryToShowCoveragePolygon !== "undefined" ? tryToShowCoveragePolygon : true;
    this._showPolygon = tryToShowCoveragePolygon;
    this._map = map;
    this._center = center;
    this._isRequestedToBeVisible = false;
    this._polygon = null;
    this._polygonCoordinates = null;
    this._heatmapCoordinates = null;
    this._heatmap = null;
    this._tdEventListeners = {};
    this._tdEventListenersOnce = {};
    this._upperMaxRangeInMeters = 1000 * 1000;
    this._paddingInPercentOfMaxRange = 10;
    this._paddingMinInMeters = 1000;
};
trackdirect.models.StationCoveragePolygon.prototype.setData = function (data, percentile) {
    this._addParametersToData(data);
    this._heatmapCoordinates = this._getCoordinates(data);
    if (this._showPolygon) {
        let maxRange = this._getCoveragePolygonMaxRange(data, percentile);
        if (maxRange <= 0) {
            this._showPolygon = false;
        } else {
            this._polygonCoordinates = this._getConvexHullCoordinates(data, maxRange);
        }
    }
    if (typeof google === "object" && typeof google.maps === "object") {
        this._googleMapsInit();
    } else if (typeof L === "object") {
        this._leafletInit();
    }
};
trackdirect.models.StationCoveragePolygon.prototype.addTdListener = function (event, handler, execOnce) {
    execOnce = typeof execOnce !== "undefined" ? execOnce : false;
    if (execOnce) {
        if (!(event in this._tdEventListenersOnce)) {
            this._tdEventListenersOnce[event] = [];
        }
        this._tdEventListenersOnce[event].push(handler);
    } else {
        if (!(event in this._tdEventListeners)) {
            this._tdEventListeners[event] = [];
        }
        this._tdEventListeners[event].push(handler);
    }
};
trackdirect.models.StationCoveragePolygon.prototype.hasContent = function () {
    if (this._heatmapCoordinates !== null && this._heatmapCoordinates.length > 0) {
        return true;
    }
    return false;
};
trackdirect.models.StationCoveragePolygon.prototype.isRequestedToBeVisible = function () {
    return this._isRequestedToBeVisible;
};
trackdirect.models.StationCoveragePolygon.prototype.showWhenDone = function () {
    this._isRequestedToBeVisible = true;
};
trackdirect.models.StationCoveragePolygon.prototype.show = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (this._polygon !== null) {
            this._polygon.setMap(this._map);
        }
        if (this._heatmap !== null) {
            this._heatmap.setMap(this._map);
        }
    } else if (typeof L === "object") {
        if (this._polygon !== null) {
            this._polygon.addTo(this._map);
        }
        if (this._heatmap !== null) {
            this._heatmap.addTo(this._map);
        }
    }
    this._isRequestedToBeVisible = true;
    if (this._showPolygon && this._polygonCoordinates !== null) {
        this._emitTdEventListeners("visible");
    } else if (this._heatmapCoordinates !== null) {
        this._emitTdEventListeners("visible");
    }
};
trackdirect.models.StationCoveragePolygon.prototype.hide = function (stillMarkAsVisible) {
    stillMarkAsVisible = typeof stillMarkAsVisible !== "undefined" ? stillMarkAsVisible : false;
    if (typeof google === "object" && typeof google.maps === "object") {
        if (this._polygon !== null) {
            this._polygon.setMap(null);
        }
        if (this._heatmap !== null) {
            this._heatmap.setMap(null);
        }
    } else if (typeof L === "object") {
        if (this._polygon !== null) {
            this._map.removeLayer(this._polygon);
        }
        if (this._heatmap !== null) {
            this._map.removeLayer(this._heatmap);
        }
    }
    if (!stillMarkAsVisible) {
        this._isRequestedToBeVisible = false;
    }
    this._emitTdEventListeners("hidden");
};
trackdirect.models.StationCoveragePolygon.prototype._googleMapsInit = function () {
    if (this._polygonCoordinates !== null && this._polygonCoordinates.length > 0) {
        this._polygon = new google.maps.Polygon({ paths: this._polygonCoordinates, strokeColor: "#0000FF", strokeOpacity: 0, strokeWeight: 0, fillColor: "#0000FF", fillOpacity: 0.2 });
    }
    if (this._heatmapCoordinates !== null && this._heatmapCoordinates.length > 0) {
        let data = [];
        for (let i = 0; i < this._heatmapCoordinates.length; i++) {
            data.push({ location: this._heatmapCoordinates[i], weight: 1 });
        }
        this._heatmap = new google.maps.visualization.HeatmapLayer({
            data: data,
            radius: 8,
            maxIntensity: 5,
            gradient: [
                "rgba(0, 255, 255, 0)",
                "rgba(0, 255, 255, 1)",
                "rgba(0, 191, 255, 1)",
                "rgba(0, 127, 255, 1)",
                "rgba(0, 63, 255, 1)",
                "rgba(0, 0, 255, 1)",
                "rgba(0, 0, 223, 1)",
                "rgba(0, 0, 191, 1)",
                "rgba(0, 0, 159, 1)",
                "rgba(0, 0, 127, 1)",
                "rgba(63, 0, 91, 1)",
                "rgba(127, 0, 63, 1)",
                "rgba(191, 0, 31, 1)",
                "rgba(255, 0, 0, 1)",
            ],
            map: null,
        });
    }
};
trackdirect.models.StationCoveragePolygon.prototype._leafletInit = function () {
    if (this._polygonCoordinates !== null && this._polygonCoordinates.length > 0) {
        this._polygon = new L.polygon(this._polygonCoordinates, { color: "#0000FF", opacity: 0, weight: 0, fillColor: "#0000FF", fillOpacity: 0.2 });
    }
    if (this._heatmapCoordinates !== null && this._heatmapCoordinates.length > 0) {
        let data = [];
        for (let i = 0; i < this._heatmapCoordinates.length; i++) {
            data.push([this._heatmapCoordinates[i].lat, this._heatmapCoordinates[i].lng, 10]);
        }
        this._heatmap = L.heatLayer(this._heatmapCoordinates, { minOpacity: 0.35, radius: 6, blur: 4 });
    }
};
trackdirect.models.StationCoveragePolygon.prototype._getConvexHullCoordinates = function (data, maxRange) {
    let positions = this._getFilteredPositions(data, maxRange);
    positions.push(this._center);
    let xyPositions = this._convertToXYPos(positions);
    let convexHullXYPositions = convexhull.makeHull(xyPositions);
    let latLngPadding = this._paddingInPercentOfMaxRange * 0.01 * maxRange * 0.000009;
    let latLngPaddingMin = this._paddingMinInMeters * 0.000009;
    if (isNaN(latLngPadding) || latLngPadding < latLngPaddingMin) {
        latLngPadding = latLngPaddingMin;
    }
    let xyPositionsWithPadding = [];
    for (let i = 0; i < convexHullXYPositions.length; i++) {
        xyPositionsWithPadding.push(convexHullXYPositions[i]);
        for (let angle = 0; angle < 360; angle += 10) {
            let x = convexHullXYPositions[i]["x"] + latLngPadding * Math.cos((angle * Math.PI) / 180);
            let y = convexHullXYPositions[i]["y"] + latLngPadding * Math.sin((angle * Math.PI) / 180) * 2;
            if (!isNaN(x) && !isNaN(y)) {
                xyPositionsWithPadding.push({ x: x, y: y });
            }
        }
    }
    let convexHullXYPositionsWithPadding = convexhull.makeHull(xyPositionsWithPadding);
    return this._convertToLatLngPos(convexHullXYPositionsWithPadding);
};
trackdirect.models.StationCoveragePolygon.prototype._getFilteredPositions = function (data, maxRange) {
    let result = [];
    for (let i = 0; i < data.length; i++) {
        if (typeof maxRange !== "undefined" && data[i].distance > maxRange) {
            continue;
        }
        result.push(data[i].latLngLiteral);
    }
    return result;
};
trackdirect.models.StationCoveragePolygon.prototype._getCoveragePolygonMaxRange = function (data, percentile) {
    let maxRange = this._getDistancePercentile(data, percentile, this._upperMaxRangeInMeters);
    if (isNaN(maxRange)) {
        maxRange = 0;
    }
    return maxRange;
};
trackdirect.models.StationCoveragePolygon.prototype._getDistancePercentile = function (data, percentile, upperMaxRange) {
    let values = [];
    for (let i = 0; i < data.length; i++) {
        if (data[i].distance + 0 < upperMaxRange) {
            values.push(data[i].distance);
        }
    }
    values.sort(function (a, b) {
        return a - b;
    });
    let index = (percentile / 100) * values.length;
    let result;
    if (Math.floor(index) == index) {
        result = (values[index - 1] + values[index]) / 2;
    } else {
        result = values[Math.floor(index)];
    }
    return result;
};
trackdirect.models.StationCoveragePolygon.prototype._getNumberOfValues = function (data, maxRange) {
    let counter = 0;
    for (let i = 0; i < data.length; i++) {
        if (data[i].distance > maxRange) {
            continue;
        }
        counter++;
    }
    return counter;
};
trackdirect.models.StationCoveragePolygon.prototype._convertToXYPos = function (positions) {
    let result = [];
    for (let i = 0; i < positions.length; i++) {
        result.push({ x: positions[i].lat, y: positions[i].lng });
    }
    return result;
};
trackdirect.models.StationCoveragePolygon.prototype._convertToLatLngPos = function (positions) {
    let result = [];
    for (let i = 0; i < positions.length; i++) {
        result.push({ lat: positions[i].x, lng: positions[i].y });
    }
    return result;
};
trackdirect.models.StationCoveragePolygon.prototype._getCoordinates = function (data) {
    let result = [];
    for (let j = 0; j < data.length; j++) {
        let position;
        if (typeof google === "object" && typeof google.maps === "object") {
            position = new google.maps.LatLng(parseFloat(data[j]["latitude"]), parseFloat(data[j]["longitude"]));
        } else {
            position = { lat: parseFloat(data[j]["latitude"]), lng: parseFloat(data[j]["longitude"]) };
        }
        result.push(position);
    }
    return result;
};
trackdirect.models.StationCoveragePolygon.prototype._addParametersToData = function (data) {
    for (let j = 0; j < data.length; j++) {
        let latLngLiteral = { lat: parseFloat(data[j].latitude), lng: parseFloat(data[j].longitude) };
        data[j].latLngLiteral = latLngLiteral;
        data[j].angle = trackdirect.services.distanceCalculator.getBearing(this._center, latLngLiteral);
    }
};
trackdirect.models.StationCoveragePolygon.prototype._emitTdEventListeners = function (event, arg) {
    if (event in this._tdEventListeners) {
        for (let i = 0; i < this._tdEventListeners[event].length; i++) {
            this._tdEventListeners[event][i](arg);
        }
    }
    if (event in this._tdEventListenersOnce) {
        let eventListenersOnce = this._tdEventListenersOnce[event].splice(0);
        this._tdEventListenersOnce[event] = [];
        for (let i = 0; i < eventListenersOnce.length; i++) {
            eventListenersOnce[i](arg);
        }
    }
};
trackdirect.models.Ruler = function (defaultLength, map) {
    this._map = map;
    if (typeof google === "object" && typeof google.maps === "object") {
        this._googleMapsInit(defaultLength);
        this._addGoolgeMapsListeners();
    } else if (typeof L === "object") {
        this.leafletInit(defaultLength);
        this._addLeafletListeners();
    }
};
trackdirect.models.Ruler.prototype._googleMapsInit = function (defaultLength) {
    this.marker1 = new google.maps.Marker({ position: trackdirect.services.distanceCalculator.getPositionByDistance(this._map.getCenterLiteral(), 270, defaultLength / 2), draggable: true, map: this._map });
    this.marker2 = new google.maps.Marker({ position: trackdirect.services.distanceCalculator.getPositionByDistance(this._map.getCenterLiteral(), 90, defaultLength / 2), draggable: true, map: this._map });
    //this.marker1 = new google.maps.marker.AdvancedMarkerElement({ position: trackdirect.services.distanceCalculator.getPositionByDistance(this._map.getCenterLiteral(), 270, defaultLength / 2), draggable: true, map: this._map });
    //this.marker2 = new google.maps.marker.AdvancedMarkerElement({ position: trackdirect.services.distanceCalculator.getPositionByDistance(this._map.getCenterLiteral(), 90, defaultLength / 2), draggable: true, map: this._map });
    this.marker1.markerLabel = new trackdirect.models.Label({ position: this.marker1.getPosition(), text: this._getDistance(this.marker1, this.marker2) }, this._map);
    this.marker1.markerLabel.show();
    this.marker2.markerLabel = new trackdirect.models.Label({ position: this.marker2.getPosition(), text: this._getDistance(this.marker2, this.marker1) }, this._map);
    this.marker2.markerLabel.show();
    this.line = new google.maps.Polyline({ path: [this.marker1.getPosition(), this.marker2.getPosition()], strokeColor: "#ffff00", strokeOpacity: 0.7, strokeWeight: 6 });
    this.line.setMap(this._map);
};
trackdirect.models.Ruler.prototype.leafletInit = function (defaultLength) {
    this.marker1 = new L.Marker(trackdirect.services.distanceCalculator.getPositionByDistance(this._map.getCenterLiteral(), 270, defaultLength / 2), { draggable: true });
    this.marker1.addTo(this._map);
    this.marker2 = new L.Marker(trackdirect.services.distanceCalculator.getPositionByDistance(this._map.getCenterLiteral(), 90, defaultLength / 2), { draggable: true });
    this.marker2.addTo(this._map);
    this.marker1.markerLabel = new trackdirect.models.Label({ position: this.marker1.getLatLng(), text: this._getDistance(this.marker1, this.marker2) }, this._map);
    this.marker1.markerLabel.show();
    this.marker2.markerLabel = new trackdirect.models.Label({ position: this.marker2.getLatLng(), text: this._getDistance(this.marker2, this.marker1) }, this._map);
    this.marker2.markerLabel.show();
    this.line = new L.Polyline([this.marker1.getLatLng(), this.marker2.getLatLng()], { color: "#ffff00", opacity: 0.8, weight: 6 });
    this.line.addTo(this._map);
};
trackdirect.models.Ruler.prototype.show = function () {
    this.marker1.markerLabel.show();
    this.marker2.markerLabel.show();
    if (typeof google === "object" && typeof google.maps === "object") {
        this.marker1.setMap(this._map);
        this.marker2.setMap(this._map);
        this.line.setMap(this._map);
    } else if (typeof L === "object") {
        this.marker1.addTo(this._map);
        this.marker2.addTo(this._map);
        this.line.addTo(this._map);
    }
};
trackdirect.models.Ruler.prototype.hide = function () {
    this.marker1.markerLabel.hide();
    this.marker2.markerLabel.hide();
    if (typeof google === "object" && typeof google.maps === "object") {
        this.marker1.setMap(null);
        this.marker2.setMap(null);
        this.line.setMap(null);
    } else if (typeof L === "object") {
        this._map.removeLayer(this.marker1);
        this._map.removeLayer(this.marker2);
        this._map.removeLayer(this.line);
    }
};
trackdirect.models.Ruler.prototype._addGoolgeMapsListeners = function () {
    let me = this;
    google.maps.event.addListener(this.marker1, "drag", function () {
        me.line.setPath([me.marker1.getPosition(), me.marker2.getPosition()]);
        me._updateLabels();
    });
    google.maps.event.addListener(this.marker2, "drag", function () {
        me.line.setPath([me.marker1.getPosition(), me.marker2.getPosition()]);
        me._updateLabels();
    });
};
trackdirect.models.Ruler.prototype._addLeafletListeners = function () {
    let me = this;
    this.marker1.on("drag", function (e) {
        me.line.setLatLngs([me.marker1.getLatLng(), me.marker2.getLatLng()]);
        me._updateLabels();
    });
    this.marker2.on("drag", function (e) {
        me.line.setLatLngs([me.marker1.getLatLng(), me.marker2.getLatLng()]);
        me._updateLabels();
    });
};
trackdirect.models.Ruler.prototype._updateLabels = function () {
    this.marker1.markerLabel.hide();
    this.marker2.markerLabel.hide();
    if (typeof google === "object" && typeof google.maps === "object") {
        this.marker1.markerLabel = new trackdirect.models.Label({ position: this.marker1.getPosition(), text: this._getDistance(this.marker1, this.marker2) }, this._map);
        this.marker2.markerLabel = new trackdirect.models.Label({ position: this.marker2.getPosition(), text: this._getDistance(this.marker2, this.marker1) }, this._map);
    } else if (typeof L === "object") {
        this.marker1.markerLabel = new trackdirect.models.Label({ position: this.marker1.getLatLng(), text: this._getDistance(this.marker1, this.marker2) }, this._map);
        this.marker2.markerLabel = new trackdirect.models.Label({ position: this.marker2.getLatLng(), text: this._getDistance(this.marker2, this.marker1) }, this._map);
    }
    this.marker1.markerLabel.show();
    this.marker2.markerLabel.show();
};
trackdirect.models.Ruler.prototype._getDistance = function (marker1, marker2) {
    let p1 = this._getPositionLiteral(marker1);
    let p2 = this._getPositionLiteral(marker2);
    let distance = Math.round(trackdirect.services.distanceCalculator.getDistance(p1, p2), 0);
    if (distance > 99999) {
        if (this._map.state.useImperialUnit) {
            distance = Math.round(trackdirect.services.imperialConverter.convertKilometerToMile(distance / 1000)).toString() + " miles";
        } else {
            distance = Math.round(distance / 1000).toString() + " km";
        }
    } else if (distance > 999) {
        if (this._map.state.useImperialUnit) {
            distance = (Math.round(trackdirect.services.imperialConverter.convertKilometerToMile(distance / 1000) * 10) / 10).toString() + " miles";
        } else {
            distance = (Math.round(distance / 100) / 10).toString() + " km";
        }
    } else {
        distance = distance.toString() + " m";
    }
    let bearing = Math.round(trackdirect.services.distanceCalculator.getBearing(p2, p1), 0).toString();
    return bearing + "&ordm; " + distance;
};
trackdirect.models.Ruler.prototype._getPositionLiteral = function (marker) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let latLng = marker.getPosition();
        if (typeof latLng !== "undefined" && typeof latLng.lat === "function") {
            return { lat: latLng.lat(), lng: latLng.lng() };
        } else {
            return latLng;
        }
    } else if (typeof L === "object") {
        let latLng = marker.getLatLng();
        if (typeof latLng !== "undefined") {
            return { lat: latLng.lat, lng: latLng.lng };
        } else {
            return latLng;
        }
    }
    return null;
};
trackdirect.models.RngCircle = function (packet, map, isHalf) {
    this._defaultMap = map;
    if (typeof google === "object" && typeof google.maps === "object") {
        const googleCircle = new google.maps.Circle(this._getGoogleCircleOptions(packet, isHalf));
        for (const key of Object.keys(this)) {
            googleCircle[key] = this[key];
        }
        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {
            if (key !== "constructor" && typeof this[key] === "function") {
                googleCircle[key] = this[key];
            }
        }
        return googleCircle;
    } else if (typeof L === "object") {
        let center = packet.getLatLngLiteral();
        if (L.version <= "0.7.7") {
            let range = this._getCircleRadius(packet, isHalf);
            L.Circle.call(this, [center.lat, center.lng], range, this._getLeafletCircleOptions(packet, isHalf));
        } else {
            L.Circle.call(this, center, this._getLeafletCircleOptions(packet, isHalf));
        }
    }
};
if (typeof google === "object" && typeof google.maps === "object") {
    trackdirect.models.RngCircle.prototype = Object.create(google.maps.Circle.prototype);
} else if (typeof L === "object") {
    trackdirect.models.RngCircle.prototype = Object.create(L.Circle.prototype);
}
trackdirect.models.RngCircle.prototype.constructor = trackdirect.models.RngCircle;
trackdirect.models.RngCircle.prototype.show = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (typeof this.getMap() === "undefined" || this.getMap() === null) {
            this.setMap(this._defaultMap);
        }
    } else if (typeof L === "object") {
        if (!this._defaultMap.hasLayer(this)) {
            this.addTo(this._defaultMap);
        }
    }
};
trackdirect.models.RngCircle.prototype.hide = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (this.getMap() !== null) {
            this.setMap(null);
        }
    } else if (typeof L === "object") {
        if (this._defaultMap.hasLayer(this)) {
            this._defaultMap.removeLayer(this);
        }
    }
};
trackdirect.models.RngCircle.prototype._getGoogleCircleOptions = function (packet, isHalf) {
    let color = trackdirect.services.stationColorCalculator.getColor(packet);
    let range = this._getCircleRadius(packet, isHalf);
    let options = { strokeColor: color, strokeOpacity: 0.6, strokeWeight: 1, fillColor: color, fillOpacity: 0.3, map: null, center: packet.getLatLngLiteral(), radius: range * 1000 };
    return options;
};
trackdirect.models.RngCircle.prototype._getLeafletCircleOptions = function (packet, isHalf) {
    let color = trackdirect.services.stationColorCalculator.getColor(packet);
    let range = this._getCircleRadius(packet, isHalf);
    let options = { color: color, opacity: 0.6, weight: 1, fillColor: color, fillOpacity: 0.3, radius: range * 1000 };
    return options;
};
trackdirect.models.RngCircle.prototype._getCircleRadius = function (packet, isHalf) {
    let range = packet.getRNGRange();
    if (range === null) {
        range = 0;
    }
    if (isHalf) {
        range = range / 2;
    }
    return range;
};
trackdirect.models.PhgCircle = function (packet, map, isHalf) {
    this._defaultMap = map;
    if (typeof google === "object" && typeof google.maps === "object") {
        const googleCircle = new google.maps.Circle(this._getGoogleCircleOptions(packet, isHalf));
        for (const key of Object.keys(this)) {
            googleCircle[key] = this[key];
        }
        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {
            if (key !== "constructor" && typeof this[key] === "function") {
                googleCircle[key] = this[key];
            }
        }
        return googleCircle;
    } else if (typeof L === "object") {
        if (L.version <= "0.7.7") {
            let range = this._getCircleRadius(packet, isHalf);
            let center = this._getCircleCenter(packet, isHalf);
            L.Circle.call(this, [center.lat, center.lng], range, this._getLeafletCircleOptions(packet, isHalf));
        } else {
            L.Circle.call(this, this._getCircleCenter(packet, isHalf), this._getLeafletCircleOptions(packet, isHalf));
        }
    }
};
if (typeof google === "object" && typeof google.maps === "object") {
    trackdirect.models.PhgCircle.prototype = Object.create(google.maps.Circle.prototype);
} else if (typeof L === "object") {
    trackdirect.models.PhgCircle.prototype = Object.create(L.Circle.prototype);
}
trackdirect.models.PhgCircle.prototype.constructor = trackdirect.models.PhgCircle;
trackdirect.models.PhgCircle.prototype.show = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (typeof this.getMap() === "undefined" || this.getMap() === null) {
            this.setMap(this._defaultMap);
        }
    } else if (typeof L === "object") {
        if (!this._defaultMap.hasLayer(this)) {
            this.addTo(this._defaultMap);
        }
    }
};
trackdirect.models.PhgCircle.prototype.hide = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (this.getMap() !== null) {
            this.setMap(null);
        }
    } else if (typeof L === "object") {
        if (this._defaultMap.hasLayer(this)) {
            this._defaultMap.removeLayer(this);
        }
    }
};
trackdirect.models.PhgCircle.prototype._getGoogleCircleOptions = function (packet, isHalf) {
    let color = trackdirect.services.stationColorCalculator.getColor(packet);
    let range = this._getCircleRadius(packet, isHalf);
    let center = this._getCircleCenter(packet, isHalf);
    let options = { strokeColor: color, strokeOpacity: 0.6, strokeWeight: 1, fillColor: color, fillOpacity: 0.3, map: null, center: center, radius: range };
    return options;
};
trackdirect.models.PhgCircle.prototype._getLeafletCircleOptions = function (packet, isHalf) {
    let color = trackdirect.services.stationColorCalculator.getColor(packet);
    let range = this._getCircleRadius(packet, isHalf);
    let options = { color: color, opacity: 0.6, weight: 1, fillColor: color, fillOpacity: 0.3, radius: range };
    return options;
};
trackdirect.models.PhgCircle.prototype._getCircleRadius = function (packet, isHalf) {
    let range = packet.getPHGRange();
    if (range === null) {
        range = 0;
    }
    if (isHalf) {
        range = range / 2;
    }
    return range;
};
trackdirect.models.PhgCircle.prototype._getCircleCenter = function (packet, isHalf) {
    let direction = packet.getPhgDirectionDegree();
    let center = packet.getLatLngLiteral();
    if (direction != null) {
        let range = packet.getPHGRange();
        if (range === null) {
            range = 0;
        }
        if (isHalf) {
            range = range / 2;
        }
        let distance = (range * 2) / 3 / 2;
        center = trackdirect.services.distanceCalculator.getPositionByDistance(center, direction, distance);
    }
    return center;
};
trackdirect.models.Packet = function (data) {
    this.init();
    for (let key in data) {
        this[key] = data[key];
    }
};
trackdirect.models.Packet.prototype.init = function () {
    this["altitude"] = null;
    this["comment"] = "";
    this["course"] = null;
    this["db"] = null;
    this["id"] = null;
    this["latest_phg_timestamp"] = null;
    this["latest_rng_timestamp"] = null;
    this["latitude"] = null;
    this["longitude"] = null;
    this["map_id"] = null;
    this["map_sector"] = null;
    this["marker_counter"] = null;
    this["marker_id"] = null;
    this["ogn"] = null;
    this["overwrite"] = null;
    this["is_moving"] = 1;
    this["packet_order_id"] = null;
    this["packet_tail_timestamp"] = null;
    this["packet_type_id"] = null;
    this["phg"] = null;
    this["posambiguity"] = 0;
    this["position_timestamp"] = null;
    this["raw"] = "";
    this["raw_path"] = "";
    this["realtime"] = 0;
    this["related_map_sectors"] = [];
    this["reported_timestamp"] = null;
    this["rng"] = null;
    this["sender_id"] = null;
    this["sender_name"] = null;
    this["source_id"] = null;
    this["speed"] = null;
    this["station_id"] = null;
    this["station_id_path"] = [];
    this["station_location_path"] = [];
    this["station_name"] = null;
    this["station_name_path"] = [];
    this["symbol"] = null;
    this["symbol_table"] = null;
    this["telemetry"] = null;
    this["timestamp"] = null;
    this["weather"] = null;
};
trackdirect.models.Packet.prototype.getStationName = function () {
    if (this.station_name == this.sender_name) {
        return escapeHtml(this.station_name);
    } else {
        return escapeHtml(this.station_name + " (" + this.sender_name + ")");
    }
};
trackdirect.models.Packet.prototype.getLatLngLiteral = function () {
    return { lat: parseFloat(this.latitude), lng: parseFloat(this.longitude) };
};
trackdirect.models.Packet.prototype.hasConfirmedMapId = function () {
    if ([1, 2, 12].indexOf(this.map_id) >= 0) {
        return true;
    }
    return false;
};
trackdirect.models.Packet.prototype.getOgnAircraftType = function () {
    if (typeof this.ogn !== "undefined" && this.ogn !== null) {
        if (typeof this.ogn.ogn_aircraft_type_id !== "undefined" && this.ogn.ogn_aircraft_type_id != "") {
            if (this.ogn.ogn_aircraft_type_id == 1) {
                return "Glider";
            } else if (this.ogn.ogn_aircraft_type_id == 2) {
                return "Tow Plane";
            } else if (this.ogn.ogn_aircraft_type_id == 3) {
                return "Helicopter";
            } else if (this.ogn.ogn_aircraft_type_id == 4) {
                return "Parachute";
            } else if (this.ogn.ogn_aircraft_type_id == 5) {
                return "Drop Plane";
            } else if (this.ogn.ogn_aircraft_type_id == 6) {
                return "Hang Glider";
            } else if (this.ogn.ogn_aircraft_type_id == 7) {
                return "Para Glider";
            } else if (this.ogn.ogn_aircraft_type_id == 8) {
                return "Powered Aircraft";
            } else if (this.ogn.ogn_aircraft_type_id == 9) {
                return "Jet Aircraft";
            } else if (this.ogn.ogn_aircraft_type_id == 10) {
                return "UFO";
            } else if (this.ogn.ogn_aircraft_type_id == 11) {
                return "Balloon";
            } else if (this.ogn.ogn_aircraft_type_id == 12) {
                return "Airship";
            } else if (this.ogn.ogn_aircraft_type_id == 13) {
                return "UAV";
            } else if (this.ogn.ogn_aircraft_type_id == 14) {
                return "";
            } else if (this.ogn.ogn_aircraft_type_id == 15) {
                return "Static Object";
            }
        }
    }
    return null;
};
trackdirect.models.Packet.prototype.getOgnDdbAircraftType = function () {
    if (typeof this.ogn_device !== "undefined" && this.ogn_device !== null) {
        if (typeof this.ogn_device.ddb_aircraft_type !== "undefined" && this.ogn_device.ddb_aircraft_type != "") {
            if (this.ogn_device.ddb_aircraft_type == 1) {
                return "Glider/Motoglider";
            } else if (this.ogn_device.ddb_aircraft_type == 2) {
                return "Plane";
            } else if (this.ogn_device.ddb_aircraft_type == 3) {
                return "Ultralight";
            } else if (this.ogn_device.ddb_aircraft_type == 4) {
                return "Helicopter";
            } else if (this.ogn_device.ddb_aircraft_type == 5) {
                return "Drone/UAV";
            } else if (this.ogn_device.ddb_aircraft_type == 6) {
                return "Other";
            }
        }
    }
    return null;
};
trackdirect.models.Packet.prototype.getOgnAddressType = function () {
    if (typeof this.ogn !== "undefined" && this.ogn !== null) {
        if (typeof this.ogn.ogn_address_type_id !== "undefined" && this.ogn.ogn_address_type_id != "") {
            if (this.ogn.ogn_address_type_id == 1) {
                return "ICAO";
            } else if (this.ogn.ogn_address_type_id == 2) {
                return "FLARM";
            } else if (this.ogn.ogn_address_type_id == 3) {
                return "OGN";
            }
        }
    }
    return null;
};
trackdirect.models.Packet.prototype.getOgnSenderAddress = function () {
    if (typeof this.ogn !== "undefined" && this.ogn !== null) {
        if (typeof this.ogn.ogn_sender_address !== "undefined" && this.ogn.ogn_sender_address != "") {
            return this.ogn.ogn_sender_address;
        }
    }
    return null;
};
trackdirect.models.Packet.prototype.getOgnRegistration = function () {
    if (typeof this.ogn_device !== "undefined" && this.ogn_device !== null) {
        if (typeof this.ogn_device.registration !== "undefined" && this.ogn_device.registration != "") {
            return this.ogn_device.registration;
        }
    }
    return null;
};
trackdirect.models.Packet.prototype.getOgnCN = function () {
    if (typeof this.ogn_device !== "undefined" && this.ogn_device !== null) {
        if (typeof this.ogn_device.cn !== "undefined" && this.ogn_device.cn != "") {
            return this.ogn_device.cn;
        }
    }
    return null;
};
trackdirect.models.Packet.prototype.getOgnSummary = function () {
    let senderAddress = this.getOgnSenderAddress();
    let aircraftType = this.getOgnAircraftType();
    let ddbAircraftType = this.getOgnDdbAircraftType();
    let addressType = this.getOgnAddressType();
    let summary = "";
    if (ddbAircraftType !== null) {
        summary += ddbAircraftType;
    } else if (aircraftType !== null) {
        summary += aircraftType;
    }
    if (senderAddress !== null) {
        if (summary != "") {
            summary += " ";
        }
        summary += senderAddress;
        if (addressType !== null) {
            summary += " (" + addressType + ")";
        }
    }
    return summary;
};
trackdirect.models.Packet.prototype.hasDirectionSupport = function () {
    if (this.course !== null && this.speed !== null && this.speed > 0 && this.source_id == 1 && this.packet_order_id == 1 && this.is_moving == 1 && this.hasConfirmedMapId()) {
        let symbolCategory = 1;
        if (this.symbol_table.charCodeAt(0) == "92") {
            symbolCategory = 2;
        }
        if (symbolCategory == 1 && trackdirect.settings.primarySymbolWithNoDirectionPolyline.indexOf(parseInt(this.symbol.charCodeAt(0))) > -1) {
            return false;
        }
        if (symbolCategory == 2 && trackdirect.settings.alternativeSymbolWithNoDirectionPolyline.indexOf(parseInt(this.symbol.charCodeAt(0))) > -1) {
            return false;
        }
        return true;
    }
    return false;
};
trackdirect.models.Packet.prototype.getPhg = function () {
    if (this.phg !== null) {
        if (this.phg == 0) {
            return null;
        } else if (this.phg < 10) {
            return "000" + String(this.phg);
        } else if (this.phg < 100) {
            return "00" + String(this.phg);
        } else if (this.phg < 1000) {
            return "0" + String(this.phg);
        } else {
            return String(this.phg);
        }
    }
    return null;
};
trackdirect.models.Packet.prototype.getRNGRange = function () {
    if (this.rng !== null) {
        return this.rng;
    }
    return null;
};
trackdirect.models.Packet.prototype.getPHGRange = function () {
    if (this.getPhg() !== null) {
        let p = this.getPhgPower();
        let h = this.getPhgHaat(false);
        let g = this.getPhgGain();
        let gain = Math.pow(10, g / 10);
        let range = Math.sqrt(2 * h * Math.sqrt((p / 10) * (gain / 2)));
        return range / 0.000621371192;
    }
    return null;
};
trackdirect.models.Packet.prototype.getPHGDescription = function () {
    if (this.getPhg() !== null) {
        let power = this.getPhgPower();
        let haat = this.getPhgHaat();
        let gain = this.getPhgGain();
        let direction = this.getPhgDirection();
        let description = "";
        if (power !== null) {
            description += "Power " + power + "W";
        }
        if (haat !== null) {
            if (description.length > 0) {
                description += ", ";
            }
            description += "Height " + haat + "m";
        }
        if (gain !== null && direction !== null) {
            if (description.length > 0) {
                description += ", ";
            }
            description += "Gain " + gain + "dB " + direction;
        }
        return description;
    }
    return null;
};
trackdirect.models.Packet.prototype.getPhgPower = function () {
    if (this.getPhg() !== null) {
        return Math.pow(parseInt(this.getPhg().substring(0, 1)), 2);
    }
    return null;
};
trackdirect.models.Packet.prototype.getPhgHaat = function (inMeters) {
    inMeters = typeof inMeters !== "undefined" ? inMeters : true;
    if (this.getPhg() != null) {
        value = parseInt(this.getPhg().substring(1, 2));
        let haat = 10;
        if (value == 1) {
            haat = 20;
        } else if (value > 1) {
            haat = 10 * Math.pow(value, 2);
        }
        if (inMeters) {
            return Math.round(haat * 0.3048, 0);
        } else {
            return haat;
        }
    }
    return null;
};
trackdirect.models.Packet.prototype.getPhgGain = function () {
    if (this.getPhg() != null) {
        return parseInt(this.getPhg().substring(2, 3));
    }
    return null;
};
trackdirect.models.Packet.prototype.getPhgDirection = function () {
    if (this.getPhg() != null) {
        switch (parseInt(this.getPhg().substring(3, 4))) {
            case 0:
                return "omni";
                break;
            case 1:
                return "North East";
                break;
            case 2:
                return "East";
                break;
            case 3:
                return "South East";
                break;
            case 4:
                return "South";
                break;
            case 5:
                return "South West";
                break;
            case 6:
                return "West";
                break;
            case 7:
                return "North West";
                break;
            case 8:
                return "North";
                break;
        }
    }
    return null;
};
trackdirect.models.Packet.prototype.getPhgDirectionDegree = function () {
    if (this.getPhg() != null) {
        switch (parseInt(this.getPhg().substring(3, 4))) {
            case 0:
                return null;
                break;
            case 1:
                return 45;
                break;
            case 2:
                return 90;
                break;
            case 3:
                return 135;
                break;
            case 4:
                return 180;
                break;
            case 5:
                return 225;
                break;
            case 6:
                return 270;
                break;
            case 7:
                return 315;
                break;
            case 8:
                return 360;
                break;
        }
    }
    return null;
};
trackdirect.models.Packet.prototype.getMarkerDistance = function (marker) {
    let packetLatLng = { lat: parseFloat(this.latitude), lng: parseFloat(this.longitude) };
    let markerPacketLatLng = { lat: parseFloat(marker.packet.latitude), lng: parseFloat(marker.packet.longitude) };
    return trackdirect.services.distanceCalculator.getDistance(packetLatLng, markerPacketLatLng);
};
trackdirect.models.Packet.prototype.hasSameSymbol = function (marker) {
    if (marker.packet.symbol == this.symbol && marker.packet.symbol_table == this.symbol_table) {
        return true;
    }
    return false;
};
trackdirect.models.Packet.prototype.getLinkifiedRawPath = function () {
    if (typeof this.raw_path !== "undefined" && this.raw_path !== null && this.raw_path !== "") {
        let rawPath = escapeHtml(this.raw_path);
        rawPath = "#" + rawPath + "#";
        for (let i = 0; i < this.station_id_path.length; i++) {
            let relatedStationId = this.station_id_path[i];
            if (typeof this.station_name_path !== "undefined" && this.station_name_path !== null) {
                let relatedStationName = escapeHtml(this.station_name_path[i]);
                let relatedStationNameReplacement =
                    '<a href="#" onclick="' +
                    " let relatedStationLatestPacket = trackdirect._map.markerCollection.getStationLatestPacket(" +
                    relatedStationId +
                    ");" +
                    " if (relatedStationLatestPacket !== null) {" +
                    "     trackdirect.focusOnStation(" +
                    relatedStationId +
                    ", true);" +
                    " } else {" +
                    "     alert('Can not go to " +
                    relatedStationName +
                    ", station has not been heard for a long time.');" +
                    " }" +
                    ' return false;">' +
                    relatedStationName +
                    "</a>";
                rawPath = rawPath.replaceAll("#" + relatedStationName + ",", "#" + relatedStationNameReplacement + ",");
                rawPath = rawPath.replaceAll("#" + relatedStationName + "*", "#" + relatedStationNameReplacement + "*");
                rawPath = rawPath.replaceAll("#" + relatedStationName + ":", "#" + relatedStationNameReplacement + ":");
                rawPath = rawPath.replaceAll("#" + relatedStationName + "#", "#" + relatedStationNameReplacement + "#");
                rawPath = rawPath.replaceAll("," + relatedStationName + ",", "," + relatedStationNameReplacement + ",");
                rawPath = rawPath.replaceAll("," + relatedStationName + "*", "," + relatedStationNameReplacement + "*");
                rawPath = rawPath.replaceAll("," + relatedStationName + ":", "," + relatedStationNameReplacement + ":");
                rawPath = rawPath.replaceAll("," + relatedStationName + "#", "," + relatedStationNameReplacement + "#");
            }
        }
        rawPath = rawPath.replace(/#+$/, "");
        rawPath = rawPath.replace(/^#+/, "");
        let rawPathArray = rawPath.split(",");
        if (rawPathArray.length > 0) {
            rawPath = rawPathArray[0] + " via " + rawPathArray.join(",").replace(rawPathArray[0] + ",", "");
        }
        return rawPath;
    }
    return null;
};
trackdirect.MarkerCreator = function (map) {
    this._map = map;
    this._currentPacketSequenceStationId = null;
};
trackdirect.MarkerCreator.prototype.addPacket = function (packet, tryToShowPacket) {
    if (this.isBadPacket(packet)) {
        return null;
    }
    let markerIdKey = this._map.markerCollection.getMarkerIdKey(packet.marker_id);
    if (this._map.markerCollection.isExistingMarker(markerIdKey)) {
        let marker = this._map.markerCollection.getMarker(markerIdKey);
        if (marker.packet.is_moving == 1 && packet.is_moving != 1) {
            packet.is_moving = 1;
        }
    } else {
        if (packet.packet_order_id == 2) {
            packet.packet_order_id = 3;
        }
    }
    markerIdKeyToOverwrite = this._getMarkerIdKeyToOverwrite(packet);
    if (markerIdKeyToOverwrite !== null) {
        this._overwriteMarker(markerIdKeyToOverwrite, markerIdKey);
    }
    if (this._map.markerCollection.isPacketReplacingMarker(packet)) {
        this._replaceMarker(markerIdKey);
    }
    this._setCurrentPacketSequenceStationId(packet);
    this._convertLostMarkersToGhost(packet);
    this._connectToPreviousMarker(packet);
    marker = this._createMarker(packet);
    this._map.addMarkerToMapSectors(markerIdKey, packet, tryToShowPacket);
    if (packet.overwrite == 1) {
        marker.overwrite = true;
    }
    return markerIdKey;
};
trackdirect.MarkerCreator.prototype._getMarkerIdKeyToOverwrite = function (packet) {
    let markerIdKey = this._map.markerCollection.getMarkerIdKey(packet.marker_id);
    if (this._map.markerCollection.isExistingMarker(markerIdKey)) {
        let marker = this._map.markerCollection.getMarker(markerIdKey);
        if (marker.overwrite == true && packet.overwrite == 0) {
            return markerIdKey;
        }
    } else {
        let prevMarker = this._map.markerCollection.getStationLatestMarker(packet.station_id);
        if (prevMarker !== null) {
            if (
                packet.is_moving == 0 &&
                packet.station_id == prevMarker.packet.station_id &&
                packet.timestamp - prevMarker.packet.timestamp > 86400 &&
                Math.round(prevMarker.packet.latitude * 100000) == Math.round(packet.latitude * 100000) &&
                Math.round(prevMarker.packet.longitude * 100000) == Math.round(packet.longitude * 100000) &&
                prevMarker.packet.symbol == packet.symbol &&
                prevMarker.packet.symbol_table == packet.symbol_table
            ) {
                return prevMarker.markerIdKey;
            }
        }
    }
    return null;
};
trackdirect.MarkerCreator.prototype._replaceMarker = function (markerIdKey) {
    if (this._map.markerCollection.isExistingMarker(markerIdKey)) {
        let marker = this._map.markerCollection.getMarker(markerIdKey);
        if (this._map.state.isMarkerInfoWindowOpen(marker)) {
            this._map.state.openInfoWindowForMarkerIdKey = markerIdKey;
        }
        marker.hide(0, false, false);
        marker.stopDirectionPolyline();
    }
};
trackdirect.MarkerCreator.prototype._overwriteMarker = function (prevMarkerIdKey, newMarkerIdKey) {
    let prevMarker = this._map.markerCollection.getMarker(prevMarkerIdKey);
    if (this._map.state.isMarkerInfoWindowOpen(prevMarker)) {
        this._map.state.openInfoWindowForMarkerIdKey = newMarkerIdKey;
    }
    let markerLabel = prevMarker.label;
    let markerPolyLine = this._map.markerCollection.getMarkerPolyline(prevMarkerIdKey);
    let markerDotMarkers = this._map.markerCollection.getDotMarkers(prevMarkerIdKey);
    let markerOriginDashedPolyline = this._map.markerCollection.getMarkerDashedPolyline(prevMarkerIdKey);
    clearTimeout(prevMarker.toOldTimerId);
    if (markerDotMarkers != null) {
        for (let i = 0; i < markerDotMarkers.length; i++) {
            clearTimeout(markerDotMarkers[i].toOldTimerId);
        }
    }
    this._map.markerCollection.resetMarker(prevMarkerIdKey);
    if (this._map.oms) {
        this._map.oms.removeMarker(prevMarker);
    }
    if (prevMarker != null && typeof prevMarker.packet.latitude != "undefined" && typeof prevMarker.packet.longitude != "undefined") {
        this._map.markerCollection.removePostionMarkerId(prevMarker.packet.latitude, prevMarker.packet.longitude, prevMarkerIdKey);
        this._map.showTopLabelOnPosition(prevMarker.packet.latitude, prevMarker.packet.longitude);
    }
    prevMarker.hide(0, false, false);
    if (markerPolyLine !== null) {
        markerPolyLine.hide();
    }
    if (markerDotMarkers != null) {
        for (let i = 0; i < markerDotMarkers.length; i++) {
            markerDotMarkers[i].hide();
        }
    }
    if (markerOriginDashedPolyline !== null) {
        markerOriginDashedPolyline.hide();
        if (typeof markerOriginDashedPolyline.relatedMarkerIdKey !== "undefined" && markerOriginDashedPolyline.relatedMarkerIdKey !== null) {
            let prevMarker = this._map.markerCollection.getMarker(markerOriginDashedPolyline.relatedMarkerIdKey);
            if (prevMarker !== null && typeof prevMarker._relatedMarkerOriginDashedPolyLine !== "undefined") {
                prevMarker._relatedMarkerOriginDashedPolyLine = null;
            }
        }
    }
    prevMarker.hidePHGCircle();
    prevMarker.hideRNGCircle();
    if (prevMarker.directionPolyLine !== null) {
        prevMarker.directionPolyLine.stop();
    }
};
trackdirect.MarkerCreator.prototype._setCurrentPacketSequenceStationId = function (packet) {
    if (packet.packet_order_id == 3) {
        this._currentPacketSequenceStationId = packet.station_id;
    }
    if (packet.packet_order_id == 2 && this._currentPacketSequenceStationId === null) {
        this._currentPacketSequenceStationId = packet.station_id;
        packet.packet_order_id = 3;
    }
    if (packet.packet_order_id == 1) {
        this._currentPacketSequenceStationId = null;
    }
};
trackdirect.MarkerCreator.prototype._createMarker = function (packet) {
    let marker;
    let markerIdKey = this._map.markerCollection.getMarkerIdKey(packet.marker_id);
    let prevmarker = this._map.markerCollection.getMarker(markerIdKey);
    this._map.state.currentMarkerZindex += 1;
    if (packet.packet_order_id == 1 || packet.is_moving == 0) {
        if (prevmarker !== null) {
            if (prevmarker.packet.latitude != packet.latitude && prevmarker.packet.longitude != packet.longitude) {
                this._map.markerCollection.removePostionMarkerId(prevmarker.latitude, prevmarker.longitude, markerIdKey);
                this._map.showTopLabelOnPosition(prevmarker.latitude, prevmarker.longitude);
            }
        }
        marker = new trackdirect.models.Marker(packet, false, this._map);
        this._addInfoWindowClickListener(marker, true);
    } else {
        marker = new trackdirect.models.Marker(packet, true, this._map);
        this._map.markerCollection.addDotMarker(markerIdKey, marker);
        this._addInfoWindowClickListener(marker, false);
    }
    marker.markerIdKey = markerIdKey;
    if (prevmarker !== null) {
        if (!this._map.markerCollection.isPacketReplacingMarker(packet)) {
            this._extendTail(prevmarker, marker);
        } else {
            this._replaceTailMarker(markerIdKey);
        }
    }
    if (packet.packet_order_id == 1) {
        if (packet.hasDirectionSupport() && packet.hasConfirmedMapId()) {
            marker.directionPolyLine = new trackdirect.models.DirectionPolyline(marker, this._map);
        }
    }
    this._map.markerCollection.setMarker(markerIdKey, marker);
    if (!marker.isDotMarker()) {
        this._createMarkerLabel(marker);
        this._map.showTopLabelOnPosition(packet.latitude, packet.longitude);
    }
    return marker;
};
trackdirect.MarkerCreator.prototype._addInfoWindowClickListener = function (marker, useOmsIfExists) {
    let me = this;
    if (useOmsIfExists && this._map.oms) {
        me._map.oms.addMarker(marker);
    } else if (typeof google === "object" && typeof google.maps === "object") {
        marker.addListener("click", function () {
            me._map.openMarkerInfoWindow(marker, false);
        });
    } else if (typeof L === "object") {
        marker.on("click", function () {
            me._map.openMarkerInfoWindow(marker, false);
        });
    }
};
trackdirect.MarkerCreator.prototype._convertToDotMarker = function (markerIdKey, packet) {
    let dotMarker = this._map.markerCollection.getMarker(markerIdKey);
    if (dotMarker != null && dotMarker.showAsMarker) {
        dotMarker.stopDirectionPolyline();
        if (this._map.state.isMarkerInfoWindowOpen(dotMarker)) {
            this._map.state.openInfoWindowForMarkerIdKey = markerIdKey;
        }
        if (!this._map.state.isFilterMode) {
            if (this._map.getZoom() < trackdirect.settings.minZoomForMarkerPrevPosition) {
                dotMarker.hide();
            }
        }
        let icon = this._getDotMarkerIcon(packet);
        dotMarker.setOpacity(1.0);
        dotMarker.setIcon(icon);
        if (typeof google === "object" && typeof google.maps === "object") {
            dotMarker.setOptions({ anchorPoint: null });
        }
        this._map.markerCollection.addDotMarker(markerIdKey, dotMarker);
        if (this._map.oms) {
            this._map.oms.removeMarker(dotMarker);
            let me = this;
            if (typeof google === "object" && typeof google.maps === "object") {
                dotMarker.addListener("click", function () {
                    me._map.openMarkerInfoWindow(dotMarker, false);
                });
            } else if (typeof L === "object") {
                dotMarker.on("click", function () {
                    me._map.openMarkerInfoWindow(dotMarker, false);
                });
            }
        }
        if (this._map.markerCollection.hasMarkerLabel(markerIdKey)) {
            let markerLabel = this._map.markerCollection.getMarkerLabel(markerIdKey);
            markerLabel.hide();
        }
        dotMarker.hasLabel = false;
        dotMarker.showAsMarker = false;
    }
};
trackdirect.MarkerCreator.prototype._getDotMarkerIcon = function (packet) {
    let colorId = trackdirect.services.stationColorCalculator.getColorId(packet);
    let icon;
    if (typeof google === "object" && typeof google.maps === "object") {
        icon = { url: trackdirect.settings.baseUrl + trackdirect.settings.imagesBaseDir + "dotColor" + colorId + ".png", size: new google.maps.Size(12, 12), origin: new google.maps.Point(0, 0), anchor: new google.maps.Point(6, 6) };
    } else if (typeof L === "object") {
        icon = L.icon({ iconUrl: trackdirect.settings.baseUrl + trackdirect.settings.imagesBaseDir + "dotColor" + colorId + ".png", iconSize: [12, 12], iconAnchor: [6, 6], popupAnchor: [-3, -12] });
    }
    return icon;
};
trackdirect.MarkerCreator.prototype._removeExistingRelatedMarkerOriginDashedPolyLine = function (prevMarker, newMarkerIdKey) {
    if (typeof prevMarker._relatedMarkerOriginDashedPolyLine !== "undefined" && prevMarker._relatedMarkerOriginDashedPolyLine !== null) {
        let ownerMarkerIdKey = prevMarker._relatedMarkerOriginDashedPolyLine.ownerMarkerIdKey;
        let ownerMarker = this._map.markerCollection.getMarker(ownerMarkerIdKey);
        let isConfirmedMapId = true;
        if (ownerMarker !== null && ownerMarker.packet.map_id != 1 && ownerMarker.packet.map_id != 2 && ownerMarker.packet.map_id != 12) {
            isConfirmedMapId = false;
        }
        if (ownerMarkerIdKey != newMarkerIdKey && (!isConfirmedMapId || !this._map.markerCollection.hasDotMarkers(ownerMarkerIdKey)) && ownerMarker.showAsMarker) {
            this._map.markerCollection.resetMarkerDashedPolyline(prevMarker._relatedMarkerOriginDashedPolyLine.ownerMarkerIdKey);
            prevMarker._relatedMarkerOriginDashedPolyLine.hide();
            prevMarker._relatedMarkerOriginDashedPolyLine = null;
        }
    }
};
trackdirect.MarkerCreator.prototype._createMarkerOriginDashedPolyLine = function (prevMarker, packet, newMarkerIdKey) {
    if (this._map.state.getClientTimestamp(prevMarker.packet.timestamp) <= this._map.state.getOldestAllowedPacketTimestamp()) {
        return;
    }
    if (typeof prevMarker._relatedMarkerOriginDashedPolyLine === "undefined" || prevMarker._relatedMarkerOriginDashedPolyLine === null) {
        let color = trackdirect.services.stationColorCalculator.getColor(packet);
        let newDashedPolyline = new trackdirect.models.DashedTailPolyline(color, this._map);
        newDashedPolyline.setMarkerIdKey(newMarkerIdKey);
        newDashedPolyline.setRelatedMarkerIdKey(prevMarker.markerIdKey);
        newDashedPolyline.addPacket(prevMarker.packet);
        newDashedPolyline.addPacket(packet);
        this._map.markerCollection.setMarkerDashedPolyline(newMarkerIdKey, newDashedPolyline);
        prevMarker._relatedMarkerOriginDashedPolyLine = newDashedPolyline;
        this._map.addMarkerToMapSectorInterval(newMarkerIdKey, prevMarker.packet.getLatLngLiteral(), packet.getLatLngLiteral());
    }
};
trackdirect.MarkerCreator.prototype._convertLostMarkersToGhost = function (newPacket) {
    if (newPacket.packet_order_id != 2 && newPacket.hasConfirmedMapId() && newPacket.is_moving == 1 && this._map.markerCollection.isPacketReplacingMarker(newPacket) == false) {
        if (this._map.markerCollection.hasNonRelatedMovingMarkerId(newPacket)) {
            list = this._map.markerCollection.getStationMarkerIdKeys(newPacket.station_id);
            for (let markerIdKey in list) {
                let newMarkerIdKey = this._map.markerCollection.getMarkerIdKey(newPacket.marker_id);
                let marker = this._map.markerCollection.getMarker(markerIdKey);
                if (marker !== null && markerIdKey !== newMarkerIdKey && marker.packet.is_moving == 1 && marker.packet.timestamp <= newPacket.timestamp && marker.packet.hasConfirmedMapId() && marker.isSingleMovingMarker()) {
                    if (this._map.markerCollection.hasRelatedDashedPolyline(marker)) {
                        masterMarkerIdKey = this._map.markerCollection.getMarkerMasterMarkerKeyId(markerIdKey);
                        if (masterMarkerIdKey !== markerIdKey && this._map.markerCollection.isExistingMarker(masterMarkerIdKey) !== null) {
                            continue;
                        } else {
                            this._map.markerCollection.resetMarkerDashedPolyline(marker._relatedMarkerOriginDashedPolyLine.ownerMarkerIdKey);
                            marker._relatedMarkerOriginDashedPolyLine.hide();
                            marker._relatedMarkerOriginDashedPolyLine = null;
                        }
                    }
                    marker.packet.map_id = 9;
                    marker.setOpacity(0.5);
                    marker.hasLabel = false;
                    marker.hideLabel();
                    marker.stopDirectionPolyline();
                    if (!this._map.state.isGhostMarkersVisible) {
                        marker.hide();
                    }
                }
            }
        }
    }
};
trackdirect.MarkerCreator.prototype._getLatestStationMarkerToConnectTo = function (newPacket, newMarkerIdKey) {
    if (this._map.markerCollection.getStationLatestMovingMarkerIdKey(newPacket.station_id) === newMarkerIdKey) {
        return newMarkerIdKey;
    }
    let latestPrevMarkerIdKey = null;
    let latestPrevMarkerIdKeyTimestamp = null;
    let list = this._map.markerCollection.getStationMarkerIdKeys(newPacket.station_id);
    for (let markerIdKey in list) {
        let marker = this._map.markerCollection.getMarker(markerIdKey);
        if (marker !== null) {
            if (markerIdKey === newMarkerIdKey) {
                return markerIdKey;
            } else if (
                marker.packet.hasConfirmedMapId() &&
                marker.packet.is_moving == 1 &&
                marker.overwrite !== true &&
                marker.isSingleMovingMarker() == false &&
                (latestPrevMarkerIdKeyTimestamp === null || latestPrevMarkerIdKeyTimestamp < marker.packet.timestamp)
            ) {
                latestPrevMarkerIdKey = markerIdKey;
                latestPrevMarkerIdKeyTimestamp = marker.packet.timestamp;
            }
        }
    }
    return latestPrevMarkerIdKey;
};
trackdirect.MarkerCreator.prototype._connectToPreviousMarker = function (newPacket) {
    let newMarkerIdKey = this._map.markerCollection.getMarkerIdKey(newPacket.marker_id);
    if (newPacket.packet_order_id != 2 && newPacket.is_moving == 1 && this._map.markerCollection.isPacketReplacingMarker(newPacket) == false) {
        let latestPrevMarkerIdKey = this._getLatestStationMarkerToConnectTo(newPacket, newMarkerIdKey);
        let latestPrevMarker = this._map.markerCollection.getMarker(latestPrevMarkerIdKey);
        if (latestPrevMarker !== null) {
            if (newPacket.hasConfirmedMapId()) {
                latestPrevMarker.stopDirectionPolyline();
            }
            if (latestPrevMarkerIdKey == newMarkerIdKey) {
                if (this._map.markerCollection.hasDashedPolyline(latestPrevMarkerIdKey) && newPacket.hasConfirmedMapId()) {
                    let dashedPolyline = this._map.markerCollection.getMarkerDashedPolyline(latestPrevMarkerIdKey);
                    let latestPrevRelatedMarkerIdKey = dashedPolyline.relatedMarkerIdKey;
                    this._convertToDotMarker(latestPrevRelatedMarkerIdKey, newPacket);
                }
                this._convertToDotMarker(latestPrevMarkerIdKey, newPacket);
            } else {
                this._removeExistingRelatedMarkerOriginDashedPolyLine(latestPrevMarker, newMarkerIdKey);
                this._createMarkerOriginDashedPolyLine(latestPrevMarker, newPacket, newMarkerIdKey);
                if (newPacket.hasConfirmedMapId()) {
                    this._convertToDotMarker(latestPrevMarkerIdKey, newPacket);
                }
            }
        }
    }
};
trackdirect.MarkerCreator.prototype._createMarkerLabel = function (marker) {
    let position = marker.packet.getLatLngLiteral();
    if (this._map.markerCollection.hasMarkerLabel(marker.markerIdKey)) {
        this._map.markerCollection.setMarkerLabelPosition(marker.markerIdKey, position);
    } else if (marker.packet.packet_order_id == 1) {
        if (marker.packet.getOgnRegistration() != null) {
            labelText = marker.packet.getOgnRegistration();
            if (marker.packet.getOgnCN() !== null) {
                labelText += " [" + marker.packet.getOgnCN() + "]";
            }
        } else {
            if (marker.packet.station_name == marker.packet.sender_name) {
                labelText = escapeHtml(marker.packet.station_name);
            } else {
                labelText = escapeHtml(marker.packet.station_name) + ' <span style="font-weight: normal;">(' + escapeHtml(marker.packet.sender_name) + ")</span>";
            }
            if (marker.packet.comment) {
                let opIndex = marker.packet.comment.indexOf("OP:");
                if (opIndex > -1) {
                    opStr = marker.packet.comment.substring(opIndex + 3).replace(/^\s+/, "") + " ";
                    opStr = opStr.substring(0, opStr.indexOf(" "));
                    if (opStr.length <= 10 && opStr.length > 0) {
                        labelText += ' <span style="font-weight: normal;">[' + escapeHtml(opStr) + "]</span>";
                    }
                }
            }
        }
        let markerLabel = new trackdirect.models.Label({ position: position, text: labelText }, this._map);
        this._map.markerCollection.setMarkerLabel(marker.markerIdKey, markerLabel);
    }
};
trackdirect.MarkerCreator.prototype._extendTail = function (prevmarker, newmarker) {
    if (this._map.state.getClientTimestamp(newmarker.packet.timestamp) <= this._map.state.getOldestAllowedPacketTimestamp()) {
        return;
    }
    if (this._map.markerCollection.hasPolyline(newmarker.markerIdKey)) {
        let polyline = this._map.markerCollection.getMarkerPolyline(newmarker.markerIdKey);
        polyline.addMarker(newmarker);
    } else {
        if (this._map.state.getClientTimestamp(this._map.markerCollection.getMarker(newmarker.markerIdKey).packet.timestamp) <= this._map.state.getOldestAllowedPacketTimestamp()) {
        } else {
            let color = trackdirect.services.stationColorCalculator.getColor(newmarker.packet);
            let newTailPolyline = new trackdirect.models.TailPolyline(color, this._map);
            newTailPolyline.setMarkerIdKey(newmarker.markerIdKey);
            newTailPolyline.addMarker(prevmarker);
            newTailPolyline.addMarker(newmarker);
            this._map.markerCollection.setMarkerPolyline(newmarker.markerIdKey, newTailPolyline);
        }
    }
};
trackdirect.MarkerCreator.prototype._replaceTailMarker = function (markerIdKey) {
    if (this._map.markerCollection.hasPolyline(markerIdKey)) {
        let marker = this._map.markerCollection.getMarker(markerIdKey);
        let polylines = this._map.markerCollection.getMarkerPolyline(markerIdKey);
        let latestIndex = polylines.getPath().length - 1;
        if (latestIndex >= 0) {
            polylines.getPathItem(latestIndex).marker = marker;
        }
    }
};
trackdirect.MarkerCreator.prototype.isBadPacket = function (packet) {
    if (typeof packet.latitude === "undefined" || typeof packet.longitude === "undefined" || packet.marker_id == null) {
        return true;
    }
    let markerIdKey = this._map.markerCollection.getMarkerIdKey(packet.marker_id);
    if (this._map.markerCollection.isExistingMarker(markerIdKey)) {
        let marker = this._map.markerCollection.getMarker(markerIdKey);
        if (packet.packet_order_id == 1 && this._currentPacketSequenceStationId == packet.station_id) {
            return false;
        }
        if (packet.db == 0) {
            if (this._map.markerCollection.isDuplicate(packet)) {
                return true;
            }
        }
        if (packet.db == 1 && marker.packet.db == 1 && marker.packet.source === 0 && packet.id === marker.packet.id) {
            return true;
        }
        if (marker.overwrite == true && packet.overwrite == 0) {
            return false;
        } else {
            if (marker.packet.timestamp >= packet.timestamp) {
                return true;
            }
            if (marker.packet.reported_timestamp !== null && packet.reported_timestamp !== null && Math.abs(marker.packet.reported_timestamp - packet.reported_timestamp) < 600) {
                if (marker.packet.reported_timestamp > packet.reported_timestamp) {
                    return true;
                }
            }
        }
    }
    if (packet.is_moving == 1) {
        let list = this._map.markerCollection.getStationMarkerIdKeys(packet.station_id);
        for (let relatedMarkerIdKey in list) {
            let relatedMarker = this._map.markerCollection.getMarker(relatedMarkerIdKey);
            if (relatedMarker !== null && relatedMarker.overwrite == false && relatedMarker.packet.timestamp > packet.timestamp) {
                return true;
            }
        }
    }
    return false;
};
trackdirect.models.MarkerCollection = function () {
    this._markerKeys = {};
    this._markers = [];
    this._stationMarkers = {};
    this._stationLastMovingMarkerIdKey = {};
    this._stationLastMarker = {};
    this._senderLastMarker = {};
    this._positionMarkersIdKeys = {};
    this._dotMarkers = [];
    this._markerPolyLines = [];
    this._markerOriginDashedPolyLines = [];
    this._mapSectorMarkerIdKeys = {};
    this._stationCoverage = {};
    this.resetAllMarkers();
};
trackdirect.models.MarkerCollection.prototype.getMarkerIdKey = function (markerId) {
    if (!(markerId in this._markerKeys)) {
        this._markers.push(null);
        this._markerPolyLines.push(null);
        this._dotMarkers.push(null);
        this._markerOriginDashedPolyLines.push(null);
        let markerIdKey = this._markers.length - 1;
        this._markerKeys[markerId] = markerIdKey;
        return markerIdKey;
    } else {
        return this._markerKeys[markerId];
    }
};
trackdirect.models.MarkerCollection.prototype.isExistingMarker = function (markerIdKey) {
    if (markerIdKey in this._markers && this._markers[markerIdKey] !== null) {
        return true;
    }
    return false;
};
trackdirect.models.MarkerCollection.prototype.setMarker = function (markerIdKey, marker) {
    if (marker !== null && typeof marker.packet !== "undefined") {
        let packet = marker.packet;
        this._markers[markerIdKey] = marker;
        this._addStationMarkerId(markerIdKey, packet);
        this._addStationLastMarker(packet, marker);
        this.addPostionMarkerId(markerIdKey, packet);
    }
};
trackdirect.models.MarkerCollection.prototype.getMarker = function (markerIdKey) {
    if (markerIdKey !== null && markerIdKey in this._markers) {
        return this._markers[markerIdKey];
    }
    return null;
};
trackdirect.models.MarkerCollection.prototype.getAllMarkers = function () {
    return this._markers;
};
trackdirect.models.MarkerCollection.prototype.removeMarker = function (markerIdKey) {
    if (markerIdKey !== null && markerIdKey in this._markers) {
        this._markers.splice(markerIdKey, 1);
    }
};
trackdirect.models.MarkerCollection.prototype.getNumberOfMarkers = function () {
    return this._markers.length;
};
trackdirect.models.MarkerCollection.prototype.setMarkerLabel = function (markerIdKey, label) {
    if (markerIdKey in this._markers && this._markers[markerIdKey] !== null) {
        this._markers[markerIdKey].label = label;
    }
};
trackdirect.models.MarkerCollection.prototype.getMarkerLabel = function (markerIdKey) {
    if (markerIdKey in this._markers && this._markers[markerIdKey] !== null) {
        return this._markers[markerIdKey].label;
    }
    return null;
};
trackdirect.models.MarkerCollection.prototype.hasMarkerLabel = function (markerIdKey) {
    if (markerIdKey in this._markers && this._markers[markerIdKey] !== null && this._markers[markerIdKey].label !== null) {
        return true;
    }
    return false;
};
trackdirect.models.MarkerCollection.prototype.setMarkerLabelPosition = function (markerIdKey, position) {
    if (markerIdKey in this._markers && this._markers[markerIdKey] !== null && this._markers[markerIdKey].label !== null) {
        this._markers[markerIdKey].label.position = position;
    }
};
trackdirect.models.MarkerCollection.prototype.isDuplicate = function (packet) {
    if (packet.is_moving == 0) {
        return false;
    }
    for (let markerIdKey in this.getPositionMarkerIdKeys(packet.latitude, packet.longitude)) {
        let marker = this.getMarker(markerIdKey);
        if (marker !== null && marker.packet.station_id == packet.station_id && marker.packet.symbol == packet.symbol && marker.packet.symbol_table == packet.symbol_table && marker.packet.course == packet.course) {
            return true;
        }
    }
    return false;
};
trackdirect.models.MarkerCollection.prototype.addDotMarker = function (markerIdKey, dotMarker) {
    if (markerIdKey in this._dotMarkers) {
        if (this._dotMarkers[markerIdKey] === null) {
            this._dotMarkers[markerIdKey] = [];
        }
        this._dotMarkers[markerIdKey].push(dotMarker);
    }
};
trackdirect.models.MarkerCollection.prototype.getDotMarkers = function (markerIdKey) {
    if (markerIdKey in this._dotMarkers && this._dotMarkers[markerIdKey] !== null) {
        return this._dotMarkers[markerIdKey];
    }
    return [];
};
trackdirect.models.MarkerCollection.prototype.hasDotMarkers = function (markerIdKey) {
    if (markerIdKey in this._dotMarkers && this._dotMarkers[markerIdKey] !== null && this._dotMarkers[markerIdKey].length > 0) {
        return true;
    }
    return false;
};
trackdirect.models.MarkerCollection.prototype.addStationCoverage = function (stationId, stationCoveragePolygon) {
    this._stationCoverage[stationId] = stationCoveragePolygon;
};
trackdirect.models.MarkerCollection.prototype.getStationCoverage = function (stationId) {
    if (stationId in this._stationCoverage && this._stationCoverage[stationId] !== null) {
        return this._stationCoverage[stationId];
    }
    return null;
};
trackdirect.models.MarkerCollection.prototype.getStationIdListWithVisibleCoverage = function () {
    let result = [];
    for (let stationId in this._stationCoverage) {
        if (this._stationCoverage[stationId].isRequestedToBeVisible()) {
            result.push(stationId);
        }
    }
    return result;
};
trackdirect.models.MarkerCollection.prototype.hasCoveragePolygon = function (stationId) {
    if (stationId in this._stationCoverage && this._stationCoverage[stationId] !== null) {
        return true;
    }
    return false;
};
trackdirect.models.MarkerCollection.prototype.resetDotMarkers = function (markerIdKey) {
    if (markerIdKey in this._dotMarkers && this._dotMarkers[markerIdKey] !== null) {
        this._dotMarkers[markerIdKey] = [];
    }
};
trackdirect.models.MarkerCollection.prototype.removeOldestDotMarker = function (markerIdKey) {
    if (this.hasDotMarkers(markerIdKey)) {
        latestMarker = this.getMarker(markerIdKey);
        let latestMarkerIndex = this.getDotMarkerIndex(markerIdKey, latestMarker);
        let dotMarkers = this.getDotMarkers(markerIdKey);
        let maxNumberOfPolyLinePoints = dotMarkers.length;
        if (latestMarkerIndex > -1) {
            maxNumberOfPolyLinePoints = maxNumberOfPolyLinePoints - 1;
        }
        let removedItems = this._dotMarkers[markerIdKey].splice(0, 1);
        if (removedItems.length == 1) {
            let removedMarker = removedItems[0];
            removedMarker.hide();
            if (this.hasPolyline(removedMarker.markerIdKey)) {
                let polyline = this.getMarkerPolyline(removedMarker.markerIdKey);
                while (polyline.getPathLength() > maxNumberOfPolyLinePoints) {
                    polyline.removePathItem(0);
                }
            }
            removedMarker = null;
            return true;
        }
    }
    return false;
};
trackdirect.models.MarkerCollection.prototype.getDotMarkerIndex = function (markerIdKey, marker) {
    if (!this.hasDotMarkers(markerIdKey)) {
        return -1;
    }
    for (let i = 0, len = this._dotMarkers[markerIdKey].length; i < len; i++) {
        let foundMarker = this._dotMarkers[markerIdKey][i];
        if (foundMarker === null) {
            continue;
        }
        if (typeof marker.packet.id !== "undefined" && marker.packet.id !== null && foundMarker.packet.id === marker.packet.id && foundMarker.packet.map_id === marker.packet.map_id) {
            return i;
        }
        if (
            foundMarker.packet.station_id === marker.packet.station_id &&
            foundMarker.packet.timestamp === marker.packet.timestamp &&
            Math.round(foundMarker.packet.latitude * 100000) === Math.round(marker.packet.latitude * 100000) &&
            Math.round(foundMarker.packet.longitude * 100000) === Math.round(marker.packet.longitude * 100000) &&
            foundMarker.packet.map_id === marker.packet.map_id
        ) {
            return i;
        }
    }
    return -1;
};
trackdirect.models.MarkerCollection.prototype.setMarkerPolyline = function (markerIdKey, polyline) {
    if (markerIdKey in this._markerPolyLines) {
        this._markerPolyLines[markerIdKey] = polyline;
    }
};
trackdirect.models.MarkerCollection.prototype.getMarkerPolyline = function (markerIdKey) {
    if (this.hasPolyline(markerIdKey)) {
        return this._markerPolyLines[markerIdKey];
    }
    return null;
};
trackdirect.models.MarkerCollection.prototype.hasPolyline = function (markerIdKey) {
    if (markerIdKey in this._markerPolyLines && this._markerPolyLines[markerIdKey] !== null) {
        if (this._markerPolyLines[markerIdKey].getPathLength() > 1) {
            return true;
        } else {
            this._markerPolyLines[markerIdKey].hide();
            this._markerPolyLines[markerIdKey] = null;
            return false;
        }
    }
    return false;
};
trackdirect.models.MarkerCollection.prototype.resetMarkerPolyline = function (markerIdKey) {
    if (markerIdKey in this._markerPolyLines) {
        this._markerPolyLines[markerIdKey] = null;
    }
};
trackdirect.models.MarkerCollection.prototype.setMarkerDashedPolyline = function (markerIdKey, polyline) {
    if (markerIdKey in this._markerOriginDashedPolyLines) {
        this._markerOriginDashedPolyLines[markerIdKey] = polyline;
    }
};
trackdirect.models.MarkerCollection.prototype.getMarkerDashedPolyline = function (markerIdKey) {
    if (this.hasDashedPolyline(markerIdKey)) {
        return this._markerOriginDashedPolyLines[markerIdKey];
    }
    return null;
};
trackdirect.models.MarkerCollection.prototype.hasDashedPolyline = function (markerIdKey) {
    if (markerIdKey in this._markerOriginDashedPolyLines && this._markerOriginDashedPolyLines[markerIdKey] !== null) {
        if (this._markerOriginDashedPolyLines[markerIdKey].getPathLength() > 1) {
            return true;
        } else {
            this._markerOriginDashedPolyLines[markerIdKey].hide();
            this._markerOriginDashedPolyLines[markerIdKey] = null;
            return false;
        }
    }
    return false;
};
trackdirect.models.MarkerCollection.prototype.resetMarkerDashedPolyline = function (markerIdKey) {
    if (markerIdKey in this._markerOriginDashedPolyLines) {
        this._markerOriginDashedPolyLines[markerIdKey] = null;
    }
};
trackdirect.models.MarkerCollection.prototype.getStationLatestPacket = function (stationId) {
    if (typeof this._stationLastMarker[stationId] !== "undefined" && this._stationLastMarker[stationId] !== null && typeof this._stationLastMarker[stationId].packet !== "undefined") {
        return this._stationLastMarker[stationId].packet;
    } else {
        return null;
    }
};
trackdirect.models.MarkerCollection.prototype.getStationLatestMarker = function (stationId) {
    if (typeof this._stationLastMarker[stationId] !== "undefined" && this._stationLastMarker[stationId] !== null) {
        return this._stationLastMarker[stationId];
    } else {
        return null;
    }
};
trackdirect.models.MarkerCollection.prototype.getSenderLatestPacket = function (senderId) {
    if (typeof this._senderLastMarker[senderId] !== "undefined" && this._senderLastMarker[senderId] !== null && typeof this._senderLastMarker[senderId].packet !== "undefined") {
        return this._senderLastMarker[senderId].packet;
    } else {
        return null;
    }
};
trackdirect.models.MarkerCollection.prototype.getStationLatestMovingMarkerIdKey = function (stationId) {
    if (
        this._stationLastMovingMarkerIdKey !== null &&
        typeof this._stationLastMovingMarkerIdKey[stationId] !== "undefined" &&
        this._stationLastMovingMarkerIdKey[stationId] !== null &&
        this.isExistingMarker(this._stationLastMovingMarkerIdKey[stationId])
    ) {
        return this._stationLastMovingMarkerIdKey[stationId];
    }
    return null;
};
trackdirect.models.MarkerCollection.prototype.getMarkerMasterMarkerKeyId = function (markerIdKey) {
    if (this.isExistingMarker(markerIdKey)) {
        let marker = this._markers[markerIdKey];
        if (this.hasRelatedDashedPolyline(marker)) {
            return this.getMarkerMasterMarkerKeyId(marker._relatedMarkerOriginDashedPolyLine.ownerMarkerIdKey);
        }
    }
    return markerIdKey;
};
trackdirect.models.MarkerCollection.prototype.getStationLatestVisibleMarker = function (stationId) {
    let latestVisibleMarker = null;
    let latestVisibleMarkerTimestamp = null;
    for (let markerIdKey in this._stationMarkers[stationId]) {
        let marker = this._markers[markerIdKey];
        if (typeof marker !== "undefined" && marker !== null && typeof marker.getMap() !== "undefined" && marker.getMap() !== null) {
            if (latestVisibleMarkerTimestamp === null || marker.packet.timestamp > latestVisibleMarkerTimestamp) {
                latestVisibleMarker = marker;
                latestVisibleMarkerTimestamp = marker.packet.timestamp;
            }
        }
    }
    return latestVisibleMarker;
};
trackdirect.models.MarkerCollection.prototype.getStationMarkerIdKeys = function (stationId) {
    if (stationId in this._stationMarkers) {
        return this._stationMarkers[stationId];
    }
    return {};
};
trackdirect.models.MarkerCollection.prototype.getPositionMarkerIdKeys = function (latitude, longitude) {
    let key = this._getCompareablePosition(latitude, longitude);
    if (key in this._positionMarkersIdKeys) {
        return this._positionMarkersIdKeys[key];
    }
    return {};
};
trackdirect.models.MarkerCollection.prototype.addPostionMarkerId = function (markerIdKey, packet) {
    let key = this._getCompareablePosition(packet.latitude, packet.longitude);
    if (!(key in this._positionMarkersIdKeys)) {
        this._positionMarkersIdKeys[key] = {};
    }
    this._positionMarkersIdKeys[key][markerIdKey] = true;
};
trackdirect.models.MarkerCollection.prototype.removePostionMarkerId = function (latitude, longitude, markerIdKey) {
    let key = this._getCompareablePosition(latitude, longitude);
    if (key in this._positionMarkersIdKeys) {
        if (markerIdKey in this._positionMarkersIdKeys[key]) {
            this._positionMarkersIdKeys[key][markerIdKey] = false;
        }
    }
};
trackdirect.models.MarkerCollection.prototype.addMarkerToMapSector = function (markerIdKey, markerMapSector) {
    if (!(markerMapSector in this._mapSectorMarkerIdKeys)) {
        this._mapSectorMarkerIdKeys[markerMapSector] = [];
    }
    if (this._mapSectorMarkerIdKeys[markerMapSector].indexOf(markerIdKey) < 0) {
        this._mapSectorMarkerIdKeys[markerMapSector].push(markerIdKey);
    }
};
trackdirect.models.MarkerCollection.prototype.getMapSectorMarkerKeys = function (mapSector) {
    if (mapSector in this._mapSectorMarkerIdKeys) {
        return this._mapSectorMarkerIdKeys[mapSector];
    }
    return [];
};
trackdirect.models.MarkerCollection.prototype.resetAllMarkers = function () {
    this._markerKeys = {};
    this._markers = [];
    this._markerPolyLines = [];
    this._dotMarkers = [];
    this._markerOriginDashedPolyLines = [];
    this._stationMarkers = {};
    this._stationLastMovingMarkerIdKey = {};
    this._stationLastMarker = {};
    this._senderLastMarker = {};
    this._positionMarkersIdKeys = {};
    this._mapSectorMarkerIdKeys = {};
    this._stationCoverage = {};
};
trackdirect.models.MarkerCollection.prototype.resetMarker = function (markerIdKey) {
    if (this.isExistingMarker(markerIdKey)) {
        let marker = this._markers[markerIdKey];
        this._markers[markerIdKey] = null;
        this._markerPolyLines[markerIdKey] = null;
        this._dotMarkers[markerIdKey] = null;
        this._markerOriginDashedPolyLines[markerIdKey] = null;
        if (typeof marker.packet.latitude != "undefined" && typeof marker.packet.longitude != "undefined") {
            this.removePostionMarkerId(marker.packet.latitude, marker.packet.longitude, markerIdKey);
        }
    }
};
trackdirect.models.MarkerCollection.prototype.hasRelatedDashedPolyline = function (marker) {
    if (typeof marker._relatedMarkerOriginDashedPolyLine !== "undefined" && marker._relatedMarkerOriginDashedPolyLine !== null) {
        return true;
    }
    return false;
};
trackdirect.models.MarkerCollection.prototype.hasNonRelatedMovingMarkerId = function (packet) {
    let latestStationMovingMarkerIdKey = this.getStationLatestMovingMarkerIdKey(packet.station_id);
    let newMarkerIdKey = this.getMarkerIdKey(packet.marker_id);
    if (latestStationMovingMarkerIdKey !== null && latestStationMovingMarkerIdKey !== newMarkerIdKey) {
        let latestStationMovingMarker = this.getMarker(latestStationMovingMarkerIdKey);
        if (latestStationMovingMarker.packet.hasConfirmedMapId()) {
            return true;
        }
    }
    return false;
};
trackdirect.models.MarkerCollection.prototype.isPacketReplacingMarker = function (packet) {
    let markerIdKey = this.getMarkerIdKey(packet.marker_id);
    if (this.isExistingMarker(markerIdKey)) {
        let marker = this.getMarker(markerIdKey);
        if (marker !== null) {
            if (packet.map_id == 14) {
                return true;
            }
            if (packet.is_moving == 0) {
                return true;
            }
            if ([1, 2, 7, 12].indexOf(packet.map_id) < 0) {
                return true;
            }
        }
    }
    return false;
};
trackdirect.models.MarkerCollection.prototype._addStationMarkerId = function (markerIdKey, packet) {
    if (!(packet.station_id in this._stationMarkers)) {
        this._stationMarkers[packet.station_id] = {};
    }
    this._stationMarkers[packet.station_id][markerIdKey] = true;
    if (packet.is_moving == 1 && packet.hasConfirmedMapId()) {
        this._stationLastMovingMarkerIdKey[packet.station_id] = markerIdKey;
    }
};
trackdirect.models.MarkerCollection.prototype._addStationLastMarker = function (packet, marker) {
    if (packet.hasConfirmedMapId()) {
        if (typeof this._stationLastMarker[packet.station_id] === "undefined" || this._stationLastMarker[packet.station_id] === null) {
            this._stationLastMarker[packet.station_id] = marker;
            if (packet.station_name == packet.sender_name) {
                this._senderLastMarker[packet.sender_id] = marker;
            }
        } else if (this._stationLastMarker[packet.station_id].packet.timestamp <= packet.timestamp) {
            this._stationLastMarker[packet.station_id] = marker;
            if (packet.station_name == packet.sender_name) {
                this._senderLastMarker[packet.sender_id] = marker;
            }
        }
    }
};
trackdirect.models.MarkerCollection.prototype._getCompareablePosition = function (latitude, longitude) {
    let latCmp = Math.round(latitude * 100000);
    let lngCmp = Math.round(longitude * 100000);
    return String(latCmp) + ":" + String(lngCmp);
};
trackdirect.models.Marker = function (packet, isDotMarker, map) {
    this.packet = packet;
    this._isDotMarker = isDotMarker;
    this._defaultMap = map;
    if (typeof google === "object" && typeof google.maps === "object") {
        const options = this._getGoogleMarkerOptions();
        if (typeof options?.icon?.url === 'string' && options.icon.url.trim() !== '') {
            //const googleMarker = new google.maps.Marker(this._getGoogleMarkerOptions());
            const googleMarker = new google.maps.Marker(this._getGoogleMarkerOptions());

            Object.assign(this, googleMarker);
            Object.setPrototypeOf(this, trackdirect.models.Marker.prototype);
        } else {
            //None
//            console.log(this._getGoogleMarkerOptions());
            const markerOptions = this._getGoogleMarkerOptions();
            markerOptions.icon = {
                path: google.maps.SymbolPath.CIRCLE,  // 使用圓形作為圖示
                scale: 4,  // 控制點的大小 (數值越大，圓點越大)
                fillColor: "#FF0000",  // 紅色
                fillOpacity: 1,  // 完全不透明
                strokeWeight: 0  // 無邊框
            };
            const googleMarker = new google.maps.Marker(markerOptions);
            //const googleMarker = new google.maps.marker.AdvancedMarkerElement(markerOptions);

            Object.assign(this, googleMarker);
            Object.setPrototypeOf(this, trackdirect.models.Marker.prototype);
        }
    } else if (typeof L === "object") {
        L.Marker.call(this, this.packet.getLatLngLiteral(), this._getLeafletMarkerOptions());
    }
    this._init();
    if (typeof google === "object" && typeof google.maps === "object") {
        this.setMap(null);
    }
};
if (typeof google === "object" && typeof google.maps === "object") {
    trackdirect.models.Marker.prototype = Object.create(google.maps.Marker.prototype);
    //trackdirect.models.Marker.prototype = Object.create(google.maps.marker.AdvancedMarkerElement.prototype);
} else if (typeof L === "object") {
    trackdirect.models.Marker.prototype = Object.create(L.Marker.prototype);
}
trackdirect.models.Marker.prototype.constructor = trackdirect.models.Marker;
trackdirect.models.Marker.prototype._init = function () {
    this._tdEventListeners = {};
    this.hasLabel = false;
    this.showAsMarker = false;
    this.overwrite = false;
    this.markerIdKey = null;
    this.label = null;
    this.transmitPolyLine = null;
    this.directionPolyLine = null;
    this.phgCircle = null;
    this.rngCircle = null;
    this.hideTimerId = null;
    this.toOldTimerId = null;
    if (!this._isDotMarker) {
        this.showAsMarker = true;
        if (this.packet.map_id != 1 && this.packet.map_id != 2 && this.packet.map_id != 12) {
            this.setOpacity(0.5);
        } else {
            this.hasLabel = true;
        }
    }
    if (this._defaultMap.state.endTimeTravelTimestamp === null) {
        this._addMarkerToOldTimeout(0);
    }
    this._addMarkerTooltip();
};
trackdirect.models.Marker.prototype.addTdListener = function (event, handler) {
    if (!(event in this._tdEventListeners)) {
        this._tdEventListeners[event] = [];
    }
    this._tdEventListeners[event].push(handler);
};
trackdirect.models.Marker.prototype.isDotMarker = function () {
    return this._isDotMarker;
};
trackdirect.models.Marker.prototype.isVisible = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (typeof this.getMap() !== "undefined" && this.getMap() !== null) {
            return true;
        }
    } else if (typeof L === "object") {
        if (this._defaultMap.hasLayer(this)) {
            return true;
        }
    }
    return false;
};
trackdirect.models.Marker.prototype.getPositionLiteral = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        let latLng = this.getPosition();
        if (typeof latLng !== "undefined" && typeof latLng.lat === "function") {
            return { lat: latLng.lat(), lng: latLng.lng() };
        } else {
            return latLng;
        }
    } else if (typeof L === "object") {
        let latLng = this.getLatLng();
        if (typeof latLng !== "undefined") {
            return { lat: latLng.lat, lng: latLng.lng };
        } else {
            return latLng;
        }
    }
    return {};
};
trackdirect.models.Marker.prototype.show = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (typeof this.getMap() === "undefined" || this.getMap() === null) {
            this.setMap(this._defaultMap);
        }
    } else if (typeof L === "object") {
        if (!this._defaultMap.hasLayer(this)) {
            this.addTo(this._defaultMap);
        }
    }
    if (this.hideTimerId !== null) {
        clearTimeout(this.hideTimerId);
    }
    this._emitTdEventListeners("onshow");
};
trackdirect.models.Marker.prototype.hide = function (delayInMilliSeconds, onlyHideIfNeeded, hideOpenInfoWindow) {
    delayInMilliSeconds = typeof delayInMilliSeconds !== "undefined" ? delayInMilliSeconds : 0;
    onlyHideIfNeeded = typeof onlyHideIfNeeded !== "undefined" ? onlyHideIfNeeded : false;
    hideOpenInfoWindow = typeof hideOpenInfoWindow !== "undefined" ? hideOpenInfoWindow : true;
    if (delayInMilliSeconds > 0) {
        this._hideLater(delayInMilliSeconds, onlyHideIfNeeded);
        return;
    }
    if (onlyHideIfNeeded && this.shouldMarkerBeVisible()) {
        return;
    }
    if (hideOpenInfoWindow && this._defaultMap.state.isMarkerInfoWindowOpen(this)) {
        this._defaultMap.state.openInfoWindow.hide();
    }
    if (this.isVisible()) {
        if (typeof google === "object" && typeof google.maps === "object") {
            this.setMap(null);
        } else if (typeof L === "object") {
            this._defaultMap.removeLayer(this);
        }
    }
    if (this.showAsMarker) {
        this.hideLabel();
    }
    this.hidePHGCircle();
    this.hideRNGCircle();
    if (this.hideTimerId !== null) {
        clearTimeout(this.hideTimerId);
    }
    this._emitTdEventListeners("onhide");
};
trackdirect.models.Marker.prototype.getDefaultMap = function () {
    return this._defaultMap;
};
trackdirect.models.Marker.prototype.getMap = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        let map = google.maps.Marker.prototype.getMap.call(this);
        //let map = google.maps.marker.AdvancedMarkerElement.prototype.getMap.call(this);
        if (typeof map !== "undefined") {
            return map;
        }
    } else if (typeof L === "object") {
        if (this._defaultMap.hasLayer(this)) {
            return this._defaultMap;
        }
    }
    return null;
};
trackdirect.models.Marker.prototype.getState = function () {
    return this._defaultMap.state;
};
trackdirect.models.Marker.prototype.getZIndex = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        return this.zIndex;
    } else if (typeof L === "object") {
        return this.options.zIndexOffset;
    }
    return 0;
};
trackdirect.models.Marker.prototype.showCompleteMarker = function () {
    if (this._defaultMap.state.isFilterMode && this._defaultMap.state.filterStationIds.indexOf(this.packet.station_id) == -1) {
        return;
    }
    if (this.shouldMarkerBeVisible()) {
        if (this.showAsMarker) {
            this.show();
        }
        if (this._defaultMap.state.isFilterMode) {
            this.showMarkerPrevPosition();
            this.showMarkerTail();
            this.showLabel();
        } else {
            if (this._defaultMap.getZoom() >= trackdirect.settings.minZoomForMarkerPrevPosition) {
                this.showMarkerPrevPosition();
            }
            if (this._defaultMap.getZoom() >= trackdirect.settings.minZoomForMarkerTail) {
                this.showMarkerTail();
            }
            if (this._defaultMap.getZoom() >= trackdirect.settings.minZoomForMarkerLabel) {
                this.showLabel();
            }
        }
        if (this._defaultMap.state.showPHGCircles == 1) {
            this.showPHGCircle(true);
        } else if (this._defaultMap.state.showPHGCircles == 2) {
            this.showPHGCircle(false);
        }
        if (this._defaultMap.state.showRNGCircles == 1) {
            this._showRNGCircle(true);
        } else if (this._defaultMap.state.showRNGCircles == 2) {
            this._showRNGCircle(false);
        }
    }
};
trackdirect.models.Marker.prototype.hideCompleteMarker = function () {
    this.hide();
    this.hideMarkerPrevPosition();
    this.hideMarkerTail();
};
trackdirect.models.Marker.prototype.showMarkerDetails = function () {
    if (this._defaultMap.getZoom() >= trackdirect.settings.minZoomForMarkerPrevPosition) {
        this.showMarkerPrevPosition();
    }
    if (this._defaultMap.getZoom() >= trackdirect.settings.minZoomForMarkerTail) {
        this.showMarkerTail();
    }
    if (this._defaultMap.getZoom() >= trackdirect.settings.minZoomForMarkerLabel) {
        this.showLabel();
    }
};
trackdirect.models.Marker.prototype.hideMarkerDetails = function () {
    if (this._defaultMap.getZoom() < trackdirect.settings.minZoomForMarkerPrevPosition) {
        this.hideMarkerPrevPosition();
    }
    if (this._defaultMap.getZoom() < trackdirect.settings.minZoomForMarkerTail) {
        this.hideMarkerTail();
    }
    if (this._defaultMap.getZoom() < trackdirect.settings.minZoomForMarkerLabel) {
        this.hideLabel();
    }
};
trackdirect.models.Marker.prototype.showLabel = function () {
    if (!this._defaultMap.state.isFilterMode || this._defaultMap.state.filterStationIds.indexOf(this.packet.station_id) > -1) {
        if (
            this.isVisible() &&
            this.label !== null &&
            (this._defaultMap.getZoom() >= trackdirect.settings.minZoomForMarkerLabel || this._defaultMap.state.filterStationIds.indexOf(this.packet.station_id) > -1) &&
            this.hasLabel &&
            this.packet.hasConfirmedMapId()
        ) {
            this.label.show();
        }
    }
};
trackdirect.models.Marker.prototype.hideLabel = function () {
    if (this.label !== null && this.hasLabel) {
        this.label.hide();
    }
};
trackdirect.models.Marker.prototype.showMarkerPrevPosition = function () {
    if (this.shouldMarkerBeVisible() && this.packet.hasConfirmedMapId()) {
        let oldestAllowedPacketTimestamp = this._defaultMap.state.getOldestAllowedPacketTimestamp();
        let dotMarkers = this._defaultMap.markerCollection.getDotMarkers(this.markerIdKey);
        for (let i = 0; i < dotMarkers.length; i++) {
            let dotMarker = dotMarkers[i];
            if (this._defaultMap.state.getClientTimestamp(dotMarker.packet.timestamp) > oldestAllowedPacketTimestamp) {
                dotMarker.show();
            }
        }
        if (!this.showAsMarker) {
            this.show();
        }
    }
};
trackdirect.models.Marker.prototype.hideMarkerPrevPosition = function () {
    if (this.packet.hasConfirmedMapId()) {
        let dotMarkers = this._defaultMap.markerCollection.getDotMarkers(this.markerIdKey);
        for (let i = 0; i < dotMarkers.length; i++) {
            let dotMarker = dotMarkers[i];
            dotMarker.hide();
        }
        if (!this.showAsMarker) {
            this.hide();
        }
    }
};
trackdirect.models.Marker.prototype.showMarkerTail = function () {
    if (this.shouldMarkerBeVisible()) {
        if (this.packet.hasConfirmedMapId() === false && this._defaultMap.state.showGhostPosition) {
            this.show();
        }
        if (this._defaultMap.markerCollection.hasPolyline(this.markerIdKey) && this.packet.hasConfirmedMapId()) {
            let polyline = this._defaultMap.markerCollection.getMarkerPolyline(this.markerIdKey);
            while (this._defaultMap.state.getClientTimestamp(polyline.getPathItem(0).marker.packet.timestamp) < this._defaultMap.state.getOldestAllowedPacketTimestamp()) {
                let relatedMarker = polyline.getPathItem(0).marker;
                if (relatedMarker.getMap() === null) {
                    polyline.removePathItem(0);
                } else {
                    break;
                }
            }
            polyline.show();
        }
        let dashedPolyline = this._defaultMap.markerCollection.getMarkerDashedPolyline(this.markerIdKey);
        if (dashedPolyline !== null && this.packet.hasConfirmedMapId()) {
            let dashedPolyLineRelatedMarker = this._defaultMap.markerCollection.getMarker(dashedPolyline.relatedMarkerIdKey);
            if (this._defaultMap.state.getClientTimestamp(dashedPolyLineRelatedMarker.packet.timestamp) > this._defaultMap.state.getOldestAllowedPacketTimestamp()) {
                dashedPolyline.show();
                if (typeof dashedPolyline.relatedMarkerIdKey !== "undefined") {
                    let relatedMarker = this._defaultMap.markerCollection.getMarker(dashedPolyline.relatedMarkerIdKey);
                    if (relatedMarker !== null && relatedMarker.markerIdKey !== this.markerIdKey) {
                        relatedMarker.showMarkerTail();
                    }
                }
            }
        }
        if (this.directionPolyLine !== null) {
            this.directionPolyLine.show();
        }
    }
};
trackdirect.models.Marker.prototype.hideMarkerTail = function (markerIdKey) {
    let latestMarker = this._defaultMap.markerCollection.getStationLatestMarker(this.packet.station_id);
    if (this._defaultMap.state.isMarkerInfoWindowOpen(this) || this._defaultMap.state.isMarkerInfoWindowOpen(latestMarker)) {
        return;
    }
    if (this.packet.map_id != 1 && this.packet.map_id != 2 && this.packet.map_id != 12) {
        this.hide();
        if (this.showAsMarker) {
            this.hideLabel();
        }
    }
    let polyline = this._defaultMap.markerCollection.getMarkerPolyline(this.markerIdKey);
    if (polyline !== null) {
        if (this._defaultMap.state.isPolylineInfoWindowOpen(polyline)) {
            this._defaultMap.state.openInfoWindow.hide();
        }
        polyline.hide();
    }
    let dashedPolyline = this._defaultMap.markerCollection.getMarkerDashedPolyline(this.markerIdKey);
    if (dashedPolyline !== null) {
        dashedPolyline.hide();
        if (typeof dashedPolyline.relatedMarkerIdKey !== "undefined") {
            let relatedMarker = this._defaultMap.markerCollection.getMarker(dashedPolyline.relatedMarkerIdKey);
            if (relatedMarker !== null && relatedMarker.markerIdKey !== this.markerIdKey) {
                relatedMarker.hideMarkerTail();
            }
        }
    }
    if (this.directionPolyLine !== null) {
        this.directionPolyLine.hide();
    }
};
trackdirect.models.Marker.prototype.hideRNGCircle = function () {
    if (this.rngCircle !== null) {
        this.rngCircle.hide();
    }
};
trackdirect.models.Marker.prototype.showRNGCircle = function (isHalf) {
    this.hideRNGCircle();
    this.rngCircle = new trackdirect.models.RngCircle(this.packet, this._defaultMap, isHalf);
    this.rngCircle.show();
};
trackdirect.models.Marker.prototype.hidePHGCircle = function () {
    if (this.phgCircle !== null) {
        this.phgCircle.hide();
    }
};
trackdirect.models.Marker.prototype.showPHGCircle = function (isHalf) {
    this.hidePHGCircle();
    this.phgCircle = new trackdirect.models.PhgCircle(this.packet, this._defaultMap, isHalf);
    this.phgCircle.show();
};
trackdirect.models.Marker.prototype.markToBeOverWritten = function () {
    this.overwrite = true;
};
trackdirect.models.Marker.prototype.isSingleMovingMarker = function () {
    let markerCounter = 0;
    if (typeof this.packet.marker_counter !== "undefined" && this.packet.marker_counter !== null) {
        markerCounter = this.packet.marker_counter;
    }
    if (this.packet.position_timestamp == this.packet.timestamp && this.packet.is_moving == 1 && [1, 2, 7, 12].indexOf(this.packet.map_id) >= 0 && markerCounter <= 1 && !this._defaultMap.markerCollection.hasDotMarkers(this.markerIdKey)) {
        return true;
    }
    return false;
};
trackdirect.models.Marker.prototype.shouldMarkerBeVisible = function () {
    if (this.packet.map_id == 14) {
        return false;
    }
    if (this.packet.source_id == 2 && !this._defaultMap.state.isCwopMarkersVisible) {
        return false;
    }
    if (!this._defaultMap.state.isStationaryMarkersVisible) {
        if (!this.isMovingStation()) {
            return false;
        }
    }
    if (!this._defaultMap.state.isUnknownMarkersVisible) {
        if (this.packet.station_name.substring(0, 7) == "UNKNOWN") {
            return false;
        }
    }
    if (!this._defaultMap.state.isOgflymMarkersVisible) {
        if (this.packet.raw_path.indexOf("OGFLYM") >= 0) {
            return false;
        }
    }
    if (!this._defaultMap.state.isInternetMarkersVisible) {
        if (this.packet.raw_path.indexOf("TCPIP") >= 0 || this.packet.raw_path.indexOf("qAC") >= 0 || this.packet.raw_path.indexOf("qAX") >= 0 || this.packet.raw_path.indexOf("qAU") >= 0 || this.packet.raw_path.indexOf("qAS") >= 0) {
            if (this.packet.station_id_path.length == 0) {
                return false;
            }
        }
    }
    if (this._defaultMap.state.visibleSymbols.length > 0) {
        let symbolFound = false;
        for (let key in this._defaultMap.state.visibleSymbols) {
            let visibleSymbol = this._defaultMap.state.visibleSymbols[key];
            if (this.packet.symbol.charCodeAt(0) == visibleSymbol[0] && this.packet.symbol_table.charCodeAt(0) == visibleSymbol[1]) {
                symbolFound = true;
            }
        }
        if (!symbolFound) {
            return false;
        }
    }
    if (this.packet.map_id != 1 && this.packet.map_id != 2 && this.packet.map_id != 12 && !this._defaultMap.state.isGhostMarkersVisible) {
        return false;
    }
    if (this._defaultMap.state.isFilterMode && this._defaultMap.state.filterStationIds.indexOf(this.packet.station_id) > -1) {
        let latestStationMarker = this._defaultMap.markerCollection.getStationLatestMarker(this.packet.station_id);
        if (
            this._defaultMap.state.getClientTimestamp(this.packet.timestamp) <= this._defaultMap.state.getOldestAllowedPacketTimestamp() &&
            typeof latestStationMarker !== "undefined" &&
            latestStationMarker !== null &&
            !this._isMarkersEqual(latestStationMarker)
        ) {
            return false;
        }
        return true;
    } else {
        if (this._defaultMap.state.isFilterMode && this._defaultMap.state.filterStationIds.indexOf(this.packet.station_id) === -1) {
            return false;
        }
        if (this.packet.map_id != 1 && this.packet.map_id != 2 && this.packet.map_id != 12 && this._defaultMap.getZoom() < trackdirect.settings.minZoomForMarkerTail) {
            return false;
        }
        if (this._defaultMap.state.getClientTimestamp(this.packet.timestamp) <= this._defaultMap.state.getOldestAllowedPacketTimestamp()) {
            return false;
        }
        if (this._defaultMap.getZoom() < trackdirect.settings.minZoomForMarkers) {
            return false;
        }
        return true;
    }
};
trackdirect.models.Marker.prototype.isMovingStation = function () {
    if (this.packet.is_moving == 0) {
        return false;
    }
    if (this._defaultMap.state.getClientTimestamp(this.packet.position_timestamp) < this._defaultMap.state.getOldestAllowedPacketTimestamp()) {
        let stationLatestMovingMarkerIdKey = this._defaultMap.markerCollection.getStationLatestMovingMarkerIdKey(this.packet.station_id);
        if (stationLatestMovingMarkerIdKey == this.markerIdKey) {
            return false;
        }
    }
    return true;
};
trackdirect.models.Marker.prototype.stopDirectionPolyline = function () {
    if (this.directionPolyLine !== null) {
        this.directionPolyLine.stop();
    }
};
trackdirect.models.Marker.prototype.stopToOldTimeout = function () {
    clearTimeout(this.toOldTimerId);
    let dotMarkers = this._defaultMap.markerCollection.getDotMarkers(this.markerIdKey);
    for (let j = 0; j < dotMarkers.length; j++) {
        clearTimeout(dotMarkers[j].toOldTimerId);
    }
};
trackdirect.models.Marker.prototype.getToolTipContent = function () {
    let iconUrl = trackdirect.services.symbolPathFinder.getFilePath(this.packet.symbol_table, this.packet.symbol, null, null, null, 20, 20);
    let date = new Date(this.packet.timestamp * 1000);
    let positionDate = new Date(this.packet.position_timestamp * 1000);
    let dateString = moment(date).format(trackdirect.settings.dateFormatNoTimeZone);
    if (this.packet.timestamp > this.packet.position_timestamp) {
        dateString = moment(positionDate).format(trackdirect.settings.dateFormatNoTimeZone) + " - " + moment(date).format(trackdirect.settings.dateFormatNoTimeZone);
    }
    if (this.packet.getOgnRegistration() != null) {
        let name = escapeHtml(this.packet.station_name);
        name += ", ";
        name += escapeHtml(this.packet.getOgnRegistration());
        if (this.packet.getOgnCN() !== null) {
            name += " [" + escapeHtml(this.packet.getOgnCN()) + "]";
        }
        return (
            '<div><img style="float: left; width:20px; height:20px;" src="' +
            iconUrl +
            '" />' +
            '<span style="font-weight: bold; font-family: Helvetica; font-size: 10px; line-height: 22px; margin-left: 5px; margin-right: 25px">' +
            name +
            "</span></div>" +
            '<div style="clear:both; font-family: Helvetica; font-size: 9px;">' +
            dateString +
            "</div>"
        );
    } else if (this.packet.station_name == this.packet.sender_name) {
        return (
            '<div><img style="float: left; width:20px; height:20px;" src="' +
            iconUrl +
            '" />' +
            '<span style="font-weight: bold; font-family: Helvetica; font-size: 10px; line-height: 22px; margin-left: 5px; margin-right: 25px">' +
            escapeHtml(this.packet.station_name) +
            "</span></div>" +
            '<div style="clear:both; font-family: Helvetica; font-size: 9px;">' +
            dateString +
            "</div>"
        );
    } else {
        return (
            '<div><img style="float: left; width:20px; height:20px;" src="' +
            iconUrl +
            '" />' +
            '<span style="font-weight: bold; font-family: Helvetica; font-size: 10px; line-height: 22px; margin-left: 5px; margin-right: 25px">' +
            escapeHtml(this.packet.station_name) +
            "</span></div>" +
            '<div style="clear:both; font-family: Helvetica; font-size: 9px;">Sent by ' +
            escapeHtml(this.packet.sender_name) +
            "</div>" +
            '<div style="clear:both; font-family: Helvetica; font-size: 9px;">' +
            dateString +
            "</div>"
        );
    }
};
trackdirect.models.Marker.prototype._getGoogleMarkerOptions = function () {
    let anchorPoint;
    let scaledImageSize;
    let imageSize;
    let imageAnchor;
    let opacity;
    let iconUrl;
    if (this._isDotMarker) {
        let colorId = trackdirect.services.stationColorCalculator.getColorId(this.packet);
        let iconUrl = trackdirect.settings.baseUrl + trackdirect.settings.imagesBaseDir + "dotColor" + colorId + ".png";
        scaledImageSize = new google.maps.Size(12, 12);
        imageSize = new google.maps.Size(12, 12);
        imageAnchor = new google.maps.Point(6, 6);
        opacity = 1.0;
    } else {
        let scalePx = 24;
        let sizePx = 24;
        if (this._shouldMarkerSymbolBeScaled()) {
            scalePx = 48;
        }
        if (this.packet.course !== null) {
            sizePx = sizePx + 7;
            if (scalePx < sizePx) {
                scalePx = sizePx;
            }
        }
        imageSize = new google.maps.Size(scalePx, scalePx);
        imageAnchor = new google.maps.Point(Math.floor(scalePx / 2), Math.floor(scalePx / 2));
        scaledImageSize = new google.maps.Size(scalePx, scalePx);
        iconUrl = trackdirect.services.symbolPathFinder.getFilePath(this.packet.symbol_table, this.packet.symbol, this.packet.course, sizePx, sizePx, scalePx, scalePx);
        if (isHighDensity()) {
            imageSize = new google.maps.Size(scalePx * 2, scalePx * 2);
            anchorPoint = new google.maps.Point(0, -Math.floor(scalePx / 2));
            iconUrl = trackdirect.services.symbolPathFinder.getFilePath(this.packet.symbol_table, this.packet.symbol, this.packet.course, sizePx, sizePx, scalePx * 2, scalePx * 2);
        }
        opacity = 1.0;
    }
    return {
        position: this.packet.getLatLngLiteral(),
        zIndex: this._defaultMap.state.currentMarkerZindex,
        icon: { url: iconUrl, size: imageSize, scaledSize: scaledImageSize, origin: new google.maps.Point(0, 0), anchor: imageAnchor },
        opacity: opacity,
        anchorPoint: anchorPoint,
    };
};
trackdirect.models.Marker.prototype._getLeafletMarkerOptions = function () {
    let icon;
    let opacity;
    if (this._isDotMarker) {
        let colorId = trackdirect.services.stationColorCalculator.getColorId(this.packet);
        let iconUrl = trackdirect.settings.baseUrl + trackdirect.settings.imagesBaseDir + "dotColor" + colorId + ".png";
        icon = L.icon({ iconUrl: iconUrl, iconSize: [12, 12], iconAnchor: [6, 6] });
        opacity = 0.8;
    } else {
        let scalePx = 24;
        let sizePx = 24;
        if (this._shouldMarkerSymbolBeScaled()) {
            scalePx = 48;
        }
        if (this.packet.course !== null) {
            sizePx = sizePx + 7;
            if (scalePx < sizePx) {
                scalePx = sizePx;
            }
        }
        let iconUrl = trackdirect.services.symbolPathFinder.getFilePath(this.packet.symbol_table, this.packet.symbol, this.packet.course, sizePx, sizePx, scalePx, scalePx);
        let iconRetinaUrl = trackdirect.services.symbolPathFinder.getFilePath(this.packet.symbol_table, this.packet.symbol, this.packet.course, sizePx, sizePx, scalePx * 2, scalePx * 2);
        icon = L.icon({ iconUrl: iconUrl, iconRetinaUrl: iconRetinaUrl, iconSize: [scalePx, scalePx], iconAnchor: [Math.floor(scalePx / 2), Math.floor(scalePx / 2)] });
        opacity = 1.0;
    }
    let tooltipTitle = "";
    if (typeof L.tooltip == "undefined") {
        tooltipTitle = this.packet.station_name;
    }
    return { zIndexOffset: this._defaultMap.state.currentMarkerZindex, icon: icon, opacity: opacity, title: tooltipTitle };
};
trackdirect.models.Marker.prototype._shouldMarkerSymbolBeScaled = function () {
    if (typeof trackdirect.settings.symbolsToScale === "undefined") {
        return false;
    }
    for (let i = 0; i < trackdirect.settings.symbolsToScale.length; i++) {
        let symbol = trackdirect.settings.symbolsToScale[i][0];
        let symbolTable = trackdirect.settings.symbolsToScale[i][1];
        if (symbolTable == null && this.packet.symbol.charCodeAt() == symbol) {
            return true;
        } else if (this.packet.symbol.charCodeAt() == symbol && this.packet.symbol_table.charCodeAt() == symbolTable) {
            return true;
        }
    }
    return false;
};
trackdirect.models.Marker.prototype._hideLater = function (delayInMilliSeconds, onlyHideIfNeeded) {
    let me = this;
    this.hideTimerId = window.setTimeout(function () {
        if (me._defaultMap.state.isMarkerInfoWindowOpen(me)) {
            me.hide(500);
        } else {
            if (!me.shouldMarkerBeVisible()) {
                me.hide(0, onlyHideIfNeeded);
            }
        }
    }, delayInMilliSeconds);
};
trackdirect.models.Marker.prototype._addMarkerTooltip = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        this._addMarkerGoogleMapTooltip();
    } else if (typeof L === "object") {
        this._addMarkerLeafletMapTooltip();
    }
};
trackdirect.models.Marker.prototype._addMarkerLeafletMapTooltip = function () {
    if (!trackdirect.isMobile) {
        let tooltip;
        if (typeof L.tooltip != "undefined") {
            tooltip = L.tooltip({ direction: "right", noWrap: true, offset: [6, 30], className: "leaflet-marker-tooltiptext" });
        }
        let me = this;
        let isMyTooltipVisible = false;
        this.on("mouseover", function (e) {
            if (typeof tooltip !== "undefined") {
                tooltip.setContent(me.getToolTipContent());
                tooltip.setLatLng(new L.LatLng(me.packet.latitude, me.packet.longitude));
                tooltip.addTo(me._defaultMap);
                isMyTooltipVisible = true;
            }
            if (me.transmitPolyLine == null) {
                me.transmitPolyLine = new trackdirect.models.TransmitPolyline(me.packet, me._defaultMap);
            }
            me.transmitPolyLine.show();
        });
        this.on("mouseout", function (e) {
            if (me.transmitPolyLine != null && me.transmitPolyLine.isVisible()) {
                me.transmitPolyLine.hide(2000);
            }
            if (typeof tooltip !== "undefined" && isMyTooltipVisible && me._defaultMap.hasLayer(tooltip)) {
                tooltip.remove();
                isMyTooltipVisible = false;
            }
        });
        this.on("remove", function (e) {
            if (me.transmitPolyLine != null && me.transmitPolyLine.isVisible()) {
                me.transmitPolyLine.hide(0);
            }
            if (typeof tooltip !== "undefined" && isMyTooltipVisible && me._defaultMap.hasLayer(tooltip)) {
                tooltip.remove();
                isMyTooltipVisible = false;
            }
        });
    }
};
trackdirect.models.Marker.prototype._addMarkerGoogleMapTooltip = function () {
    if (!trackdirect.isMobile) {
        if (!$("#marker-tooltip").length) {
            let tooltip = $(document.createElement("div"));
            tooltip.attr("id", "marker-tooltip");
            tooltip.css("display", "none");
            tooltip.css("position", "absolute");
            tooltip.css("margin", "15px");
            tooltip.css("z-index", "90");
            tooltip.css("padding", "3px");
            tooltip.css("opacity", "0.95");
            tooltip.css("filter", "alpha(opacity=95)");
            tooltip.css("-webkit-border-radius", "1px");
            tooltip.css("-moz-border-radius", "1px");
            tooltip.css("border-radius", "1px");
            tooltip.css("-webkit-box-shadow", "0px 0px 3px 0px rgba(0,0,0,0.3)");
            tooltip.css("-moz-box-shadow", "0px 0px 3px 0px rgba(0,0,0,0.3)");
            tooltip.css("box-shadow", "0px 0px 3px 0px rgba(0,0,0,0.3)");
            tooltip.css("background-color", "#fff");
            tooltip.css("background", "#ffffff");
            $("body").append(tooltip);
        }
        let me = this;
        let isMyTooltipVisible = false;
        google.maps.event.addListener(this, "mouseover", function () {
            let point = this._fromGoogleLatLngToPoint(me.getPosition());
            let mapElementId = this._defaultMap.getMapElementId();
            $("#marker-tooltip")
                .html(me.getToolTipContent())
                .css({ left: point.x + $("#" + mapElementId).offset().left, top: point.y + $("#" + mapElementId).offset().top })
                .show();
            isMyTooltipVisible = true;
            if (me.transmitPolyLine == null) {
                me.transmitPolyLine = new trackdirect.models.TransmitPolyline(me.packet, me._defaultMap);
            }
            me.transmitPolyLine.show();
        });
        google.maps.event.addListener(this, "mouseout", function () {
            if (me.transmitPolyLine != null && me.transmitPolyLine.isVisible()) {
                me.transmitPolyLine.hide(2000);
            }
            if (isMyTooltipVisible) {
                $("#marker-tooltip").hide();
                isMyTooltipVisible = false;
            }
        });
        this.addTdListener("onhide", function () {
            if (me.transmitPolyLine != null && me.transmitPolyLine.isVisible()) {
                me.transmitPolyLine.hide(0);
            }
            if (isMyTooltipVisible) {
                $("#marker-tooltip").hide();
                isMyTooltipVisible = false;
            }
        });
    }
};
trackdirect.models.Marker.prototype._fromGoogleLatLngToPoint = function (latLng) {
    let topRight = this._defaultMap.getProjection().fromLatLngToPoint(this._defaultMap.getBounds().getNorthEast());
    let bottomLeft = this._defaultMap.getProjection().fromLatLngToPoint(this._defaultMap.getBounds().getSouthWest());
    let scale = Math.pow(2, this._defaultMap.getZoom());
    let worldPoint = this._defaultMap.getProjection().fromLatLngToPoint(latLng);
    return new google.maps.Point((worldPoint.x - bottomLeft.x) * scale, (worldPoint.y - topRight.y) * scale);
};
trackdirect.models.Marker.prototype._isMarkersEqual = function (marker2) {
    let marker1 = this;
    if (
        typeof marker2 !== "undefined" &&
        marker2 !== null &&
        typeof marker1.packet !== "undefined" &&
        typeof marker2.packet !== "undefined" &&
        marker1.packet.station_id === marker2.packet.station_id &&
        marker1.packet.timestamp === marker2.packet.timestamp &&
        Math.round(marker1.packet.latitude * 100000) === Math.round(marker2.packet.latitude * 100000) &&
        Math.round(marker1.packet.longitude * 100000) === Math.round(marker2.packet.longitude * 100000) &&
        marker1.packet.map_id === marker2.packet.map_id
    ) {
        return true;
    } else {
        return false;
    }
};
(trackdirect.models.Marker.prototype._addMarkerToOldTimeout = function (altDelayMilliSeconds) {
    let markerCollection = this._defaultMap.markerCollection;
    let state = this._defaultMap.state;
    let delay = (this._defaultMap.state.getClientTimestamp(this.packet.timestamp) - state.getOldestAllowedPacketTimestamp()) * 1000;
    if (altDelayMilliSeconds !== 0) {
        delay = altDelayMilliSeconds;
    }
    if (delay < 0) {
        delay = 10;
    }
    if (typeof this.toOldTimerId !== "undefined" && this.toOldTimerId !== null) {
        clearTimeout(this.toOldTimerId);
    }
    let me = this;
    this.toOldTimerId = window.setTimeout(function () {
        if (me._defaultMap.state.isMarkerInfoWindowOpen(me)) {
            me._addMarkerToOldTimeout(500);
        } else {
            let latestStationMarker = markerCollection.getStationLatestMarker(me.packet.station_id);
            let latestMarker = markerCollection.getMarker(me.markerIdKey);
            if (!me._isMarkersEqual(latestStationMarker) || state.filterStationIds.indexOf(me.packet.station_id) == -1) {
                if (latestMarker === me) {
                    let callback = function () {
                        me.hideCompleteMarker();
                        markerCollection.resetMarkerPolyline(me.markerIdKey);
                        markerCollection.resetDotMarkers(me.markerIdKey);
                    };
                    trackdirect.services.callbackExecutor.add(me, callback, []);
                } else if (markerCollection.hasDotMarkers(me.markerIdKey)) {
                    let index = markerCollection.getDotMarkerIndex(me.markerIdKey, me);
                    if (index == 0) {
                        let callback = function () {
                            if (markerCollection.hasDotMarkers(me.markerIdKey)) {
                                let success = markerCollection.removeOldestDotMarker(me.markerIdKey);
                                if (!success) {
                                    me._addMarkerToOldTimeout(500);
                                }
                            }
                        };
                        trackdirect.services.callbackExecutor.add(me, callback, []);
                    } else if (index > 0) {
                        let dotMarkers = markerCollection.getDotMarkers(me.markerIdKey);
                        dotMarkers[0]._addMarkerToOldTimeout(0);
                        me._addMarkerToOldTimeout(100);
                    }
                }
            } else {
                me._addMarkerToOldTimeout(1000);
            }
        }
    }, delay);
}),
    (trackdirect.models.Marker.prototype._emitTdEventListeners = function (event, arg) {
        if (event in this._tdEventListeners) {
            for (let i = 0; i < this._tdEventListeners[event].length; i++) {
                this._tdEventListeners[event][i](arg);
            }
        }
    });
trackdirect.models.MapState = function () {
    this._init();
};
trackdirect.models.MapState.prototype._init = function () {
    this.isFilterMode = false;
    this.filterStationIds = [];
    this.isGhostMarkersVisible = false;
    this.isCwopMarkersVisible = true;
    this.isStationaryMarkersVisible = true;
    this.isInternetMarkersVisible = true;
    this.isUnknownMarkersVisible = true;
    this.isOgflymMarkersVisible = true;
    this.visibleSymbols = [];
    this.useImperialUnit = false;
    this.showPHGCircles = 0;
    this.showRNGCircles = 0;
    this.trackStationId = null;
    this.onlyTrackRecentPackets = false;
    this.timeLengthInSeconds = 3600;
    this.endTimeTravelTimestamp = null;
    this.currentMarkerZindex = 200;
    this.serverClientTimestampDiff = 0;
    this.openInfoWindow = null;
    this.openInfoWindowForMarkerIdKey = null;
};
trackdirect.models.MapState.prototype.getOldestAllowedPacketTimestamp = function () {
    let oldestAllowedTimestamp = Math.floor(Date.now() / 1000) - this.timeLengthInSeconds;
    if (this.endTimeTravelTimestamp !== null) {
        oldestAllowedTimestamp = this.endTimeTravelTimestamp - this.timeLengthInSeconds;
    }
    return oldestAllowedTimestamp;
};
trackdirect.models.MapState.prototype.setTimeLength = function (seconds) {
    this.timeLengthInSeconds = seconds;
};
trackdirect.models.MapState.prototype.getTimeLength = function () {
    return this.timeLengthInSeconds;
};
trackdirect.models.MapState.prototype.getClientTimestamp = function (serverTimestamp) {
    return serverTimestamp - this.serverClientTimestampDiff;
};
trackdirect.models.MapState.prototype.setServerCurrentTimestamp = function (serverTimestamp) {
    this.serverClientTimestampDiff = serverTimestamp - Math.floor(Date.now() / 1000);
};
trackdirect.models.MapState.prototype.isInfoWindowOpen = function () {
    if (this.openInfoWindow === null) {
        return false;
    }
    return this.openInfoWindow.isInfoWindowOpen();
};
trackdirect.models.MapState.prototype.isMarkerInfoWindowOpen = function (marker) {
    if (!this.isInfoWindowOpen()) {
        return false;
    }
    if (this.openInfoWindow.getPolyline() !== null) {
        return false;
    }
    if (this.openInfoWindow.getMarker() === marker) {
        return true;
    }
    return false;
};
trackdirect.models.MapState.prototype.isPolylineInfoWindowOpen = function (polyline) {
    if (!this.isInfoWindowOpen()) {
        return false;
    }
    if (this.openInfoWindow.getPolyline() === null) {
        return false;
    }
    if (this.openInfoWindow.getPolyline() === polyline) {
        return true;
    }
    return false;
};
trackdirect.models.MapState.prototype.getFilterStationIds = function () {
    return this.filterStationIds;
};
trackdirect.models.MapState.prototype.getTrackStationId = function () {
    return this.trackStationId;
};
trackdirect.models.Map = function (mapElementId, options) {
    this._init(mapElementId, options);
    if (typeof google === "object" && typeof google.maps === "object") {
        const googleMap = new google.maps.Map(document.getElementById(mapElementId), this._getGoogleMapOptions());
        for (const key of Object.keys(this)) {
            googleMap[key] = this[key];
        }
        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {
            if (key !== "constructor" && typeof this[key] === "function") {
                googleMap[key] = this[key];
            }
        }
        googleMap._initMap();
        return googleMap;
    } else if (typeof L === "object") {
        L.Map.call(this, document.getElementById(mapElementId), this._getLeafletMapOptions());
        this._updateLeafletTileLayer();
        L.control.zoom({ position: "bottomright" }).addTo(this);
        this._initMap();
    }
};
if (typeof google === "object" && typeof google.maps === "object") {
    trackdirect.models.Map.prototype = Object.create(google.maps.Map.prototype);
} else if (typeof L === "object") {
    trackdirect.models.Map.prototype = Object.create(L.Map.prototype);
}
trackdirect.models.Map.prototype.constructor = trackdirect.models.Map;
trackdirect.models.Map.prototype._init = function (mapElementId, options) {
    this._mapElementId = mapElementId;
    this._tdMapOptions = options;
    this._initBasic();
    this._initMapTypes();
};
trackdirect.models.Map.prototype._initBasic = function () {
    this._tdEventListeners = {};
    this._tdEventTimeout = null;
    this._currentContentZoom = null;
    this._visibleMapSectors = [];
    this._newMarkersToShow = [];
    this._leafletTileLayer = null;
    this._heatMap = null;
    this.markerCollection = new trackdirect.models.MarkerCollection();
    this.state = new trackdirect.models.MapState();
};
trackdirect.models.Map.prototype._initMapTypes = function () {
    this._supportedMapTypes = {};
    if (typeof this._tdMapOptions.supportedMapTypes !== "undefined" && this._tdMapOptions.supportedMapTypes !== null && Object.keys(this._tdMapOptions.supportedMapTypes).length > 0) {
        this._supportedMapTypes = this._tdMapOptions.supportedMapTypes;
    } else if (typeof google === "object" && typeof google.maps === "object") {
        this._supportedMapTypes["roadmap"] = google.maps.MapTypeId.ROADMAP;
        this._supportedMapTypes["terrain"] = google.maps.MapTypeId.TERRAIN;
        this._supportedMapTypes["satellite"] = google.maps.MapTypeId.SATELLITE;
        this._supportedMapTypes["hybrid"] = google.maps.MapTypeId.HYBRID;
    } else if (typeof L === "object") {
        this._supportedMapTypes["roadmap"] = "OpenStreetMap.Mapnik";
        this._supportedMapTypes["terrain"] = "OpenTopoMap";
    }
    if (typeof this._tdMapOptions.maptype !== "undefined" && this._tdMapOptions.maptype !== null && this._tdMapOptions.maptype in this._supportedMapTypes) {
        this._mapType = this._tdMapOptions.maptype;
    } else {
        this._mapType = Object.keys(this._supportedMapTypes)[0];
    }
};
trackdirect.models.Map.prototype._initMap = function () {
    this._heatMap = new trackdirect.models.HeatMap(this);
    this._setMapInitialLocation();
    this._initOms();
    this._initInfoWindowEvent();
    this._updateMapContent();
    this._initMapEvents();
    if (typeof google === "object" && typeof google.maps === "object") {
        if (typeof this._tdMapOptions.mid !== "undefined") {
            let kmlUrl = "https://www.google.com/maps/d/u/0/kml?mid=" + this._tdMapOptions.mid;
            let kmlLayer = new google.maps.KmlLayer(kmlUrl, { map: this });
        }
    }
};
trackdirect.models.Map.prototype.triggerResize = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        google.maps.event.trigger(this, "resize");
    } else if (typeof L === "object") {
        L.Map.prototype._onResize.call(this);
    }
};
trackdirect.models.Map.prototype.setCenter = function (pos, zoom) {
    if (typeof google === "object" && typeof google.maps === "object") {
        google.maps.Map.prototype.setCenter.call(this, pos);
        if (typeof zoom !== "undefined") {
            google.maps.Map.prototype.setZoom.call(this, zoom);
        }
    } else if (typeof L === "object") {
        zoom = typeof zoom !== "undefined" ? zoom : this.getZoom();
        L.Map.prototype.setView.call(this, pos, zoom);
    }
    this._renderCoordinatesContainer(pos);
};
trackdirect.models.Map.prototype.getCenterLiteral = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        let latLng = google.maps.Map.prototype.getCenter.call(this);
        if (typeof latLng !== "undefined" && typeof latLng.lat === "function") {
            return { lat: latLng.lat(), lng: latLng.lng() };
        } else {
            return latLng;
        }
    } else if (typeof L === "object") {
        let latLng = L.Map.prototype.getCenter.call(this);
        if (typeof latLng !== "undefined") {
            return { lat: latLng.lat, lng: latLng.lng };
        } else {
            return latLng;
        }
    }
    return null;
};
trackdirect.models.Map.prototype.fitBounds = function (bounds) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let latLngBounds = new google.maps.LatLngBounds();
        for (let i = 0; i < bounds.length; i++) {
            latLngBounds.extend(bounds[i]);
        }
        google.maps.Map.prototype.fitBounds.call(this, latLngBounds);
    } else if (typeof L === "object") {
        L.Map.prototype.fitBounds.call(this, bounds);
    }
};
trackdirect.models.Map.prototype.setCenterByStationId = function (stationId) {
    let latestVisibleMarker = this.markerCollection.getStationLatestVisibleMarker(stationId);
    if (latestVisibleMarker !== null) {
        this.setCenter(latestVisibleMarker.packet.getLatLngLiteral());
    }
};
trackdirect.models.Map.prototype.getMapElementId = function () {
    return this._mapElementId;
};
trackdirect.models.Map.prototype.getTdMapOptions = function () {
    return this._tdMapOptions;
};
trackdirect.models.Map.prototype.isMapSectorVisible = function (mapSector) {
    if (this._visibleMapSectors.indexOf(mapSector) >= 0 || this.state.isFilterMode) {
        return true;
    }
    return false;
};
trackdirect.models.Map.prototype.getNumberOfNewMarkersToShow = function () {
    return this._newMarkersToShow;
};
trackdirect.models.Map.prototype.showNewMarkersInQueue = function (track) {
    track = typeof track !== "undefined" ? track : true;
    let oldestAllowedTrackingTimestamp = 0;
    if (this.state.onlyTrackRecentPackets) {
        oldestAllowedTrackingTimestamp = Math.floor(Date.now() / 1000) - 60;
    }
    while ((markerIdKey = this._newMarkersToShow.pop()) != null) {
        if (!this.markerCollection.isExistingMarker(markerIdKey)) {
            continue;
        }
        let marker = this.markerCollection.getMarker(markerIdKey);
        trackdirect.services.callbackExecutor.addWithPriority(marker, marker.showCompleteMarker, []);
        if (track && marker.packet.packet_order_id == 1) {
            if (
                marker.shouldMarkerBeVisible() &&
                marker.showAsMarker &&
                this.state.trackStationId !== null &&
                this.state.trackStationId == marker.packet.station_id &&
                this.state.getClientTimestamp(marker.packet.timestamp) > oldestAllowedTrackingTimestamp
            ) {
                trackdirect.services.callbackExecutor.addWithPriority(this, this.setCenterByStationId, [marker.packet.station_id]);
            }
        }
        if (this.state.openInfoWindowForMarkerIdKey !== null && this.state.openInfoWindowForMarkerIdKey == markerIdKey && marker.packet.packet_order_id == 1 && marker.shouldMarkerBeVisible() && marker.showAsMarker) {
            trackdirect.services.callbackExecutor.addWithPriority(this, this.openLatestStationInfoWindow, [marker.packet.station_id]);
        }
    }
    this.state.openInfoWindowForMarkerIdKey = null;
};
trackdirect.models.Map.prototype.activateFilteredMode = function () {
    this.state.isFilterMode = true;
    this._deactivateHeatMap();
    this._updateMapContent();
};
trackdirect.models.Map.prototype.deactivateFilteredMode = function () {
    if (this.state.isFilterMode) {
        this._activateHeatMap();
        this.state.isFilterMode = false;
        this.state.filterStationIds = [];
        this._updateMapContent();
    }
};
trackdirect.models.Map.prototype.getNorthEastLat = function () {
    if (this.getBounds() != null) {
        if (typeof google === "object" && typeof google.maps === "object") {
            return this.getBounds().getNorthEast().lat();
        } else if (typeof L === "object") {
            return this.getBounds().getNorthEast().lat;
        }
    }
    return 0;
};
trackdirect.models.Map.prototype.getNorthEastLng = function () {
    if (this.getBounds() != null) {
        if (typeof google === "object" && typeof google.maps === "object") {
            return this.getBounds().getNorthEast().lng();
        } else if (typeof L === "object") {
            return this.getBounds().getNorthEast().lng;
        }
    }
    return 0;
};
trackdirect.models.Map.prototype.getSouthWestLat = function () {
    if (this.getBounds() != null) {
        if (typeof google === "object" && typeof google.maps === "object") {
            return this.getBounds().getSouthWest().lat();
        } else if (typeof L === "object") {
            return this.getBounds().getSouthWest().lat;
        }
    }
    return 0;
};
trackdirect.models.Map.prototype.getSouthWestLng = function () {
    if (this.getBounds() != null) {
        if (typeof google === "object" && typeof google.maps === "object") {
            return this.getBounds().getSouthWest().lng();
        } else if (typeof L === "object") {
            return this.getBounds().getSouthWest().lng;
        }
    }
    return 0;
};
trackdirect.models.Map.prototype.isMapReady = function () {
    if (this.getBounds() != null) {
        return true;
    }
    return false;
};
trackdirect.models.Map.prototype.setMapType = function (mapType) {
    if (mapType in this._supportedMapTypes) {
        this._mapType = mapType;
        if (typeof google === "object" && typeof google.maps === "object") {
            this._updateGoogleMapTileLayer();
        } else if (typeof L === "object") {
            this._updateLeafletTileLayer();
        }
        this._emitTdEventListeners("change");
    }
};
trackdirect.models.Map.prototype.getMapType = function () {
    return this._mapType;
};
trackdirect.models.Map.prototype.getLeafletTileLayer = function () {
    return this._leafletTileLayer;
};
trackdirect.models.Map.prototype.getMid = function () {
    if (typeof this._tdMapOptions.mid !== "undefined") {
        return this._tdMapOptions.mid;
    }
    return null;
};
trackdirect.models.Map.prototype.resetAllMarkers = function () {
    while (this.markerCollection.getNumberOfMarkers() > 0) {
        let i = this.markerCollection.getNumberOfMarkers();
        while (i--) {
            let marker = this.markerCollection.getMarker(i);
            if (marker !== null) {
                marker.stopToOldTimeout();
                marker.stopDirectionPolyline();
                marker.hide();
                marker.hideMarkerPrevPosition();
                marker.hideMarkerTail();
                let stationCoverage = this.markerCollection.getStationCoverage(marker.packet.station_id);
                if (stationCoverage) {
                    stationCoverage.hide();
                }
            }
            this.markerCollection.removeMarker(i);
        }
    }
    if (this.state.openInfoWindow !== null) {
        this.state.openInfoWindow.hide();
    }
    if (this.oms) {
        this.oms.clearMarkers();
    }
    this.markerCollection.resetAllMarkers();
};
trackdirect.models.Map.prototype.openMarkerInfoWindow = function (marker, disableAutoPan) {
    disableAutoPan = typeof disableAutoPan !== "undefined" ? disableAutoPan : true;
    if (marker.getMap() !== null) {
        if (this.state.openInfoWindow !== null && this.state.openInfoWindow.getMarker().packet.id != marker.packet.id) {
            this.state.openInfoWindow.hide();
        }
        if (this.state.openInfoWindow !== null && this.state.openInfoWindow.getMarker().packet.id == marker.packet.id) {
            this.state.openInfoWindow.setMarker(marker);
        } else {
            this.state.openInfoWindow = new trackdirect.models.InfoWindow(marker, this, disableAutoPan);
        }
        this._addInfoWindowListeners(this.state.openInfoWindow);
        this.state.openInfoWindow.show();
    }
};
trackdirect.models.Map.prototype.openLatestStationInfoWindow = function (stationId) {
    let latestVisibleMarker = this.markerCollection.getStationLatestVisibleMarker(stationId);
    if (latestVisibleMarker !== null) {
        this.openMarkerInfoWindow(latestVisibleMarker);
    }
};
trackdirect.models.Map.prototype.openPolylineInfoWindow = function (marker, position) {
    if (this.state.openInfoWindow !== null) {
        this.state.openInfoWindow.hide();
    }
    this.state.openInfoWindow = new trackdirect.models.InfoWindow(marker, this);
    this._addInfoWindowListeners(this.state.openInfoWindow);
    this.state.openInfoWindow.show(true, position);
};
trackdirect.models.Map.prototype._addInfoWindowListeners = function (infoWindow) {
    let me = this;
    infoWindow.addTdListener("station-tail-needed", function (stationId) {
        me._emitTdEventListeners("station-tail-needed", stationId);
    });
};
(trackdirect.models.Map.prototype.addTdListener = function (event, handler) {
    if (!(event in this._tdEventListeners)) {
        this._tdEventListeners[event] = [];
    }
    this._tdEventListeners[event].push(handler);
}),
    (trackdirect.models.Map.prototype._emitTdEventListeners = function (event, arg) {
        if (event in this._tdEventListeners) {
            for (let i = 0; i < this._tdEventListeners[event].length; i++) {
                this._tdEventListeners[event][i](arg);
            }
        }
    });
(trackdirect.models.Map.prototype._triggerMapChangeEvent = function () {
    if (this._tdEventTimeout != null) {
        clearTimeout(this._tdEventTimeout);
    }
    let me = this;
    this._tdEventTimeout = window.setTimeout(function () {
        me._emitTdEventListeners("change");
        me._tdEventTimeout = null;
    }, 5);
}),
    (trackdirect.models.Map.prototype._deactivateHeatMap = function () {
        if (typeof google === "object" && typeof google.maps === "object") {
            if (typeof this.overlayMapTypes !== "undefined" && this.overlayMapTypes.length > 0) {
                this.overlayMapTypes.clear();
            }
        } else if (typeof L === "object") {
            if (this._heatMap !== null) {
                this.removeLayer(this._heatMap);
            }
        }
    });
trackdirect.models.Map.prototype._activateHeatMap = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (typeof this.overlayMapTypes !== "undefined" && this.overlayMapTypes.length == 0) {
            this.overlayMapTypes.setAt(0, this._heatMap);
        }
    } else if (typeof L === "object") {
        if (this._heatMap !== null) {
            this._heatMap.addTo(this);
            this._heatMap.bringToFront();
            this._heatMap.setZIndex(1000);
        }
    }
};
trackdirect.models.Map.prototype._updateGoogleMapTileLayer = function () {
    this.setMapTypeId(this._supportedMapTypes[this._mapType]);
};
trackdirect.models.Map.prototype._updateLeafletTileLayer = function () {
    if (typeof windyInit !== "function") {
        if (this._leafletTileLayer !== null) {
            this._leafletTileLayer.remove();
        }
        if (typeof L.mapboxGL === "function") {
            let attribution = "";
            let accessToken = "no-token";
            let style = "";
            if ("mapboxGLStyle" in this._tdMapOptions) {
                style = this._tdMapOptions["mapboxGLStyle"];
            }
            if ("mapboxGLAccessToken" in this._tdMapOptions) {
                accessToken = this._tdMapOptions["mapboxGLAccessToken"];
            }
            if ("mapboxGLAttribution" in this._tdMapOptions) {
                attribution = this._tdMapOptions["mapboxGLAttribution"];
            }
            this._leafletTileLayer = L.mapboxGL({ accessToken: accessToken, style: style });
            this.addLayer(this._leafletTileLayer);
            this.attributionControl.addAttribution(attribution);
        } else {
            let options = {};
            if (isHighDensity()) {
                options["ppi"] = "320";
                options["size"] = "512";
            } else if (trackdirect.isMobile) {
                options["ppi"] = "250";
            }
            this._leafletTileLayer = L.tileLayer.provider(this._supportedMapTypes[this._mapType], options);
            this.addLayer(this._leafletTileLayer);
            this._leafletTileLayer.bringToBack();
        }
    }
};
trackdirect.models.Map.prototype._updateMapContent = function () {
    if (this.getBounds() != null) {
        let previousVisibleMapSectors = [];
        for (let i = 0; i < this._visibleMapSectors.length; i++) {
            previousVisibleMapSectors.push(this._visibleMapSectors[i]);
        }
        this._visibleMapSectors = trackdirect.services.MapSectorCalculator.getMapSectors(this.getBounds());
        this._triggerMapChangeEvent();
        if (!this.state.isFilterMode) {
            if (this.getZoom() < trackdirect.settings.minZoomForMarkers) {
                this.hideAllMarkers();
                this._activateHeatMap();
            } else {
                this._deactivateHeatMap();
                this._hideMarkersInPreviousVisibleMapSectors(previousVisibleMapSectors);
                this._showMarkersInNewVisibleMapSectors(previousVisibleMapSectors);
                if (this._isAnyMarkerDetailsVisible()) {
                    this._showVisibleMarkerDetails();
                }
                if (this._isAnyMarkerDetailsHidden()) {
                    this._hideVisibleMarkerDetails();
                }
            }
        }
    }
    this._currentContentZoom = this.getZoom();
};
trackdirect.models.Map.prototype._isAnyMarkerDetailsVisible = function () {
    let showPrevPosition = this.getZoom() >= trackdirect.settings.minZoomForMarkerPrevPosition && this._currentContentZoom < trackdirect.settings.minZoomForMarkerPrevPosition;
    let showMarkerTail = this.getZoom() >= trackdirect.settings.minZoomForMarkerTail && this._currentContentZoom < trackdirect.settings.minZoomForMarkerTail;
    let showMarkerLabel = this.getZoom() >= trackdirect.settings.minZoomForMarkerLabel && this._currentContentZoom < trackdirect.settings.minZoomForMarkerLabel;
    if (showPrevPosition || showMarkerTail || showMarkerLabel) {
        return true;
    }
    return false;
};
trackdirect.models.Map.prototype._isAnyMarkerDetailsHidden = function () {
    let hidePrevPosition = this.getZoom() < trackdirect.settings.minZoomForMarkerPrevPosition && this._currentContentZoom >= trackdirect.settings.minZoomForMarkerPrevPosition;
    let hideMarkerTail = this.getZoom() < trackdirect.settings.minZoomForMarkerTail && this._currentContentZoom >= trackdirect.settings.minZoomForMarkerTail;
    let hideMarkerLabel = this.getZoom() < trackdirect.settings.minZoomForMarkerLabel && this._currentContentZoom >= trackdirect.settings.minZoomForMarkerLabel;
    if (hidePrevPosition || hideMarkerTail || hideMarkerLabel) {
        return true;
    }
    return false;
};
trackdirect.models.Map.prototype._showVisibleMarkerDetails = function () {
    for (let i = 0; i < this._visibleMapSectors.length; i++) {
        let mapSector = this._visibleMapSectors[i];
        let mapSectorMarkerKeys = this.markerCollection.getMapSectorMarkerKeys(mapSector);
        for (let j = 0; j < mapSectorMarkerKeys.length; j++) {
            let markerIdKey = mapSectorMarkerKeys[j];
            let marker = this.markerCollection.getMarker(markerIdKey);
            if (marker === null) {
                continue;
            }
            trackdirect.services.callbackExecutor.addWithPriority(marker, marker.showMarkerDetails, []);
        }
    }
};
trackdirect.models.Map.prototype._hideVisibleMarkerDetails = function () {
    for (let i = 0; i < this._visibleMapSectors.length; i++) {
        let mapSector = this._visibleMapSectors[i];
        let mapSectorMarkerKeys = this.markerCollection.getMapSectorMarkerKeys(mapSector);
        for (let j = 0; j < mapSectorMarkerKeys.length; j++) {
            let markerIdKey = mapSectorMarkerKeys[j];
            let marker = this.markerCollection.getMarker(markerIdKey);
            if (marker === null) {
                continue;
            }
            trackdirect.services.callbackExecutor.addWithPriority(marker, marker.hideMarkerDetails, []);
        }
    }
};
trackdirect.models.Map.prototype.showHideMarkers = function () {
    if (this.oms) {
        this.oms.unspiderfy();
    }
    if (this.state.isFilterMode) {
        for (let markerIdKey in this.markerCollection.getAllMarkers()) {
            if (this.markerCollection.isExistingMarker(markerIdKey)) {
                let marker = this.markerCollection.getMarker(markerIdKey);
                if (marker) {
                    if (marker.shouldMarkerBeVisible()) {
                        marker.showCompleteMarker();
                    } else {
                        marker.hideCompleteMarker();
                    }
                }
                if (marker.packet) {
                    this.showTopLabelOnPosition(marker.packet.latitude, marker.packet.longitude);
                }
            }
        }
    } else {
        for (let i = 0; i < this._visibleMapSectors.length; i++) {
            let mapSector = this._visibleMapSectors[i];
            let mapSectorMarkerKeys = this.markerCollection.getMapSectorMarkerKeys(mapSector);
            for (let j = 0; j < mapSectorMarkerKeys.length; j++) {
                let markerIdKey = mapSectorMarkerKeys[j];
                if (this.markerCollection.isExistingMarker(markerIdKey)) {
                    let marker = this.markerCollection.getMarker(markerIdKey);
                    if (marker.shouldMarkerBeVisible()) {
                        marker.showCompleteMarker();
                    } else {
                        marker.hideCompleteMarker();
                    }
                    this.showTopLabelOnPosition(marker.packet.latitude, marker.packet.longitude);
                }
            }
        }
    }
};
trackdirect.models.Map.prototype.showHidePHGCircles = function () {
    if (this.getZoom() >= trackdirect.settings.minZoomForMarkers) {
        if (this.state.isFilterMode) {
            for (let markerIdKey in this.markerCollection.getAllMarkers()) {
                if (this.markerCollection.isExistingMarker(markerIdKey)) {
                    let marker = this.markerCollection.getMarker(markerIdKey);
                    if (marker.showAsMarker && marker.packet.phg != null && marker.getMap() !== null && marker.shouldMarkerBeVisible()) {
                        if (this.state.showPHGCircles == 0) {
                            marker.hidePHGCircle();
                        } else if (this.state.showPHGCircles == 1) {
                            marker.showPHGCircle(true);
                        } else if (this.state.showPHGCircles == 2) {
                            marker.showPHGCircle(false);
                        }
                    }
                }
            }
        } else {
            for (let i = 0; i < this._visibleMapSectors.length; i++) {
                let mapSector = this._visibleMapSectors[i];
                let mapSectorMarkerKeys = this.markerCollection.getMapSectorMarkerKeys(mapSector);
                for (let j = 0; j < mapSectorMarkerKeys.length; j++) {
                    let markerIdKey = mapSectorMarkerKeys[j];
                    if (this.markerCollection.isExistingMarker(markerIdKey)) {
                        let marker = this.markerCollection.getMarker(markerIdKey);
                        if (marker.showAsMarker && marker.packet.phg != null && marker.getMap() !== null && marker.shouldMarkerBeVisible()) {
                            if (this.state.showPHGCircles == 0) {
                                marker.hidePHGCircle();
                            } else if (this.state.showPHGCircles == 1) {
                                marker.showPHGCircle(true);
                            } else if (this.state.showPHGCircles == 2) {
                                marker.showPHGCircle(false);
                            }
                        }
                    }
                }
            }
        }
    }
};
trackdirect.models.Map.prototype.showHideRNGCircles = function () {
    if (this.getZoom() >= trackdirect.settings.minZoomForMarkers) {
        if (this.state.isFilterMode) {
            for (let markerIdKey in this.markerCollection.getAllMarkers()) {
                if (this.markerCollection.isExistingMarker(markerIdKey)) {
                    let marker = this.markerCollection.getMarker(markerIdKey);
                    if (marker.showAsMarker && marker.packet.rng != null && marker.getMap() !== null && marker.shouldMarkerBeVisible()) {
                        if (this.state.showRNGCircles == 0) {
                            marker.hideRNGCircle();
                        } else if (this.state.showRNGCircles == 1) {
                            marker.showRNGCircle(true);
                        } else if (this.state.showRNGCircles == 2) {
                            marker.showRNGCircle(false);
                        }
                    }
                }
            }
        } else {
            for (let i = 0; i < this._visibleMapSectors.length; i++) {
                let mapSector = this._visibleMapSectors[i];
                let mapSectorMarkerKeys = this.markerCollection.getMapSectorMarkerKeys(mapSector);
                for (let j = 0; j < mapSectorMarkerKeys.length; j++) {
                    let markerIdKey = mapSectorMarkerKeys[j];
                    if (this.markerCollection.isExistingMarker(markerIdKey)) {
                        let marker = this.markerCollection.getMarker(markerIdKey);
                        if (marker.showAsMarker && marker.packet.rng != null && marker.getMap() !== null && marker.shouldMarkerBeVisible()) {
                            if (this.state.showRNGCircles == 0) {
                                marker.hideRNGCircle();
                            } else if (this.state.showRNGCircles == 1) {
                                marker.showRNGCircle(true);
                            } else if (this.state.showRNGCircles == 2) {
                                marker.showRNGCircle(false);
                            }
                        }
                    }
                }
            }
        }
    }
};
trackdirect.models.Map.prototype.hideAllMarkers = function () {
    for (let markerIdKey in this.markerCollection.getAllMarkers()) {
        let marker = this.markerCollection.getMarker(markerIdKey);
        if (marker !== null) {
            marker.hideCompleteMarker();
        }
    }
};
trackdirect.models.Map.prototype.showTopLabelOnPosition = function (latitude, longitude) {
    let topMarkerIdKey = -1;
    let topMarkerZindex = 0;
    if (Object.keys(this.markerCollection.getPositionMarkerIdKeys(latitude, longitude)).length > 1) {
        for (let markerIdKey in this.markerCollection.getPositionMarkerIdKeys(latitude, longitude)) {
            let marker = this.markerCollection.getMarker(markerIdKey);
            if (marker !== null && marker.shouldMarkerBeVisible()) {
                if (marker.getZIndex() > topMarkerZindex) {
                    topMarkerZindex = marker.getZIndex();
                    topMarkerIdKey = markerIdKey;
                }
                marker.hideLabel();
                marker.hasLabel = false;
            }
        }
        if (topMarkerIdKey != -1) {
            let topMarker = this.markerCollection.getMarker(topMarkerIdKey);
            topMarker.hasLabel = true;
            let topMarkerMapSector = trackdirect.services.MapSectorCalculator.getMapSector(topMarker.getPositionLiteral().lat, topMarker.getPositionLiteral().lng);
            if (this.state.isFilterMode) {
                topMarker.showLabel();
            } else if (this.isMapSectorVisible(topMarkerMapSector) && this.getZoom() >= trackdirect.settings.minZoomForMarkerLabel) {
                topMarker.showLabel();
            }
        }
    }
};
trackdirect.models.Map.prototype._hideMarkersInPreviousVisibleMapSectors = function (previousVisibleMapSectors) {
    if (this._currentContentZoom >= trackdirect.settings.minZoomForMarkers) {
        let markerIdKeyListToMaybeHide = {};
        let markerIdKeyListNotToHide = {};
        for (let i = 0; i < previousVisibleMapSectors.length; i++) {
            let mapSector = previousVisibleMapSectors[i];
            if (!this.isMapSectorVisible(mapSector) || this.getZoom() < trackdirect.settings.minZoomForMarkers) {
                let mapSectorMarkerKeys = this.markerCollection.getMapSectorMarkerKeys(mapSector);
                for (let j = 0; j < mapSectorMarkerKeys.length; j++) {
                    let markerIdKey = mapSectorMarkerKeys[j];
                    markerIdKeyListToMaybeHide[markerIdKey] = markerIdKey;
                }
            } else if (this.getZoom() >= trackdirect.settings.minZoomForMarkers) {
                let mapSectorMarkerKeys = this.markerCollection.getMapSectorMarkerKeys(mapSector);
                for (let j = 0; j < mapSectorMarkerKeys.length; j++) {
                    let markerIdKey = mapSectorMarkerKeys[j];
                    markerIdKeyListNotToHide[markerIdKey] = markerIdKey;
                }
            }
        }
        for (let markerIdKey in markerIdKeyListToMaybeHide) {
            if (markerIdKey in markerIdKeyListNotToHide) {
                continue;
            }
            let marker = this.markerCollection.getMarker(markerIdKey);
            if (marker !== null) {
                trackdirect.services.callbackExecutor.addWithPriority(marker, marker.hideCompleteMarker, []);
            }
        }
    }
};
trackdirect.models.Map.prototype._showMarkersInNewVisibleMapSectors = function (previousVisibleMapSectors) {
    if (this.getZoom() >= trackdirect.settings.minZoomForMarkers) {
        for (let i = 0; i < this._visibleMapSectors.length; i++) {
            let mapSector = this._visibleMapSectors[i];
            if (previousVisibleMapSectors.indexOf(mapSector) == -1 || this._currentContentZoom < trackdirect.settings.minZoomForMarkers) {
                let mapSectorMarkerKeys = this.markerCollection.getMapSectorMarkerKeys(mapSector);
                for (let j = 0; j < mapSectorMarkerKeys.length; j++) {
                    let markerIdKey = mapSectorMarkerKeys[j];
                    let marker = this.markerCollection.getMarker(markerIdKey);
                    if (marker !== null) {
                        trackdirect.services.callbackExecutor.addWithPriority(marker, marker.showCompleteMarker, []);
                    }
                }
            }
        }
        let stationIdList = this.markerCollection.getStationIdListWithVisibleCoverage();
        for (let i = 0; i < stationIdList.length; i++) {
            let latestMarker = this.markerCollection.getStationLatestMarker(stationIdList[i]);
            if (latestMarker !== null) {
                if (latestMarker.shouldMarkerBeVisible() && latestMarker.showAsMarker) {
                    latestMarker.show();
                }
            }
        }
    }
};
trackdirect.models.Map.prototype._setMapInitialLocation = function () {
    let zoom = this._getInitialZoom();
    if (typeof this._tdMapOptions.initCenter !== "undefined" && this._tdMapOptions.initCenter !== null) {
        let pos = this._tdMapOptions.initCenter;
        this.setCenter(pos, zoom);
    } else {
        this.setMapDefaultLocation();
        this.setZoom(zoom);
    }
    this._emitTdEventListeners("change");
};
trackdirect.models.Map.prototype.setMapDefaultLocation = function (setDefaultZoom) {
    setDefaultZoom = typeof setDefaultZoom !== "undefined" ? setDefaultZoom : false;
    let defaultLatitude = typeof this._tdMapOptions.defaultLatitude !== "undefined" ? this._tdMapOptions.defaultLatitude : 59.35;
    let defaultLongitude = typeof this._tdMapOptions.defaultLongitude !== "undefined" ? this._tdMapOptions.defaultLongitude : 18.05;
    let pos = { lat: parseFloat(defaultLatitude), lng: parseFloat(defaultLongitude) };
    if (setDefaultZoom) {
        if (trackdirect.isMobile) {
            this.setCenter(pos, trackdirect.settings.defaultCurrentZoomMobile);
        } else {
            this.setCenter(pos, trackdirect.settings.defaultCurrentZoom);
        }
    } else {
        this.setCenter(pos);
    }
};
trackdirect.models.Map.prototype.addMarkerToMapSectorInterval = function (markerIdKey, startLatLng, endLatLng) {
    let minLat = startLatLng.lat;
    let maxLat = endLatLng.lat;
    let minLng = startLatLng.lng;
    let maxLng = endLatLng.lng;
    if (endLatLng.lat < minLat) {
        minLat = endLatLng.lat;
        maxLat = startLatLng.lat;
    }
    if (endLatLng.lng < minLng) {
        minLng = endLatLng.lng;
        maxLng = startLatLng.lng;
    }
    for (let lat = Math.floor(minLat); lat <= Math.ceil(maxLat); lat++) {
        for (let lng = Math.floor(minLng); lng <= Math.ceil(maxLng); lng++) {
            let markerMapSector = trackdirect.services.MapSectorCalculator.getMapSector(lat, lng);
            this.markerCollection.addMarkerToMapSector(markerIdKey, markerMapSector);
            if (this.isMapSectorVisible(markerMapSector)) {
                if (this._newMarkersToShow.indexOf(markerIdKey) < 0) {
                    this._newMarkersToShow.push(markerIdKey);
                }
            }
        }
    }
};
trackdirect.models.Map.prototype.addMarkerToMapSectors = function (markerIdKey, packet, tryToShowPacket) {
    let markerMapSectors = [];
    markerMapSectors.push(packet.map_sector);
    if (typeof packet.related_map_sectors !== "undefined" && packet.related_map_sectors !== null) {
        for (let i = 0; i < packet.related_map_sectors.length; i++) {
            markerMapSectors.push(packet.related_map_sectors[i]);
        }
    }
    for (let i = 0; i < markerMapSectors.length; i++) {
        let markerMapSector = markerMapSectors[i];
        this.markerCollection.addMarkerToMapSector(markerIdKey, markerMapSector);
        if (tryToShowPacket) {
            if (this.isMapSectorVisible(markerMapSector)) {
                if (this._newMarkersToShow.indexOf(markerIdKey) < 0) {
                    this._newMarkersToShow.push(markerIdKey);
                }
            }
        }
    }
};
trackdirect.models.Map.prototype._initMapEvents = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        this._initGoogleMapEvents();
    } else if (typeof L === "object") {
        this._initLeafletMapEvents();
    }
};
trackdirect.models.Map.prototype._initGoogleMapEvents = function () {
    let me = this;
    google.maps.event.addListener(this, "mousemove", function (event) {
        me._renderCoordinatesContainer(event.latLng);
    });
    google.maps.event.addListener(this, "idle", function () {
        me._updateMapContent();
    });
    google.maps.event.addListener(this, "maptypeid_changed", function () {
        me._updateMapContent();
    });
    google.maps.event.addListener(this, "bounds_changed", function () {
        if (me.isMapReady()) {
            me._emitTdEventListeners("moving");
        }
    });
};
trackdirect.models.Map.prototype._initLeafletMapEvents = function () {
    let me = this;
    this.on("mousemove", function (event) {
        me._renderCoordinatesContainer(event.latlng);
    });
    this.on("moveend", function () {
        me._updateMapContent();
    });
    this.on("move", function () {
        if (me.isMapReady()) {
            me._emitTdEventListeners("moving");
        }
    });
};
trackdirect.models.Map.prototype._initOms = function () {
    let options = {};
    options["nearbyDistance"] = 12;
    if (typeof google === "object" && typeof google.maps === "object") {
        let mti = google.maps.MapTypeId;
        this.oms = new OverlappingMarkerSpiderfier(this, options);
        this.oms.legColors.usual[mti.HYBRID] = this.oms.legColors.usual[mti.SATELLITE] = "#fff";
        this.oms.legColors.usual[mti.TERRAIN] = this.oms.legColors.usual[mti.ROADMAP] = "#222";
        this.oms.legColors.highlighted[mti.HYBRID] = this.oms.legColors.highlighted[mti.SATELLITE] = "#f00";
        this.oms.legColors.highlighted[mti.TERRAIN] = this.oms.legColors.highlighted[mti.ROADMAP] = "#f00";
    } else if (typeof L === "object") {
        this.oms = new OverlappingMarkerSpiderfier(this, options);
    }
};
trackdirect.models.Map.prototype._initInfoWindowEvent = function () {
    let me = this;
    if (this.oms) {
        this.oms.addListener("click", function (marker, event) {
            me.openMarkerInfoWindow(marker, false);
        });
    } else {
    }
};
trackdirect.models.Map.prototype._getGoogleMapOptions = function () {
    let zoom = this._getInitialZoom();
    let mapOptions = {
        zoom: zoom,
        panControl: false,
        zoomControl: true,
        zoomControlOptions: { position: google.maps.ControlPosition.RIGHT_BOTTOM },
        mapTypeControl: false,
        scaleControl: false,
        streetViewControl: false,
        overviewMapControl: false,
        fullscreenControl: false,
        mapTypeId: google.maps.MapTypeId.ROADMAP,
        gestureHandling: "greedy",
    };
    mapOptions.mapTypeId = this._supportedMapTypes[this._mapType];
    return mapOptions;
};
trackdirect.models.Map.prototype._getLeafletMapOptions = function () {
    let zoom = this._getInitialZoom();
    let mapOptions = { zoom: zoom, zoomControl: true, attributionControl: true, zoomControl: false, minZoom: 3, maxZoom: 19, closePopupOnClick: false };
    return mapOptions;
};
trackdirect.models.Map.prototype._getInitialZoom = function () {
    let zoom = trackdirect.settings.defaultCurrentZoom;
    if (typeof this._tdMapOptions.zoom !== "undefined" && this._tdMapOptions.zoom !== null) {
        zoom = parseInt(this._tdMapOptions.zoom);
    } else if (trackdirect.isMobile) {
        zoom = trackdirect.settings.defaultCurrentZoomMobile;
    }
    return zoom;
};
trackdirect.models.Map.prototype.getCurrentRadiusInKm = function () {
    if (this.getBounds() != null) {
        let latLngLiteral;
        if (typeof google === "object" && typeof google.maps === "object") {
            let latLng = this.getBounds().getNorthEast();
            latLngLiteral = { lat: latLng.lat(), lng: latLng.lng() };
        } else if (typeof L === "object") {
            let latLng = this.getBounds().getNorthEast();
            latLngLiteral = { lat: latLng.lat, lng: latLng.lng };
        }
        return trackdirect.services.distanceCalculator.getDistance(this.getCenterLiteral(), latLngLiteral) / 1000;
    }
    return 0;
};
trackdirect.models.Map.prototype._renderCoordinatesContainer = function (mouseLatLng) {
    let options = this.getTdMapOptions();
    if (typeof options.coordinatesContainer === "undefined") {
        return;
    }
    if (options.coordinatesContainer == null) {
        return;
    }
    let lat = null;
    let lng = null;
    if (typeof mouseLatLng.lat == "function") {
        lat = mouseLatLng.lat();
        lng = mouseLatLng.lng();
    } else {
        lat = mouseLatLng.lat;
        lng = mouseLatLng.lng;
    }
    if (lat <= 90 && lat >= -90 && lng <= 180 && lng >= -180) {
        let content = "";
        content += this._getGpsDegreeFromGpsDecimal(lat.toFixed(5), "lat");
        content += " " + this._getGpsDegreeFromGpsDecimal(lng.toFixed(5), "lon");
        content += "&nbsp;|&nbsp;" + lat.toFixed(5) + ", " + lng.toFixed(5);
        content += "&nbsp;|&nbsp;" + this._getMaidenheadLocatorFromGpsDecimal(lat, lng);
        $("#" + options.coordinatesContainer).html(content);
    }
};
trackdirect.models.Map.prototype._getGpsDegreeFromGpsDecimal = function (dms, type) {
    let sign = 1,
        Abs = 0;
    let days, minutes, secounds, direction;
    if (dms < 0) {
        sign = -1;
    }
    Abs = Math.abs(Math.round(dms * 1000000));
    if (type == "lat" && Abs > 90 * 1000000) {
        return false;
    } else if (type == "lon" && Abs > 180 * 1000000) {
        return false;
    }
    days = Math.floor(Abs / 1000000);
    minutes = Math.floor((Abs / 1000000 - days) * 60);
    secounds = ((Math.floor(((Abs / 1000000 - days) * 60 - minutes) * 100000) * 60) / 100000).toFixed();
    days = days * sign;
    if (type == "lat") direction = days < 0 ? "S" : "N";
    if (type == "lon") direction = days < 0 ? "W" : "E";
    return days * sign + "º " + minutes + "' " + secounds + "'' " + direction;
};
trackdirect.models.Map.prototype._getMaidenheadLocatorFromGpsDecimal = function (lat, lng) {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVX";
    let result = "";
    lng = lng + 180;
    lat = lat + 90;
    result = chars.charAt(parseInt(lng / 20));
    result += chars.charAt(parseInt(lat / 10));
    result += parseInt((lng / 2) % 10);
    result += parseInt(lat % 10);
    lng_r = (lng - parseInt(lng / 2) * 2) * 60;
    lat_r = (lat - parseInt(lat)) * 60;
    result += chars.charAt(parseInt(lng_r / 5));
    result += chars.charAt(parseInt(lat_r / 2.5));
    return result;
};
if (typeof google === "object" && typeof google.maps === "object") {
    trackdirect.models.Label = function (options, map) {
        this._defaultMap = map;
        options.map = null;
        this.setValues(options);
        this.div_ = null;
    };
    trackdirect.models.Label.prototype = new google.maps.OverlayView();
    trackdirect.models.Label.prototype.show = function () {
        if (typeof this.getMap() === "undefined" || this.getMap() === null) {
            this.setMap(this._defaultMap);
        }
    };
    trackdirect.models.Label.prototype.hide = function () {
        if (this.getMap() !== null) {
            this.setMap(null);
        }
    };
    trackdirect.models.Label.prototype.onAdd = function () {
        if (this.div_ === null) {
            let jqSpan = $(document.createElement("span"));
            jqSpan.css("color", "#101010");
            jqSpan.css("text-shadow", "1px 1px 1px #FFF, -1px -1px 1px #FFF, 1px -1px 1px #FFF, -1px 1px 1px #FFF, 1px 1px 1px #FFF");
            jqSpan.css("position", "relative");
            jqSpan.css("top", "10px");
            jqSpan.css("white-space", "nowrap");
            jqSpan.css("font-family", "Helvetica");
            jqSpan.css("font-weight", "bold");
            jqSpan.css("font-size", "10px");
            jqSpan.css("padding", "0px");
            jqSpan.css("z-index", "1000");
            jqSpan.css("margin", "0");
            jqSpan.css("line-height", "10px");
            let span = (this.span_ = jqSpan[0]);
            span.innerHTML = this.get("text").toString();
            let div = (this.div_ = document.createElement("div"));
            div.appendChild(span);
            div.style.cssText = "position: absolute; display: none";
        }
        let pane = this.getPanes().overlayLayer;
        pane.appendChild(this.div_);
        let me = this;
        this.listeners_ = [
            google.maps.event.addListener(this, "position_changed", function () {
                me.draw();
            }),
            google.maps.event.addListener(this, "text_changed", function () {
                me.draw();
            }),
        ];
    };
    trackdirect.models.Label.prototype.onRemove = function () {
        if (this.div_ !== null && this.div_.parentNode !== null) {
            this.div_.parentNode.removeChild(this.div_);
            for (let i = 0, I = this.listeners_.length; i < I; ++i) {
                google.maps.event.removeListener(this.listeners_[i]);
            }
        }
    };
    trackdirect.models.Label.prototype.draw = function () {
        let projection = this.getProjection();
        let latLng;
        if (typeof this.get("position").lat === "function") {
            latLng = new google.maps.LatLng({ lat: this.get("position").lat(), lng: this.get("position").lng() });
        } else {
            latLng = new google.maps.LatLng({ lat: this.get("position").lat, lng: this.get("position").lng });
        }
        let position = projection.fromLatLngToDivPixel(latLng);
        let div = this.div_;
        let span = this.span_;
        span.innerHTML = this.get("text").toString();
        div.style.left = position.x + "px";
        div.style.top = position.y + "px";
        div.style.display = "block";
    };
} else if (typeof L === "object" && typeof L.Tooltip !== "undefined") {
    trackdirect.models.Label = function (options, map) {
        this._defaultMap = map;
        L.Tooltip.call(this, this._getBasicOptions(options));
        this.setContent(options.text);
        if (typeof options.position !== "undefined" && typeof options.position.lat !== "undefined" && typeof options.position.lng !== "undefined") {
            this.setLatLng(new L.LatLng(options.position.lat, options.position.lng));
        }
    };
    trackdirect.models.Label.prototype = new L.Tooltip();
    trackdirect.models.Label.prototype.show = function () {
        if (!this._defaultMap.hasLayer(this)) {
            this.addTo(this._defaultMap);
        }
    };
    trackdirect.models.Label.prototype.hide = function () {
        if (this._defaultMap.hasLayer(this)) {
            this._defaultMap.removeLayer(this);
        }
    };
    trackdirect.models.Label.prototype._getBasicOptions = function (options) {
        return { direction: "right", noWrap: true, offset: L.point(2, 10), className: "leaflet-marker-labeltext", permanent: true };
    };
} else if (typeof L === "object") {
    trackdirect.models.Label = function (options, map) {
        this._defaultMap = map;
        let position = null;
        if (typeof options.position !== "undefined" && typeof options.position.lat !== "undefined" && typeof options.position.lng !== "undefined") {
            position = [options.position.lat, options.position.lng];
        }
        L.Marker.call(this, position, this._getBasicOptions(options));
    };
    trackdirect.models.Label.prototype = Object.create(L.Marker.prototype);
    trackdirect.models.Label.prototype.constructor = trackdirect.models.Label;
    trackdirect.models.Label.prototype.show = function () {
        if (!this._defaultMap.hasLayer(this)) {
            this.addTo(this._defaultMap);
        }
    };
    trackdirect.models.Label.prototype.hide = function () {
        if (this._defaultMap.hasLayer(this)) {
            this._defaultMap.removeLayer(this);
        }
    };
    trackdirect.models.Label.prototype._getBasicOptions = function (options) {
        let strlen = options.text.length;
        let myIcon = L.divIcon({ iconSize: new L.Point(strlen * 10, 20), className: "leaflet-marker-labeltext", html: options.text, iconAnchor: new L.Point(-2, -10) });
        return { icon: myIcon, clickable: false, keyboard: false };
    };
} else {
    trackdirect.models.Label = function (options, map) {};
    trackdirect.models.Label.prototype.show = function () {};
    trackdirect.models.Label.prototype.hide = function () {};
}
trackdirect.models.InfoWindow = function (marker, map, disableAutoPan) {
    disableAutoPan = typeof disableAutoPan !== "undefined" ? disableAutoPan : true;
    this._marker = marker;
    this._defaultMap = map;
    this._polyline = null;
    this._tdEventListeners = {};
    if (typeof google === "object" && typeof google.maps === "object") {
        const googleInfoWindow = new google.maps.InfoWindow({ disableAutoPan: disableAutoPan });
        for (const key of Object.keys(this)) {
            googleInfoWindow[key] = this[key];
        }
        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {
            if (key !== "constructor" && typeof this[key] === "function") {
                googleInfoWindow[key] = this[key];
            }
        }
        return googleInfoWindow;
    } else if (typeof L === "object") {
        let yOffset = 2;
        if (!marker.isDotMarker()) {
            yOffset = -5;
        }
        L.Popup.call(this, { autoPan: !disableAutoPan, offset: [0, yOffset], maxWidth: 440, className: "leaflet-infowindow-content" });
    }
    let me = this;
    if (typeof google === "object" && typeof google.maps === "object") {
        google.maps.event.addListener(this, "closeclick", function () {
            me._hideRelatedMarkerTail();
        });
    } else if (typeof L === "object") {
        this.on("popupclose", function () {
            me._hideRelatedMarkerTail();
        });
    }
};
if (typeof google === "object" && typeof google.maps === "object") {
    trackdirect.models.InfoWindow.prototype = Object.create(google.maps.InfoWindow.prototype);
} else if (typeof L === "object") {
    trackdirect.models.InfoWindow.prototype = Object.create(L.Popup.prototype);
}
trackdirect.models.InfoWindow.prototype.constructor = trackdirect.models.InfoWindow;
trackdirect.models.InfoWindow.prototype.setMarker = function (marker) {
    this._marker = marker;
};
trackdirect.models.InfoWindow.prototype.getMarker = function () {
    return this._marker;
};
trackdirect.models.InfoWindow.prototype.getPolyline = function () {
    return this._polyline;
};
trackdirect.models.InfoWindow.prototype.isInfoWindowOpen = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (this.getMap() !== null) {
            return true;
        }
    } else if (typeof L === "object" && typeof windyInit === "function") {
        return this._defaultMap.hasLayer(this);
    } else if (typeof L === "object") {
        return this.isOpen();
    }
    return false;
};
trackdirect.models.InfoWindow.prototype.show = function (compactVersion, position) {
    compactVersion = typeof compactVersion !== "undefined" ? compactVersion : false;
    position = typeof position !== "undefined" ? position : null;
    this._create(compactVersion);
    if (typeof google === "object" && typeof google.maps === "object") {
        if (position !== null) {
            this.setPosition(position);
            this.open(this._defaultMap);
        } else {
            this.open(this._defaultMap, this._marker);
        }
        this.addListener("domready", function () {
            this._addPhgLinkListeners();
            this._addRngLinkListeners();
        });
    } else if (typeof L === "object") {
        if (this.isOpen()) {
            this._addPhgLinkListeners();
            this._addRngLinkListeners();
        } else {
            this.on("add", function () {
                this._addPhgLinkListeners();
                this._addRngLinkListeners();
            });
        }
        if (position !== null) {
            this.setLatLng(position);
            this.openOn(this._defaultMap);
        } else {
            this.setLatLng(this._marker.packet.getLatLngLiteral());
            this.openOn(this._defaultMap);
        }
    }
    if (this._defaultMap.getZoom() < trackdirect.settings.minZoomForMarkerTail) {
        if (this._marker.overwrite) {
            this._emitTdEventListeners("station-tail-needed", this._marker.packet.station_id);
        }
        this._marker.showMarkerTail(true);
    }
};
trackdirect.models.InfoWindow.prototype.hide = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        this.close();
        if (this.getMap() !== null) {
            this.setMap(null);
        }
    } else if (typeof L === "object") {
        this._defaultMap.removeLayer(this);
    }
    this._hideRelatedMarkerTail();
    if (this._defaultMap.state.openInfoWindow !== null && this._defaultMap.state.openInfoWindow === this) {
        this._defaultMap.state.openInfoWindow = null;
    }
};
(trackdirect.models.InfoWindow.prototype.addTdListener = function (event, handler) {
    if (!(event in this._tdEventListeners)) {
        this._tdEventListeners[event] = [];
    }
    this._tdEventListeners[event].push(handler);
}),
    (trackdirect.models.InfoWindow.prototype._emitTdEventListeners = function (event, arg) {
        if (event in this._tdEventListeners) {
            for (let i = 0; i < this._tdEventListeners[event].length; i++) {
                this._tdEventListeners[event][i](arg);
            }
        }
    });
trackdirect.models.InfoWindow.prototype._create = function (compactVersion) {
    let mainDiv;
    let menuwrapper;
    if (compactVersion) {
        mainDiv = this._getCompactMainDiv();
        menuwrapper = this._getMenuDiv(false);
        this._polyline = this._defaultMap.markerCollection.getMarkerPolyline(this._marker.markerIdKey);
    } else {
        mainDiv = this._getMainDiv();
        if (!trackdirect.isMobile) {
            mainDiv.append(this._getIconDiv());
        }
        mainDiv.append(this._getCompletePacketDiv());
        menuwrapper = this._getMenuDiv(true);
    }
    mainDiv.append(menuwrapper);
    let wrapperDiv = $(document.createElement("div"));
    wrapperDiv.append(mainDiv);
    if (typeof google === "object" && typeof google.maps === "object") {
        this.setContent(wrapperDiv.html());
    } else if (typeof L === "object") {
        this.setContent(wrapperDiv.html());
    }
};
trackdirect.models.InfoWindow.prototype._hideRelatedMarkerTail = function () {
    if (this._polyline !== null) {
        if (!this._defaultMap.state.isFilterMode && this._defaultMap.getZoom() < trackdirect.settings.minZoomForMarkerTail) {
            let markerIdKey = this._polyline.markerIdKey;
            if (this._defaultMap.markerCollection.isExistingMarker(markerIdKey)) {
                let stationId = this._defaultMap.markerCollection.getMarker(markerIdKey).packet.station_id;
                let stationLatestMarker = this._defaultMap.markerCollection.getStationLatestMarker(stationId);
                if (stationLatestMarker !== null) {
                    stationLatestMarker.hideMarkerTail();
                }
            }
        }
    } else if (this._marker !== null) {
        if (!this._defaultMap.state.isFilterMode && this._defaultMap.getZoom() < trackdirect.settings.minZoomForMarkerTail) {
            this._marker.hideMarkerTail();
        }
    }
};
trackdirect.models.InfoWindow.prototype._getMainDiv = function () {
    let mainDiv = $(document.createElement("div"));
    mainDiv.css("font-family", "Verdana,Arial,sans-serif");
    if (!trackdirect.isMobile) {
        mainDiv.css("font-size", "11px");
    } else {
        mainDiv.css("font-size", "10px");
    }
    mainDiv.css("line-height", "1.42857143");
    mainDiv.css("color", "#333");
    mainDiv.css("text-align", "left");
    return mainDiv;
};
trackdirect.models.InfoWindow.prototype._getIconDiv = function () {
    let iconUrl64 = trackdirect.services.symbolPathFinder.getFilePath(this._marker.packet.symbol_table, this._marker.packet.symbol, null, null, null, 64, 64);
    let iconImg = $(document.createElement("img"));
    iconImg.css("width", "64px");
    iconImg.css("height", "64px");
    iconImg.attr("src", iconUrl64);
    iconImg.attr("alt", "");
    iconImg.attr("title", "");
    let leftIconDiv = $(document.createElement("div"));
    leftIconDiv.css("display", "inline-block");
    leftIconDiv.css("vertical-align", "top");
    leftIconDiv.css("padding-right", "15px");
    leftIconDiv.css("padding-bottom", "5px");
    leftIconDiv.append(iconImg);
    return leftIconDiv;
};
trackdirect.models.InfoWindow.prototype._getPacketDiv = function () {
    let packetDiv = $(document.createElement("div"));
    packetDiv.css("display", "inline-block");
    packetDiv.css("vertical-align", "top");
    packetDiv.css("max-width", "350px");
    return packetDiv;
};
trackdirect.models.InfoWindow.prototype._getNameIconDiv = function () {
    let iconUrl24 = trackdirect.services.symbolPathFinder.getFilePath(this._marker.packet.symbol_table, this._marker.packet.symbol, null, null, null, 24, 24);
    let iconImg = $(document.createElement("img"));
    iconImg.css("width", "24px");
    iconImg.css("height", "24px");
    iconImg.css("vertical-align", "middle");
    iconImg.attr("src", iconUrl24);
    iconImg.attr("alt", "symbol");
    iconImg.attr("title", "");
    return iconImg;
};
trackdirect.models.InfoWindow.prototype._getNameLink = function () {
    let nameLink = $(document.createElement("a"));
    nameLink.css("color", "#337ab7");
    if (trackdirect.isMobile) {
        nameLink.css("vertical-align", "-2px");
    }
    nameLink.attr("href", "");
    nameLink.attr("onclick", "trackdirect.openStationInformationDialog(" + this._marker.packet.station_id + "); return false;");
    nameLink.html(escapeHtml(this._marker.packet.station_name));
    return nameLink;
};
trackdirect.models.InfoWindow.prototype._getSenderNameLink = function () {
    let nameLink = $(document.createElement("span"));
    if (trackdirect.isMobile) {
        nameLink.css("vertical-align", "-2px");
    }
    nameLink.html(escapeHtml(this._marker.packet.sender_name));
    return nameLink;
};
trackdirect.models.InfoWindow.prototype._getNameDiv = function () {
    let nameDiv = $(document.createElement("div"));
    nameDiv.css("clear", "both");
    nameDiv.css("font-size", "12px");
    nameDiv.css("font-weight", "bold");
    if (trackdirect.isMobile) {
        nameDiv.append(this._getNameIconDiv());
        nameDiv.append("&nbsp;");
        nameDiv.append("&nbsp;");
    }
    nameDiv.append(this._getNameLink());
    if (this._marker.packet.getOgnRegistration() != null) {
        let name = escapeHtml(this._marker.packet.getOgnRegistration());
        if (this._marker.packet.getOgnCN() !== null) {
            name += " [" + escapeHtml(this._marker.packet.getOgnCN()) + "]";
        }
        nameDiv.append(", ");
        nameDiv.append(name);
    }
    if (this._marker.packet.sender_name != this._marker.packet.station_name) {
        nameDiv.append("&nbsp;(");
        nameDiv.append(this._getSenderNameLink());
        nameDiv.append(")");
    }
    return nameDiv;
};
trackdirect.models.InfoWindow.prototype._getCompletePacketDiv = function () {
    let packetDiv = this._getPacketDiv();
    packetDiv.append(this._getNameDiv());
    packetDiv.append(this._getPacketTimeDiv());
    if (this._marker.packet.timestamp > 0) {
        if ($(window).height() >= 300) {
            packetDiv.append(this._getPacketPathDiv());
        }
        let phgRange = this._marker.packet.getPHGRange();
        let rngRange = this._marker.packet.getRNGRange();
        if (phgRange !== null || rngRange !== null) {
            packetDiv.append(this._getSpaceDiv());
            packetDiv.append(this._getPhgDiv(phgRange));
            packetDiv.append(this._getRngDiv(rngRange));
        }
        if ($(window).height() >= 300) {
            let transmitDistance = this._getTransmitDistance(this._marker.packet);
            let tailDistance = this._getTailDistance(this._defaultMap.markerCollection.getMarkerMasterMarkerKeyId(this._marker.markerIdKey));
            if ((transmitDistance !== null && Math.round(transmitDistance / 100) != 0) || (tailDistance !== null && Math.round(tailDistance) > 0)) {
                packetDiv.append(this._getSpaceDiv());
                packetDiv.append(this._getTransmitDistanceDiv(transmitDistance));
                packetDiv.append(this._getTailDistanceDiv(tailDistance));
            }
        }
        if (this._marker.packet.speed !== null || this._marker.packet.course !== null || this._marker.packet.altitude !== null) {
            packetDiv.append(this._getSpaceDiv());
            packetDiv.append(this._getPacketSpeedAltitudeCourseDiv());
        }
        if (typeof this._marker.packet.weather !== "undefined" && this._marker.packet.weather !== null) {
            packetDiv.append(this._getSpaceDiv());
            packetDiv.append(this._getWeatherDiv());
        }
        if (typeof this._marker.packet.latest_telemetry_packet_timestamp !== "undefined" && this._marker.packet.latest_telemetry_packet_timestamp !== null) {
            packetDiv.append(this._getSpaceDiv());
            packetDiv.append(this._getTelemetryDiv());
        }
        let commentDiv = this._getPacketCommentDiv();
        if (commentDiv != null) {
            packetDiv.append(this._getSpaceDiv());
            packetDiv.append(commentDiv);
        }
    }
    return packetDiv;
};
trackdirect.models.InfoWindow.prototype._getPacketTimeDiv = function () {
    let dateString;
    if (this._marker.packet.timestamp == 0) {
        dateString = '<span style="color: grey;">No known packet for specified limits.</span>';
    } else {
        let date = new Date(this._marker.packet.timestamp * 1000);
        dateString = moment(date).format(trackdirect.settings.dateFormatNoTimeZone);
        if (this._marker.packet.timestamp > this._marker.packet.position_timestamp && !trackdirect.isMobile) {
            let positionDate = new Date(this._marker.packet.position_timestamp * 1000);
            dateString = moment(positionDate).format(trackdirect.settings.dateFormatNoTimeZone) + " - " + moment(date).format(trackdirect.settings.dateFormatNoTimeZone);
        }
        if (this._defaultMap.state.endTimeTravelTimestamp !== null && this._marker.packet.map_id == 12) {
            dateString += '<br/><span style="color: grey;">(exact time for this is not known)</span>';
        }
    }
    let timeDiv = $(document.createElement("div"));
    timeDiv.css("clear", "both");
    timeDiv.html(dateString);
    return timeDiv;
};
trackdirect.models.InfoWindow.prototype._getPacketPathDiv = function () {
    let rawPath = this._marker.packet.getLinkifiedRawPath();
    if (rawPath !== null) {
        let rawPathDiv = $(document.createElement("div"));
        rawPathDiv.css("clear", "both");
        rawPathDiv.html("[" + rawPath + "]");
        return rawPathDiv;
    }
    return null;
};
trackdirect.models.InfoWindow.prototype._getSpaceDiv = function () {
    let spaceDiv = $(document.createElement("div"));
    spaceDiv.css("clear", "both");
    spaceDiv.css("line-height", "4px");
    spaceDiv.html("&nbsp;");
    return spaceDiv;
};
trackdirect.models.InfoWindow.prototype._getPhgDiv = function (phgRange) {
    let phgRangeToShow = phgRange;
    let phgRangeUnit = "";
    if (phgRange !== null) {
        if (this._defaultMap.state.useImperialUnit) {
            phgRangeToShow = Math.round(trackdirect.services.imperialConverter.convertKilometerToMile(phgRange / 1000) * 10) / 10;
            phgRangeUnit = "miles";
        } else {
            phgRangeToShow = Math.round(phgRange / 10) / 100;
            phgRangeUnit = "km";
        }
        let phgDiv = $(document.createElement("div"));
        phgDiv.attr("id", "phglinks-" + this._marker.packet.station_id + "-" + this._marker.packet.id);
        let halfPhgLink = $("<a style='color: #337ab7;' id='half-phg-" + this._marker.packet.station_id + "-" + this._marker.packet.id + "' href='#'>Half</a>");
        let fullPhgLink = $("<a style='color: #337ab7;' id='full-phg-" + this._marker.packet.station_id + "-" + this._marker.packet.id + "' href='#'>Full</a>");
        let nonePhgLink = $("<a style='color: #337ab7;' id='none-phg-" + this._marker.packet.station_id + "-" + this._marker.packet.id + "' href='#'>None</a>");
        phgDiv.css("clear", "both");
        phgDiv.css("display", "none");
        phgDiv.css("color", "#440B2A");
        phgDiv.append("PHG calculated range: " + phgRangeToShow + " " + phgRangeUnit);
        if (typeof L === "object" && L.version <= "0.7.7") {
            return phgDiv;
        }
        if (phgRangeToShow > 0) {
            phgDiv.append("<br/>");
            phgDiv.append("PHG circle: ");
            phgDiv.append(fullPhgLink);
            phgDiv.append('<span style="color:#000"> - </span>');
            phgDiv.append(halfPhgLink);
            phgDiv.append('<span style="color:#000"> - </span>');
            phgDiv.append(nonePhgLink);
        }
        return phgDiv;
    }
    return null;
};
trackdirect.models.InfoWindow.prototype._getRngDiv = function (rngRange) {
    let rngRangeToShow = rngRange;
    let rngRangeUnit = "";
    if (rngRange !== null) {
        if (this._defaultMap.state.useImperialUnit) {
            rngRangeToShow = Math.round(trackdirect.services.imperialConverter.convertKilometerToMile(rngRange / 1000) * 10) / 10;
            rngRangeUnit = "miles";
        } else {
            rngRangeToShow = Math.round(rngRange * 100) / 100;
            rngRangeUnit = "km";
        }
        let rngDiv = $(document.createElement("div"));
        rngDiv.attr("id", "rnglinks-" + this._marker.packet.station_id + "-" + this._marker.packet.id);
        let halfRngLink = $("<a style='color: #337ab7;' id='half-rng-" + this._marker.packet.station_id + "-" + this._marker.packet.id + "' href='#'>Half</a>");
        let fullRngLink = $("<a style='color: #337ab7;' id='full-rng-" + this._marker.packet.station_id + "-" + this._marker.packet.id + "' href='#'>Full</a>");
        let noneRngLink = $("<a style='color: #337ab7;' id='none-rng-" + this._marker.packet.station_id + "-" + this._marker.packet.id + "' href='#'>None</a>");
        rngDiv.css("clear", "both");
        rngDiv.css("display", "none");
        rngDiv.css("color", "#440B2A");
        rngDiv.append("RNG precalculated range: " + rngRangeToShow + " " + rngRangeUnit);
        if (typeof L === "object" && L.version <= "0.7.7") {
            return rngDiv;
        }
        if (rngRangeToShow > 0) {
            rngDiv.append("<br/>");
            rngDiv.append("RNG circle: ");
            rngDiv.append(fullRngLink);
            rngDiv.append('<span style="color:#000"> - </span>');
            rngDiv.append(halfRngLink);
            rngDiv.append('<span style="color:#000"> - </span>');
            rngDiv.append(noneRngLink);
        }
        return rngDiv;
    }
    return null;
};
trackdirect.models.InfoWindow.prototype._getTransmitDistanceDiv = function (transmitDistance) {
    if (transmitDistance !== null && Math.round(transmitDistance / 100) != 0) {
        let transmitDistanceDiv = $(document.createElement("div"));
        transmitDistanceDiv.css("clear", "both");
        transmitDistanceDiv.css("color", "#273c20");
        if (this._defaultMap.state.useImperialUnit) {
            transmitDistance = Math.round(trackdirect.services.imperialConverter.convertKilometerToMile(transmitDistance / 1000) * 10) / 10;
            transmitDistanceUnit = "miles";
        } else {
            transmitDistance = Math.round(transmitDistance / 100) / 10;
            transmitDistanceUnit = "km";
        }
        transmitDistanceDiv.append('<span title="Transmit distance to receiving digipeater/igate">Transmit distance: ' + transmitDistance + " " + transmitDistanceUnit + "</span>");
        return transmitDistanceDiv;
    }
    return null;
};
trackdirect.models.InfoWindow.prototype._getTailDistanceDiv = function (tailDistance) {
    if (tailDistance !== null && Math.round(tailDistance) > 0) {
        let distanceDiv = $(document.createElement("div"));
        distanceDiv.css("clear", "both");
        distanceDiv.css("color", "#273c20");
        if (tailDistance < 1000) {
            if (this._defaultMap.state.useImperialUnit) {
                tailDistance = Math.round(trackdirect.services.imperialConverter.convertMeterToYard(tailDistance));
                tailDistanceUnit = "yd";
            } else {
                tailDistance = Math.round(tailDistance);
                tailDistanceUnit = "m";
            }
        } else {
            if (this._defaultMap.state.useImperialUnit) {
                tailDistance = Math.round(trackdirect.services.imperialConverter.convertKilometerToMile(tailDistance / 1000) * 10) / 10;
                tailDistanceUnit = "miles";
            } else {
                tailDistance = Math.round(tailDistance / 100) / 10;
                tailDistanceUnit = "km";
            }
        }
        distanceDiv.append('<span title="Current shown tail distance (depends on the time settings)">Current tail distance: ' + tailDistance + " " + tailDistanceUnit + "</span>");
        return distanceDiv;
    }
    return null;
};
trackdirect.models.InfoWindow.prototype._getPacketSpeedAltitudeCourseDiv = function () {
    if (Math.round(this._marker.packet.speed) != 0 || Math.round(this._marker.packet.course) != 0 || Math.round(this._marker.packet.altitude) != 0) {
        let speedDiv = $(document.createElement("div"));
        speedDiv.css("clear", "both");
        speedDiv.css("font-weight", "bold");
        if (this._marker.packet.speed !== null) {
            if (this._defaultMap.state.useImperialUnit) {
                speedDiv.append(Math.round(trackdirect.services.imperialConverter.convertKilometerToMile(this._marker.packet.speed)) + " mph ");
            } else {
                speedDiv.append(Math.round(this._marker.packet.speed) + " km/h ");
            }
        }
        if (this._marker.packet.course !== null) {
            speedDiv.append(Math.round(this._marker.packet.course) + "&deg; ");
        }
        if (this._marker.packet.altitude !== null) {
            if (this._defaultMap.state.useImperialUnit) {
                speedDiv.append(" alt " + Math.round(trackdirect.services.imperialConverter.convertMeterToFeet(this._marker.packet.altitude)) + " ft ");
            } else {
                speedDiv.append(" alt " + Math.round(this._marker.packet.altitude) + " m ");
            }
        }
        return speedDiv;
    }
    return null;
};
trackdirect.models.InfoWindow.prototype._getWeatherDivRainString = function () {
    if (isNumeric(this._marker.packet.weather.rain_1h)) {
        let rain1h = "-";
        let rain24h = "-";
        let rainSinceMidnight = "-";
        if (this._defaultMap.state.useImperialUnit) {
            if (isNumeric(this._marker.packet.weather.rain_1h)) {
                rain1h = Math.round(trackdirect.services.imperialConverter.convertMmToInch(this._marker.packet.weather.rain_1h)) + "in";
            }
            if (isNumeric(this._marker.packet.weather.rain_24h)) {
                rain24h = Math.round(trackdirect.services.imperialConverter.convertMmToInch(this._marker.packet.weather.rain_24h)) + "in";
            }
            if (isNumeric(this._marker.packet.weather.rain_since_midnight)) {
                rainSinceMidnight = Math.round(trackdirect.services.imperialConverter.convertMmToInch(this._marker.packet.weather.rain_since_midnight)) + "in";
            }
        } else {
            if (isNumeric(this._marker.packet.weather.rain_1h)) {
                rain1h = Math.round(this._marker.packet.weather.rain_1h) + "mm";
            }
            if (isNumeric(this._marker.packet.weather.rain_24h)) {
                rain24h = Math.round(this._marker.packet.weather.rain_24h) + "mm";
            }
            if (isNumeric(this._marker.packet.weather.rain_since_midnight)) {
                rainSinceMidnight = Math.round(this._marker.packet.weather.rain_since_midnight) + "mm";
            }
        }
        return "<b>Rain</b> " + rain1h + "/" + rain24h + "/" + rainSinceMidnight + " (1h/24h/midnight)<br/>";
    }
    return null;
};
trackdirect.models.InfoWindow.prototype._getWeatherDivTemperatureString = function () {
    if (isNumeric(this._marker.packet.weather.temperature)) {
        if (this._defaultMap.state.useImperialUnit) {
            return "<b>Temperature</b> " + Math.round(trackdirect.services.imperialConverter.convertCelciusToFahrenheit(this._marker.packet.weather.temperature)) + "&deg;F" + "<br/>";
        } else {
            return "<b>Temperature</b> " + Math.round(this._marker.packet.weather.temperature) + "&deg;C" + "<br/>";
        }
    }
    return null;
};
trackdirect.models.InfoWindow.prototype._getWeatherDivHumidityString = function () {
    if (isNumeric(this._marker.packet.weather.humidity)) {
        return "<b>Humidity</b> " + Math.round(this._marker.packet.weather.humidity) + "%<br/>";
    }
    return null;
};
trackdirect.models.InfoWindow.prototype._getWeatherDivPressureString = function () {
    if (isNumeric(this._marker.packet.weather.pressure)) {
        if (this._defaultMap.state.useImperialUnit) {
            return "<b>Pressure</b> " + Math.round(trackdirect.services.imperialConverter.convertMbarToMmhg(this._marker.packet.weather.pressure)) + " mmHg<br/>";
        } else {
            return "<b>Pressure</b> " + Math.round(this._marker.packet.weather.pressure) + " hPa<br/>";
        }
    }
    return null;
};
trackdirect.models.InfoWindow.prototype._getWeatherDivWindString = function () {
    if (isNumeric(this._marker.packet.weather.wind_speed)) {
        let windDir = "";
        if (typeof this._marker.packet.weather.wind_direction !== "undefined" && isNumeric(this._marker.packet.weather.wind_direction)) {
            windDir = this._marker.packet.weather.wind_direction.toString() + "&deg; ";
        }
        if (this._defaultMap.state.useImperialUnit) {
            if (isNumeric(this._marker.packet.weather.wind_gust)) {
                return (
                    "<b>Wind</b> " +
                    windDir +
                    Math.round(trackdirect.services.imperialConverter.convertMpsToMph(this._marker.packet.weather.wind_speed) * 10) / 10 +
                    " mph" +
                    " (" +
                    Math.round(trackdirect.services.imperialConverter.convertMpsToMph(this._marker.packet.weather.wind_gust) * 10) / 10 +
                    " mph)<br/>"
                );
            } else {
                return "<b>Wind</b> " + windDir + Math.round(trackdirect.services.imperialConverter.convertMpsToMph(this._marker.packet.weather.wind_speed) * 10) / 10 + " mph<br/>";
            }
        } else {
            if (isNumeric(this._marker.packet.weather.wind_gust)) {
                return "<b>Wind</b> " + windDir + Math.round(this._marker.packet.weather.wind_speed * 10) / 10 + " m/s" + " (" + Math.round(this._marker.packet.weather.wind_gust * 10) / 10 + " m/s)<br/>";
            } else {
                return "<b>Wind</b> " + windDir + Math.round(this._marker.packet.weather.wind_speed * 10) / 10 + " m/s <br/>";
            }
        }
    }
    return null;
};
trackdirect.models.InfoWindow.prototype._getWeatherDiv = function () {
    let weatherDiv = $(document.createElement("div"));
    weatherDiv.css("clear", "both");
    weatherDiv.css("color", "#227152");
    let weatherDate = new Date(this._marker.packet.timestamp * 1000);
    if (typeof this._marker.packet.weather.timestamp !== "undefined" && this._marker.packet.weather.timestamp !== null) {
        weatherDate = new Date(this._marker.packet.weather.timestamp * 1000);
    }
    weatherDateString = moment(weatherDate).format(trackdirect.settings.dateFormatNoTimeZone);
    weatherDiv.append("<b>Latest Weather</b>  " + weatherDateString + "<br/>");
    if (!trackdirect.isMobile && $(window).height() >= 300) {
        weatherDiv.append(this._getWeatherDivTemperatureString());
        weatherDiv.append(this._getWeatherDivHumidityString());
        weatherDiv.append(this._getWeatherDivPressureString());
        weatherDiv.append(this._getWeatherDivRainString());
        weatherDiv.append(this._getWeatherDivWindString());
    }
    return weatherDiv;
};
trackdirect.models.InfoWindow.prototype._getTelemetryDiv = function () {
    let telemetryDiv = $(document.createElement("div"));
    telemetryDiv.css("clear", "both");
    telemetryDiv.css("color", "#823030");
    let telemetryDate = new Date(this._marker.packet.latest_telemetry_packet_timestamp * 1000);
    telemetryDateString = moment(telemetryDate).format(trackdirect.settings.dateFormatNoTimeZone);
    telemetryDiv.append("Latest Telemetry  " + telemetryDateString + "<br/>");
    return telemetryDiv;
};
trackdirect.models.InfoWindow.prototype._getPacketCommentDiv = function () {
    let comment = "";
    let ognSummary = escapeHtml(this._marker.packet.getOgnSummary());
    if (ognSummary != "") {
        comment = ognSummary;
    } else if (typeof this._marker.packet.comment !== "undefined" && this._marker.packet.comment !== null) {
        comment = Autolinker.link(escapeHtml(this._marker.packet.comment), { newWindow: true });
    }
    if (comment == "") {
        return null;
    }
    let commentDiv = $(document.createElement("div"));
    commentDiv.css("clear", "both");
    commentDiv.css("font-weight", "bold");
    if (!trackdirect.isMobile) {
        commentDiv.css("font-size", "11px");
    } else {
        commentDiv.css("font-size", "10px");
    }
    commentDiv.html(comment);
    return commentDiv;
};
trackdirect.models.InfoWindow.prototype._addPhgLinkListeners = function () {
    let marker = this._marker;
    $("#half-phg-" + marker.packet.station_id + "-" + marker.packet.id).click(function (e) {
        marker.showPHGCircle(true);
        return false;
    });
    $("#full-phg-" + marker.packet.station_id + "-" + marker.packet.id).click(function (e) {
        marker.showPHGCircle(false);
        return false;
    });
    $("#none-phg-" + this._marker.packet.station_id + "-" + marker.packet.id).click(function (e) {
        marker.hidePHGCircle();
        return false;
    });
    if ($("#phglinks-" + marker.packet.station_id + "-" + marker.packet.id).length) {
        $("#phglinks-" + marker.packet.station_id + "-" + marker.packet.id).show();
    }
};
trackdirect.models.InfoWindow.prototype._addRngLinkListeners = function () {
    let marker = this._marker;
    $("#half-rng-" + marker.packet.station_id + "-" + marker.packet.id).click(function (e) {
        marker.showRNGCircle(true);
        return false;
    });
    $("#full-rng-" + marker.packet.station_id + "-" + marker.packet.id).click(function (e) {
        marker.showRNGCircle(false);
        return false;
    });
    $("#none-rng-" + marker.packet.station_id + "-" + marker.packet.id).click(function (e) {
        marker.hideRNGCircle();
        return false;
    });
    if ($("#rnglinks-" + marker.packet.station_id + "-" + marker.packet.id).length) {
        $("#rnglinks-" + marker.packet.station_id + "-" + marker.packet.id).show();
    }
};
trackdirect.models.InfoWindow.prototype._getMenuDiv = function (isInfoWindowOpen) {
    let menuWrapperDiv = this._getMenuDivWrapperDiv();
    let menuDiv = this._getMenuDivMainDiv();
    menuWrapperDiv.append(menuDiv);
    let menuUl = this._getMenuDivUlDiv();
    menuDiv.append(menuUl);
    menuUl.append(this._getMenuDivTrackLink());
    menuUl.append(this._getMenuDivFilterLink());
    if (!trackdirect.isMobile) {
        menuUl.append(this._getMenuDivCenterLink(isInfoWindowOpen));
    }
    menuUl.append(this._getMenuDivZoomLink(isInfoWindowOpen));
    if (!trackdirect.isEmbedded && !inIframe() && !this._marker.isMovingStation() && this._marker.packet.source_id != 2) {
        menuUl.append(this._getMenuDivCoverageLink());
    }
    return menuWrapperDiv;
};
trackdirect.models.InfoWindow.prototype._getMenuDivWrapperDiv = function () {
    let menuWrapperDiv = $(document.createElement("div"));
    menuWrapperDiv.addClass("infowindow-menu-wrapper");
    menuWrapperDiv.css("clear", "both");
    menuWrapperDiv.css("width", "100%");
    menuWrapperDiv.css("padding-top", "8px");
    return menuWrapperDiv;
};
trackdirect.models.InfoWindow.prototype._getMenuDivMainDiv = function () {
    let menuDiv = $(document.createElement("div"));
    menuDiv.addClass("infowindow-menu");
    menuDiv.css("width", "100%");
    menuDiv.css("border-top", "1px solid #cecece");
    return menuDiv;
};
trackdirect.models.InfoWindow.prototype._getMenuDivUlDiv = function () {
    let menuUl = $(document.createElement("ul"));
    menuUl.css("list-style-type", "none");
    menuUl.css("list-style", "none");
    menuUl.css("text-align", "center");
    menuUl.css("margin", "0");
    menuUl.css("padding", "0");
    menuUl.css("display", "table");
    return menuUl;
};
trackdirect.models.InfoWindow.prototype._getMenuDivLinkCss = function () {
    let liLinkCss = { "list-style": "none", display: "table-cell", "text-align": "center", "padding-right": "10px", width: "auto" };
    return liLinkCss;
};
trackdirect.models.InfoWindow.prototype._getMenuDivTrackLink = function () {
    let trackLinkElementClass = "trackStationLink" + this._marker.packet.station_id;
    let menuLi = $(document.createElement("li"));
    menuLi.css(this._getMenuDivLinkCss());
    let menuLink = $(document.createElement("a"));
    menuLink.css("color", "#337ab7");
    menuLink.attr("href", "#");
    menuLink.addClass(trackLinkElementClass);
    menuLink.attr("onclick", "trackdirect.handleTrackStationRequest(" + this._marker.packet.station_id + ', "' + trackLinkElementClass + '"); return false;');
    if (this._defaultMap.state.getTrackStationId() !== null && this._defaultMap.state.getTrackStationId() == this._marker.packet.station_id) {
        menuLink.html("Untrack");
    } else {
        menuLink.html("Track");
    }
    menuLi.append(menuLink);
    return menuLi;
};
trackdirect.models.InfoWindow.prototype._getMenuDivFilterLink = function () {
    let filterLinkElementClass = "filterStationLink" + this._marker.packet.station_id;
    let menuLi = $(document.createElement("li"));
    menuLi.css(this._getMenuDivLinkCss());
    let menuLink = $(document.createElement("a"));
    menuLink.css("color", "#337ab7");
    menuLink.addClass(filterLinkElementClass);
    menuLink.attr("onclick", "trackdirect.handleFilterStationRequest(" + this._marker.packet.station_id + ', "' + filterLinkElementClass + '"); return false;');
    if (this._defaultMap.state.filterStationIds.length > 0 && this._defaultMap.state.filterStationIds.indexOf(this._marker.packet.station_id) > -1) {
        menuLink.html("Unfilter");
        let center = this._defaultMap.getCenterLiteral();
        menuLink.attr("href", "/center/" + Number.parseFloat(center.lat).toFixed(5) + "," + Number.parseFloat(center.lng).toFixed(5) + "/zoom/" + this._defaultMap.getZoom());
    } else {
        menuLink.html("Filter");
        menuLink.attr("href", "/sid/" + this._marker.packet.station_id);
    }
    menuLi.append(menuLink);
    return menuLi;
};
trackdirect.models.InfoWindow.prototype._getMenuDivCoverageLink = function () {
    let coverageLinkElementClass = "stationCoverageLink" + this._marker.packet.station_id;
    let menuLi = $(document.createElement("li"));
    menuLi.css(this._getMenuDivLinkCss());
    let menuLink = $(document.createElement("a"));
    menuLink.css("color", "#337ab7");
    menuLink.css("white-space", "nowrap");
    menuLink.attr("href", "#");
    menuLink.addClass(coverageLinkElementClass);
    menuLink.attr("onclick", "trackdirect.toggleStationCoverage(" + this._marker.packet.station_id + ', "' + coverageLinkElementClass + '"); return false;');
    let coveragePolygon = this._defaultMap.markerCollection.getStationCoverage(this._marker.packet.station_id);
    if (coveragePolygon !== null && coveragePolygon.isRequestedToBeVisible()) {
        menuLink.html("Hide Coverage");
    } else {
        menuLink.html("Coverage");
    }
    menuLi.append(menuLink);
    return menuLi;
};
trackdirect.models.InfoWindow.prototype._getMenuDivCenterLink = function (isInfoWindowOpen) {
    let menuLi = $(document.createElement("li"));
    menuLi.css(this._getMenuDivLinkCss());
    let menuLink = $(document.createElement("a"));
    menuLink.css("color", "#337ab7");
    if (isInfoWindowOpen) {
        menuLink.attr("href", "/center/" + this._marker.packet.latitude.toFixed(5) + "," + this._marker.packet.longitude.toFixed(5) + "/zoom/" + this._defaultMap.getZoom());
        menuLink.attr("onclick", "trackdirect.setCenter(" + this._marker.packet.latitude + "," + this._marker.packet.longitude + "); return false;");
        menuLink.html("Center");
    } else {
        menuLink.attr("href", "/center/" + this._marker.packet.latitude.toFixed(5) + "," + this._marker.packet.longitude.toFixed(5) + "/zoom/" + this._defaultMap.getZoom());
        menuLink.attr("onclick", "trackdirect.focusOnMarkerId(" + this._marker.packet.marker_id + "); return false;");
        menuLink.html("Focus");
    }
    menuLi.append(menuLink);
    return menuLi;
};
trackdirect.models.InfoWindow.prototype._getMenuDivZoomLink = function (isInfoWindowOpen) {
    let menuLi = $(document.createElement("li"));
    menuLi.css(this._getMenuDivLinkCss());
    let menuLink = $(document.createElement("a"));
    menuLink.css("color", "#337ab7");
    if (isInfoWindowOpen) {
        menuLink.attr("href", "/center/" + this._marker.packet.latitude.toFixed(5) + "," + this._marker.packet.longitude.toFixed(5) + "/zoom/14");
        menuLink.attr("onclick", "trackdirect.setCenter(" + this._marker.packet.latitude + "," + this._marker.packet.longitude + ", 14); return false;");
        menuLink.html("Zoom");
    } else {
        menuLink.attr("href", "/center/" + this._marker.packet.latitude.toFixed(5) + "," + this._marker.packet.longitude.toFixed(5) + "/zoom/14");
        menuLink.attr("onclick", "trackdirect.focusOnMarkerId(" + this._marker.packet.marker_id + ", 14); return false;");
        menuLink.html("Zoom");
    }
    menuLi.append(menuLink);
    return menuLi;
};
trackdirect.models.InfoWindow.prototype._getCompactMainDiv = function () {
    let packet = this._marker.packet;
    let mainDiv = $(document.createElement("div"));
    mainDiv.css("font-family", "Verdana,Arial,sans-serif");
    if (!trackdirect.isMobile) {
        mainDiv.css("font-size", "11px");
    } else {
        mainDiv.css("font-size", "10px");
    }
    mainDiv.css("line-height", "1.42857143");
    mainDiv.css("color", "#333");
    mainDiv.css("text-align", "left");
    let polylineDiv = $(document.createElement("div"));
    polylineDiv.css("float", "left");
    let nameDiv = $(document.createElement("div"));
    nameDiv.css("clear", "both");
    nameDiv.css("font-size", "12px");
    nameDiv.css("font-weight", "bold");
    let iconUrl24 = trackdirect.services.symbolPathFinder.getFilePath(packet.symbol_table, packet.symbol, null, null, null, 24, 24);
    let iconImg = $(document.createElement("img"));
    iconImg.css("vertical-align", "middle");
    iconImg.css("width", "24px");
    iconImg.css("height", "24px");
    iconImg.attr("src", iconUrl24);
    iconImg.attr("alt", "");
    iconImg.attr("title", "");
    nameDiv.append(iconImg);
    nameDiv.append("&nbsp;");
    nameDiv.append("&nbsp;");
    let nameLink = $(document.createElement("a"));
    nameLink.css("color", "#337ab7");
    if (trackdirect.isMobile) {
        nameLink.css("vertical-align", "-2px");
    }
    nameLink.attr("href", "");
    nameLink.attr("onclick", "trackdirect.openStationInformationDialog(" + packet.station_id + "); return false;");
    nameLink.html(escapeHtml(packet.station_name));
    nameDiv.append(nameLink);
    if (packet.sender_name != packet.station_name) {
        nameDiv.append("&nbsp;(");
        let nameLink2 = $(document.createElement("span"));
        if (trackdirect.isMobile) {
            nameLink2.css("vertical-align", "-2px");
        }
        nameLink2.html(escapeHtml(packet.sender_name));
        nameDiv.append(nameLink2);
        nameDiv.append(")");
    }
    polylineDiv.append(nameDiv);
    let tailDistance = this._getTailDistance(this._defaultMap.markerCollection.getMarkerMasterMarkerKeyId(this._marker.markerIdKey));
    if (tailDistance !== null && Math.round(tailDistance) > 0) {
        let distanceDiv = $(document.createElement("div"));
        distanceDiv.css("clear", "both");
        distanceDiv.css("padding-top", "4px");
        distanceDiv.append("Tail distance: ");
        if (tailDistance < 1000) {
            if (this._defaultMap.state.useImperialUnit) {
                distanceDiv.append(Math.round(trackdirect.services.imperialConverter.convertMeterToYard(tailDistance)) + " yd ");
            } else {
                distanceDiv.append(Math.round(tailDistance) + " m ");
            }
        } else {
            if (this._defaultMap.state.useImperialUnit) {
                distanceDiv.append(Math.round(trackdirect.services.imperialConverter.convertKilometerToMile(tailDistance / 1000) * 10) / 10 + " miles ");
            } else {
                distanceDiv.append(Math.round(tailDistance / 100) / 10 + " km ");
            }
        }
        polylineDiv.append(distanceDiv);
    }
    mainDiv.append(polylineDiv);
    return mainDiv;
};
trackdirect.models.InfoWindow.prototype._getTailDistance = function (markerIdKey) {
    if (this._defaultMap.markerCollection.isExistingMarker(markerIdKey)) {
        let marker = this._defaultMap.markerCollection.getMarker(markerIdKey);
        if (marker.packet.hasConfirmedMapId() && marker.packet.is_moving == 1 && marker.overwrite !== true) {
            let distance = 0;
            if (this._defaultMap.markerCollection.hasDotMarkers(markerIdKey)) {
                let prevLatLng = null;
                let dotMarkers = this._defaultMap.markerCollection.getDotMarkers(markerIdKey);
                for (let i = 0; i < dotMarkers.length; i++) {
                    let dotMarker = dotMarkers[i];
                    let latLng = dotMarker.packet.getLatLngLiteral();
                    if (prevLatLng !== null) {
                        distance += trackdirect.services.distanceCalculator.getDistance(prevLatLng, latLng);
                    }
                    prevLatLng = latLng;
                }
                if (prevLatLng !== null) {
                    let latLng = marker.packet.getLatLngLiteral();
                    if (prevLatLng !== latLng) {
                        distance += trackdirect.services.distanceCalculator.getDistance(prevLatLng, latLng);
                    }
                }
            }
            let dashedPolyline = this._defaultMap.markerCollection.getMarkerDashedPolyline(markerIdKey);
            if (dashedPolyline !== null) {
                if (dashedPolyline.getPathLength() == 2) {
                    distance += trackdirect.services.distanceCalculator.getDistance(dashedPolyline.getPathItem(0), dashedPolyline.getPathItem(1));
                    distance += this._getTailDistance(dashedPolyline.relatedMarkerIdKey);
                }
            }
            return distance;
        }
    }
    return null;
};
trackdirect.models.InfoWindow.prototype._getTransmitDistance = function (packet) {
    if (typeof packet.station_location_path !== "undefined" && packet.station_location_path !== null && packet.station_location_path.length >= 1) {
        let relatedStationLatLng = { lat: parseFloat(packet.station_location_path[0][0]), lng: parseFloat(packet.station_location_path[0][1]) };
        let distance = trackdirect.services.distanceCalculator.getDistance(packet.getLatLngLiteral(), relatedStationLatLng);
        if (distance !== null) {
            return distance;
        }
    }
    if (typeof packet.station_id_path !== "undefined" && packet.station_id_path !== null && packet.station_id_path.length >= 1) {
        for (let i = 0; i < packet.station_id_path.length; i++) {
            let relatedStationId = packet.station_id_path[i];
            let relatedStationPacket = this._defaultMap.markerCollection.getStationLatestPacket(relatedStationId);
            if (relatedStationPacket !== null) {
                break;
            }
        }
        if (relatedStationPacket !== null) {
            let relatedStationLatLng = { lat: parseFloat(relatedStationPacket.latitude), lng: parseFloat(relatedStationPacket.longitude) };
            let distance = trackdirect.services.distanceCalculator.getDistance(packet.getLatLngLiteral(), relatedStationLatLng);
            if (distance !== null) {
                return distance;
            }
        }
    }
    return null;
};
trackdirect.models.HeatMap = function (map) {
    this._defaultMap = map;
    if (typeof google === "object" && typeof google.maps === "object") {
        const googleImageMapType = new google.maps.ImageMapType(this._getGoogleMapOptions());
        for (const key of Object.keys(this)) {
            googleImageMapType[key] = this[key];
        }
        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {
            if (key !== "constructor" && typeof this[key] === "function") {
                googleImageMapType[key] = this[key];
            }
        }
        return googleImageMapType;
    } else if (typeof L === "object") {
        L.TileLayer.call(this, this._getUrlTemplate(), this._getLeafletOptions());
    }
};
if (typeof google === "object" && typeof google.maps === "object") {
    trackdirect.models.HeatMap.prototype = Object.create(google.maps.ImageMapType.prototype);
} else if (typeof L === "object") {
    trackdirect.models.HeatMap.prototype = Object.create(L.TileLayer.prototype);
}
trackdirect.models.HeatMap.prototype.constructor = trackdirect.models.HeatMap;
trackdirect.models.HeatMap.prototype._getLeafletOptions = function () {
    let options = { errorTileUrl: trackdirect.settings.baseUrl + "/heatmaps/transparent.png", tileSize: 256, maxZoom: 9, minZoom: 0 };
    return options;
};
trackdirect.models.HeatMap.prototype._getGoogleMapOptions = function () {
    let me = this;
    let options = {
        getTileUrl: function (coord, zoom) {
            if (zoom > trackdirect.settings.minZoomForMarkers - 1) {
                return trackdirect.settings.baseUrl + "/heatmaps/transparent.png";
            }
            let normalizedCoord = me._getNormalizedCoord(coord, zoom);
            if (!normalizedCoord) {
                return trackdirect.settings.baseUrl + "/heatmaps/transparent.png";
            }
            let xString = String(normalizedCoord.x);
            let yString = String(normalizedCoord.y);
            return me._getUrlTemplate().replace("{z}", zoom).replace("{y}", yString).replace("{x}", xString);
        },
        tileSize: new google.maps.Size(256, 256),
        maxZoom: 9,
        minZoom: 0,
        radius: 1738000,
        name: "APRSHEAT",
    };
    return options;
};
trackdirect.models.HeatMap.prototype._getUrlTemplate = function () {
    return trackdirect.settings.baseUrl + "/heatmaps/latest-heatmap.{z}.{y}.{x}.png?version=" + this._getHeatMapVersion();
};
trackdirect.models.HeatMap.prototype._getHeatMapVersion = function () {
    let today = new Date();
    let dd = today.getDate();
    let mm = today.getMonth() + 1;
    let yyyy = today.getFullYear();
    let hh = today.getHours();
    if (dd < 10) {
        dd = "0" + dd;
    }
    if (mm < 10) {
        mm = "0" + mm;
    }
    return yyyy + "-" + mm + "-" + dd + "-" + hh;
};
trackdirect.models.HeatMap.prototype._getNormalizedCoord = function (coord, zoom) {
    let y = coord.y;
    let x = coord.x;
    let tileRange = 1 << zoom;
    if (y < 0 || y >= tileRange) {
        return null;
    }
    if (x < 0 || x >= tileRange) {
        x = ((x % tileRange) + tileRange) % tileRange;
    }
    return { x: x, y: y };
};
trackdirect.models.DirectionPolyline = function (marker, map) {
    this._marker = marker;
    this._defaultMap = map;
    this.startTimestamp = this._marker.packet.timestamp;
    this.speed = this._marker.packet.speed;
    this.course = this._marker.packet.course;
    this.stopped = false;
    this.timerId = null;
    if (typeof google === "object" && typeof google.maps === "object") {
        const googlePolyline = new google.maps.Polyline(this._getGooglePolylineOptions());
        for (const key of Object.keys(this)) {
            googlePolyline[key] = this[key];
        }
        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {
            if (key !== "constructor" && typeof this[key] === "function") {
                googlePolyline[key] = this[key];
            }
        }
        return googlePolyline;
    } else if (typeof L === "object") {
        L.Polyline.call(this, {}, this._getLeafletPolylineOptions());
        this.setLatLngs([this._getFirstCoordinate(), this._getExpectedCoordinate()]);
    }
};
if (typeof google === "object" && typeof google.maps === "object") {
    trackdirect.models.DirectionPolyline.prototype = Object.create(google.maps.Polyline.prototype);
} else if (typeof L === "object") {
    trackdirect.models.DirectionPolyline.prototype = Object.create(L.Polyline.prototype);
}
trackdirect.models.DirectionPolyline.prototype.constructor = trackdirect.models.DirectionPolyline;
trackdirect.models.DirectionPolyline.prototype.setPathItems = function (pathItems) {
    if (typeof google === "object" && typeof google.maps === "object") {
        this.setPath(pathItems);
    } else if (typeof L === "object") {
        this.setLatLngs(pathItems);
    }
};
trackdirect.models.DirectionPolyline.prototype.getMap = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        let map = google.maps.Polyline.prototype.getMap.call(this);
        if (typeof map !== "undefined") {
            return map;
        }
    } else if (typeof L === "object") {
        if (this._defaultMap.hasLayer(this)) {
            return this._defaultMap;
        }
    }
    return null;
};
trackdirect.models.DirectionPolyline.prototype.show = function () {
    let timeInSeconds = this._getAgeInSeconds();
    if (this.stopped === false && timeInSeconds <= 900 && this._marker.packet.hasConfirmedMapId() && (this._defaultMap.state.isFilterMode || this._defaultMap.getZoom() >= trackdirect.settings.minZoomForMarkerTail)) {
        if (typeof google === "object" && typeof google.maps === "object") {
            if (typeof this.getMap() === "undefined" || this.getMap() === null) {
                this.setMap(this._defaultMap);
            }
        } else if (typeof L === "object") {
            if (!this._defaultMap.hasLayer(this)) {
                this.addTo(this._defaultMap);
            }
        }
        this.recalculate();
    }
};
trackdirect.models.DirectionPolyline.prototype.hide = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (this.getMap() !== null) {
            this.setMap(null);
        }
    } else if (typeof L === "object") {
        if (this._defaultMap.hasLayer(this)) {
            this._defaultMap.removeLayer(this);
        }
    }
};
trackdirect.models.DirectionPolyline.prototype.stop = function () {
    this.stopped = true;
    this.hide();
};
trackdirect.models.DirectionPolyline.prototype._getGooglePolylineOptions = function () {
    let lineCoordinates = [this._getFirstCoordinate(), this._getExpectedCoordinate()];
    let lineSymbol = { path: google.maps.SymbolPath.FORWARD_OPEN_ARROW, strokeOpacity: 1, scale: 0.65 };
    let options = { path: lineCoordinates, strokeOpacity: 0, strokeColor: trackdirect.services.stationColorCalculator.getColor(this._marker.packet), map: null, icons: [{ icon: lineSymbol, offset: "0px", repeat: "8px" }] };
    return options;
};
trackdirect.models.DirectionPolyline.prototype._getLeafletPolylineOptions = function () {
    return { color: trackdirect.services.stationColorCalculator.getColor(this._marker.packet), weight: 4, opacity: 0.7, dashArray: "2,8", lineJoin: "round" };
};
trackdirect.models.DirectionPolyline.prototype._getFirstCoordinate = function () {
    return this._marker.packet.getLatLngLiteral();
};
trackdirect.models.DirectionPolyline.prototype._getExpectedCoordinate = function () {
    let timeInSeconds = this._getAgeInSeconds();
    let distance = (this.speed / 3.6) * timeInSeconds;
    let startPosition = this._getFirstCoordinate();
    if (startPosition != null) {
        return trackdirect.services.distanceCalculator.getPositionByDistance(startPosition, this.course, distance);
    }
    return null;
};
trackdirect.models.DirectionPolyline.prototype.recalculate = function () {
    let interval = 1000;
    let me = this;
    this.timerId = window.setInterval(function () {
        if (!me._marker.isVisible() || me.stopped || !me._marker.showAsMarker) {
            me.hide();
            clearInterval(me.timerId);
            return;
        }
        let timeInSeconds = me._getAgeInSeconds();
        if (timeInSeconds > 900) {
            me.stop();
            if (me.timerId !== null) {
                clearInterval(me.timerId);
            }
        } else {
            let firstPosition = me._getFirstCoordinate();
            let newPosition = me._getExpectedCoordinate();
            if (firstPosition != null && newPosition != null) {
                me.setPathItems([firstPosition, newPosition]);
            }
        }
    }, interval);
};
trackdirect.models.DirectionPolyline.prototype._getAgeInSeconds = function () {
    let timeInSeconds = 0;
    let startTimestamp = this._defaultMap.state.getClientTimestamp(this.startTimestamp);
    if (startTimestamp < Date.now() / 1000) {
        timeInSeconds = Date.now() / 1000 - startTimestamp;
    }
    return timeInSeconds;
};
trackdirect.models.DashedTailPolyline = function (color, map) {
    this._defaultMap = map;
    this.markerIdKey = null;
    this.ownerMarkerIdKey = null;
    this.relatedMarkerIdKey = null;
    if (typeof google === "object" && typeof google.maps === "object") {
        const googlePolyline = new google.maps.Polyline(this._getGooglePolylineOptions(color));
        for (const key of Object.keys(this)) {
            googlePolyline[key] = this[key];
        }
        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {
            if (key !== "constructor" && typeof this[key] === "function") {
                googlePolyline[key] = this[key];
            }
        }
        return googlePolyline;
    } else if (typeof L === "object") {
        L.Polyline.call(this, {}, this._getLeafletPolylineOptions(color));
    }
};
if (typeof google === "object" && typeof google.maps === "object") {
    trackdirect.models.DashedTailPolyline.prototype = Object.create(google.maps.Polyline.prototype);
} else if (typeof L === "object") {
    trackdirect.models.DashedTailPolyline.prototype = Object.create(L.Polyline.prototype);
}
trackdirect.models.DashedTailPolyline.prototype.constructor = trackdirect.models.DashedTailPolyline;
trackdirect.models.DashedTailPolyline.prototype.getPathItem = function (index) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let path = google.maps.Polyline.prototype.getPath.call(this);
        return path.getAt(index);
    } else if (typeof L === "object") {
        let list = this.getLatLngs();
        if (typeof list[index] !== "undefined") {
            return list[index];
        } else {
            return null;
        }
    }
    return null;
};
trackdirect.models.DashedTailPolyline.prototype.pushPathItem = function (latLng) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let path = google.maps.Polyline.prototype.getPath.call(this);
        path.push(latLng);
    } else if (typeof L === "object") {
        this.addLatLng(latLng);
    }
};
trackdirect.models.DashedTailPolyline.prototype.removePathItem = function (index) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let path = google.maps.Polyline.prototype.getPath.call(this);
        path.removeAt(index);
    } else if (typeof L === "object") {
        let list = this.getLatLngs();
        if (typeof list[index] !== "undefined") {
            list.splice(index, 1);
            this.setLatLngs(list);
        }
    }
};
trackdirect.models.DashedTailPolyline.prototype.getPathLength = function (index) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let path = google.maps.Polyline.prototype.getPath.call(this);
        return path.getLength();
    } else if (typeof L === "object") {
        let list = this.getLatLngs();
        return list.length;
    }
};
trackdirect.models.DashedTailPolyline.prototype.getPath = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        return google.maps.Polyline.prototype.getPath.call(this).getArray();
    } else if (typeof L === "object") {
        return this.getLatLngs();
    }
    return [];
};
trackdirect.models.DashedTailPolyline.prototype.getMap = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        let map = google.maps.Polyline.prototype.getMap.call(this);
        if (typeof map !== "undefined") {
            return map;
        }
    } else if (typeof L === "object") {
        if (this._defaultMap.hasLayer(this)) {
            return this._defaultMap;
        }
    }
    return null;
};
trackdirect.models.DashedTailPolyline.prototype.setMarkerIdKey = function (markerIdKey) {
    this.markerIdKey = markerIdKey;
    this.ownerMarkerIdKey = markerIdKey;
    this._addInfoWindowListener(markerIdKey);
};
trackdirect.models.DashedTailPolyline.prototype.setRelatedMarkerIdKey = function (markerIdKey) {
    this.relatedMarkerIdKey = markerIdKey;
};
trackdirect.models.DashedTailPolyline.prototype.show = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (typeof this.getMap() === "undefined" || this.getMap() === null) {
            this.setMap(this._defaultMap);
        }
    } else if (typeof L === "object") {
        if (!this._defaultMap.hasLayer(this)) {
            this.addTo(this._defaultMap);
        }
    }
};
trackdirect.models.DashedTailPolyline.prototype.hide = function () {
    if (typeof google === "object" && typeof google.maps === "object") {
        if (this.getMap() !== null) {
            this.setMap(null);
        }
    } else if (typeof L === "object") {
        if (this._defaultMap.hasLayer(this)) {
            this._defaultMap.removeLayer(this);
        }
    }
};
trackdirect.models.DashedTailPolyline.prototype.addPacket = function (packet) {
    if (typeof google === "object" && typeof google.maps === "object") {
        let latLng = new google.maps.LatLng(parseFloat(packet.latitude), parseFloat(packet.longitude));
        this.pushPathItem(latLng);
    } else if (typeof L === "object") {
        let latLng = new L.latLng(parseFloat(packet.latitude), parseFloat(packet.longitude));
        this.addLatLng(latLng);
    }
};
trackdirect.models.DashedTailPolyline.prototype._addInfoWindowListener = function (markerIdKey) {
    let me = this;
    if (typeof google === "object" && typeof google.maps === "object") {
        google.maps.event.addListener(this, "click", function (event) {
            let marker = me._defaultMap.markerCollection.getMarker(markerIdKey);
            me._defaultMap.openPolylineInfoWindow(marker, event.latLng);
        });
    } else if (typeof L === "object") {
        this.on("click", function (event) {
            let marker = me._defaultMap.markerCollection.getMarker(markerIdKey);
            me._defaultMap.openPolylineInfoWindow(marker, event.latlng);
        });
    }
};
trackdirect.models.DashedTailPolyline.prototype._getGooglePolylineOptions = function (color) {
    let lineSymbol = { path: "M 0,-1 0,1", strokeOpacity: 0.4, scale: 3 };
    let options = { geodesic: false, strokeOpacity: 0, strokeColor: color, icons: [{ icon: lineSymbol, offset: "20px", repeat: "15px" }], map: null, zIndex: 100 };
    return options;
};
trackdirect.models.DashedTailPolyline.prototype._getLeafletPolylineOptions = function (color) {
    return { opacity: 0.6, weight: 3, dashArray: "6,8", lineJoin: "round", color: color };
};
